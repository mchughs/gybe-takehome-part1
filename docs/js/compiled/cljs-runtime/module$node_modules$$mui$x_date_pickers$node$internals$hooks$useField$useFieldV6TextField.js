shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldV6TextField = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.useFieldV6TextField = exports.addPositionPropertiesToSections = void 0;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _styles = require("module$node_modules$$mui$material$node$styles$index"), _useEventCallback = global(require("module$node_modules$$mui$utils$node$useEventCallback$index")), _useForkRef = global(require("module$node_modules$$mui$utils$node$useForkRef$index")), _utils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$utils"), _useField = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils");
  const cleanString = dirtyString => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, ""), addPositionPropertiesToSections = (sections, localizedDigits, isRTL) => {
    let position = 0, positionInInput = isRTL ? 1 : 0;
    const newSections = [];
    for (let i = 0; i < sections.length; i += 1) {
      const section = sections[i];
      var renderedValue = (0,_useField.getSectionVisibleValue)(section, isRTL ? "input-rtl" : "input-ltr", localizedDigits), sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
      const sectionLength = cleanString(sectionStr).length;
      sectionStr = sectionStr.length;
      const cleanedValue = cleanString(renderedValue);
      renderedValue = positionInInput + ("" === cleanedValue ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;
      newSections.push((0,_extends2.default)({}, section, {start:position, end:position + sectionLength, startInInput:renderedValue, endInInput:renderedValue + cleanedValue.length}));
      position += sectionLength;
      positionInInput += sectionStr;
    }
    return newSections;
  };
  exports.addPositionPropertiesToSections = addPositionPropertiesToSections;
  exports.useFieldV6TextField = params => {
    const isRTL = "rtl" === (0,_styles.useTheme)().direction, focusTimeoutRef = React.useRef(), {forwardedProps:{onFocus, onClick, onPaste, onBlur, inputRef:inputRefProp}, internalProps:{readOnly = !1}, parsedSelectedSections, activeSectionIndex, state, fieldValueManager, valueManager, applyCharacterEditing, resetCharacterQuery, updateSectionValue, updateValueFromValueStr, clearActiveSection, clearValue, setTempAndroidValueStr, setSelectedSections, getSectionsFromValue, areAllSectionsEmpty, localizedDigits} = 
    params, inputRef = React.useRef(null);
    params = (0,_useForkRef.default)(inputRefProp, inputRef);
    const sections = React.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRTL), [state.sections, localizedDigits, isRTL]), interactions = React.useMemo(() => ({syncSelectionToDOM:() => {
      if (inputRef.current) {
        if (null == parsedSelectedSections) {
          inputRef.current.scrollLeft && (inputRef.current.scrollLeft = 0);
        } else {
          if (inputRef.current === (0,_utils.getActiveElement)(document)) {
            var currentScrollTop = inputRef.current.scrollTop;
            if ("all" === parsedSelectedSections) {
              inputRef.current.select();
            } else {
              var selectedSection = sections[parsedSelectedSections];
              const selectionStart = "empty" === selectedSection.type ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;
              selectedSection = "empty" === selectedSection.type ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;
              selectionStart === inputRef.current.selectionStart && selectedSection === inputRef.current.selectionEnd || inputRef.current !== (0,_utils.getActiveElement)(document) || inputRef.current.setSelectionRange(selectionStart, selectedSection);
            }
            inputRef.current.scrollTop = currentScrollTop;
          }
        }
      }
    }, getActiveSectionIndexFromDOM:() => {
      const browserStartIndex = inputRef.current.selectionStart ?? 0;
      var browserEndIndex = inputRef.current.selectionEnd ?? 0;
      if (0 === browserStartIndex && 0 === browserEndIndex) {
        return null;
      }
      browserEndIndex = browserStartIndex <= sections[0].startInInput ? 1 : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);
      return -1 === browserEndIndex ? sections.length - 1 : browserEndIndex - 1;
    }, focusField:(newSelectedSection = 0) => {
      inputRef.current?.focus();
      setSelectedSections(newSelectedSection);
    }, setSelectedSections:newSelectedSections => setSelectedSections(newSelectedSections), isFieldFocused:() => inputRef.current === (0,_utils.getActiveElement)(document)}), [inputRef, parsedSelectedSections, sections, setSelectedSections]), syncSelectionFromDOM = () => {
      if (readOnly) {
        setSelectedSections(null);
      } else {
        var browserStartIndex = inputRef.current.selectionStart ?? 0;
        var nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 : browserStartIndex >= sections[sections.length - 1].endInInput ? 1 : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);
        setSelectedSections(-1 === nextSectionIndex ? sections.length - 1 : nextSectionIndex - 1);
      }
    }, handleInputFocus = (0,_useEventCallback.default)((...args) => {
      onFocus?.(...args);
      const input = inputRef.current;
      clearTimeout(focusTimeoutRef.current);
      focusTimeoutRef.current = setTimeout(() => {
        input && input === inputRef.current && (null != activeSectionIndex || readOnly || (input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length ? setSelectedSections("all") : syncSelectionFromDOM()));
      });
    }), handleInputClick = (0,_useEventCallback.default)((event, ...args) => {
      event.isDefaultPrevented() || (onClick?.(event, ...args), syncSelectionFromDOM());
    }), handleInputPaste = (0,_useEventCallback.default)(event => {
      onPaste?.(event);
      event.preventDefault();
      if (!readOnly) {
        event = event.clipboardData.getData("text");
        if ("number" === typeof parsedSelectedSections) {
          const activeSection = state.sections[parsedSelectedSections], lettersOnly = /^[a-zA-Z]+$/.test(event), digitsOnly = /^[0-9]+$/.test(event), digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(event);
          if ("letter" === activeSection.contentType && lettersOnly || "digit" === activeSection.contentType && digitsOnly || "digit-with-letter" === activeSection.contentType && digitsAndLetterOnly) {
            resetCharacterQuery();
            updateSectionValue({activeSection, newSectionValue:event, shouldGoToNextSection:!0});
            return;
          }
          if (lettersOnly || digitsOnly) {
            return;
          }
        }
        resetCharacterQuery();
        updateValueFromValueStr(event);
      }
    }), handleContainerBlur = (0,_useEventCallback.default)((...args) => {
      onBlur?.(...args);
      setSelectedSections(null);
    }), handleInputChange = (0,_useEventCallback.default)(event => {
      if (!readOnly) {
        var targetValue = event.target.value;
        if ("" === targetValue) {
          resetCharacterQuery(), clearValue();
        } else {
          var eventData = event.nativeEvent.data, shouldUseEventData = eventData && 1 < eventData.length;
          targetValue = shouldUseEventData ? eventData : targetValue;
          event = cleanString(targetValue);
          if (null == activeSectionIndex || shouldUseEventData) {
            updateValueFromValueStr(shouldUseEventData ? eventData : event);
          } else {
            if ("all" !== parsedSelectedSections || 1 !== event.length) {
              eventData = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRTL));
              let endOfDiffIndex = shouldUseEventData = -1;
              for (var i = 0; i < eventData.length; i += 1) {
                -1 === shouldUseEventData && eventData[i] !== event[i] && (shouldUseEventData = i), -1 === endOfDiffIndex && eventData[eventData.length - i - 1] !== event[event.length - i - 1] && (endOfDiffIndex = i);
              }
              i = sections[activeSectionIndex];
              if (shouldUseEventData < i.start || eventData.length - endOfDiffIndex - 1 > i.end) {
                return;
              }
              eventData = event.length - eventData.length + i.end - cleanString(i.endSeparator || "").length;
              event = event.slice(i.start + cleanString(i.startSeparator || "").length, eventData);
            }
            0 === event.length ? (0,_useField.isAndroid)() ? setTempAndroidValueStr(targetValue) : (resetCharacterQuery(), clearActiveSection()) : applyCharacterEditing({keyPressed:event, sectionIndex:activeSectionIndex});
          }
        }
      }
    }), placeholder = React.useMemo(() => fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRTL), [fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRTL]), valueStr = React.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRTL), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRTL]);
    React.useEffect(() => {
      inputRef.current && inputRef.current === (0,_utils.getActiveElement)(document) && setSelectedSections("all");
      return () => {
        clearTimeout(focusTimeoutRef.current);
      };
    }, []);
    const inputMode = React.useMemo(() => null == activeSectionIndex || "letter" === state.sections[activeSectionIndex].contentType ? "text" : "numeric", [activeSectionIndex, state.sections]), inputHasFocus = inputRef.current && inputRef.current === (0,_utils.getActiveElement)(document);
    return {interactions, returnedValue:{readOnly, onBlur:handleContainerBlur, onClick:handleInputClick, onFocus:handleInputFocus, onPaste:handleInputPaste, inputRef:params, enableAccessibleFieldDOMStructure:!1, placeholder, inputMode, autoComplete:"off", value:!inputHasFocus && areAllSectionsEmpty ? "" : valueStr, onChange:handleInputChange}};
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldV6TextField.js.map
