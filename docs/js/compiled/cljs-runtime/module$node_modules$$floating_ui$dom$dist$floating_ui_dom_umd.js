shadow$provide.module$node_modules$$floating_ui$dom$dist$floating_ui_dom_umd = function(global, require, module, exports) {
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? factory(exports, require("module$node_modules$$floating_ui$core$dist$floating_ui_core_umd")) : "function" === typeof define && define.amd ? define(["exports", "@floating-ui/core"], factory) : (global = "undefined" !== typeof globalThis ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));
  })(this, function(exports, core) {
    function getNodeName(node) {
      return isNode(node) ? (node.nodeName || "").toLowerCase() : "#document";
    }
    function getWindow(node) {
      var _node$ownerDocument;
      return (null == node || null == (_node$ownerDocument = node.ownerDocument) ? void 0 : _node$ownerDocument.defaultView) || window;
    }
    function getDocumentElement(node) {
      var _ref;
      return null == (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) ? void 0 : _ref.documentElement;
    }
    function isNode(value) {
      return value instanceof Node || value instanceof getWindow(value).Node;
    }
    function isElement(value) {
      return value instanceof Element || value instanceof getWindow(value).Element;
    }
    function isHTMLElement(value) {
      return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
    }
    function isShadowRoot(value) {
      return "undefined" === typeof ShadowRoot ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
    }
    function isOverflowElement(element) {
      const {overflow, overflowX, overflowY, display} = getComputedStyle(element);
      return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
    }
    function isContainingBlock(element) {
      const webkit = isWebKit(), css = getComputedStyle(element);
      return "none" !== css.transform || "none" !== css.perspective || (css.containerType ? "normal" !== css.containerType : !1) || !webkit && (css.backdropFilter ? "none" !== css.backdropFilter : !1) || !webkit && (css.filter ? "none" !== css.filter : !1) || ["transform", "perspective", "filter"].some(value => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some(value => (css.contain || "").includes(value));
    }
    function isWebKit() {
      return "undefined" !== typeof CSS && CSS.supports ? CSS.supports("-webkit-backdrop-filter", "none") : !1;
    }
    function isLastTraversableNode(node) {
      return ["html", "body", "#document"].includes(getNodeName(node));
    }
    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function getNodeScroll(element) {
      return isElement(element) ? {scrollLeft:element.scrollLeft, scrollTop:element.scrollTop} : {scrollLeft:element.pageXOffset, scrollTop:element.pageYOffset};
    }
    function getParentNode(node) {
      if ("html" === getNodeName(node)) {
        return node;
      }
      node = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
      return isShadowRoot(node) ? node.host : node;
    }
    function getNearestOverflowAncestor(node) {
      const parentNode = getParentNode(node);
      return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list, traverseIframes) {
      var _node$ownerDocument2;
      void 0 === list && (list = []);
      void 0 === traverseIframes && (traverseIframes = !0);
      const scrollableAncestor = getNearestOverflowAncestor(node);
      node = scrollableAncestor === (null == (_node$ownerDocument2 = node.ownerDocument) ? void 0 : _node$ownerDocument2.body);
      _node$ownerDocument2 = getWindow(scrollableAncestor);
      return node ? list.concat(_node$ownerDocument2, _node$ownerDocument2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], _node$ownerDocument2.frameElement && traverseIframes ? getOverflowAncestors(_node$ownerDocument2.frameElement) : []) : list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
    }
    function getCssDimensions(element) {
      var css = getComputedStyle(element);
      let width = parseFloat(css.width) || 0;
      css = parseFloat(css.height) || 0;
      var hasOffset = isHTMLElement(element);
      const offsetWidth = hasOffset ? element.offsetWidth : width;
      element = hasOffset ? element.offsetHeight : css;
      if (hasOffset = round(width) !== offsetWidth || round(css) !== element) {
        width = offsetWidth, css = element;
      }
      return {width, height:css, $:hasOffset};
    }
    function unwrapElement(element) {
      return isElement(element) ? element : element.contextElement;
    }
    function getScale(element) {
      var domElement = unwrapElement(element);
      if (!isHTMLElement(domElement)) {
        return {x:1, y:1};
      }
      element = domElement.getBoundingClientRect();
      const {width, height, $} = getCssDimensions(domElement);
      domElement = ($ ? round(element.width) : element.width) / width;
      element = ($ ? round(element.height) : element.height) / height;
      domElement && Number.isFinite(domElement) || (domElement = 1);
      element && Number.isFinite(element) || (element = 1);
      return {x:domElement, y:element};
    }
    function getVisualOffsets(element) {
      element = getWindow(element);
      return isWebKit() && element.visualViewport ? {x:element.visualViewport.offsetLeft, y:element.visualViewport.offsetTop} : noOffsets;
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
      void 0 === includeScale && (includeScale = !1);
      void 0 === isFixedStrategy && (isFixedStrategy = !1);
      var clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element), scale = {x:1, y:1};
      includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));
      element = isFixedStrategy;
      void 0 === element && (element = !1);
      element = !offsetParent || element && offsetParent !== getWindow(domElement) ? !1 : element;
      includeScale = element ? getVisualOffsets(domElement) : {x:0, y:0};
      element = (clientRect.left + includeScale.x) / scale.x;
      includeScale = (clientRect.top + includeScale.y) / scale.y;
      isFixedStrategy = clientRect.width / scale.x;
      clientRect = clientRect.height / scale.y;
      if (domElement) {
        scale = getWindow(domElement);
        domElement = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
        var currentWin = scale;
        for (scale = currentWin.frameElement; scale && offsetParent && domElement !== currentWin;) {
          currentWin = getScale(scale);
          var iframeRect = scale.getBoundingClientRect();
          const css = getComputedStyle(scale), left = iframeRect.left + (scale.clientLeft + parseFloat(css.paddingLeft)) * currentWin.x;
          iframeRect = iframeRect.top + (scale.clientTop + parseFloat(css.paddingTop)) * currentWin.y;
          element *= currentWin.x;
          includeScale *= currentWin.y;
          isFixedStrategy *= currentWin.x;
          clientRect *= currentWin.y;
          element += left;
          includeScale += iframeRect;
          currentWin = getWindow(scale);
          scale = currentWin.frameElement;
        }
      }
      return core.rectToClientRect({width:isFixedStrategy, height:clientRect, x:element, y:includeScale});
    }
    function isTopLayer(floating) {
      return topLayerSelectors.some(selector => {
        try {
          return floating.matches(selector);
        } catch (e) {
          return !1;
        }
      });
    }
    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
      if ("viewport" === clippingAncestor) {
        clippingAncestor = getWindow(element);
        var html = getDocumentElement(element);
        clippingAncestor = clippingAncestor.visualViewport;
        element = html.clientWidth;
        html = html.clientHeight;
        var x = 0, y = 0;
        if (clippingAncestor) {
          element = clippingAncestor.width;
          html = clippingAncestor.height;
          var visualViewportBased = isWebKit();
          if (!visualViewportBased || visualViewportBased && "fixed" === strategy) {
            x = clippingAncestor.offsetLeft, y = clippingAncestor.offsetTop;
          }
        }
        strategy = {width:element, height:html, x, y};
      } else {
        "document" === clippingAncestor ? (visualViewportBased = getDocumentElement(element), strategy = getDocumentElement(visualViewportBased), x = getNodeScroll(visualViewportBased), clippingAncestor = visualViewportBased.ownerDocument.body, element = max(strategy.scrollWidth, strategy.clientWidth, clippingAncestor.scrollWidth, clippingAncestor.clientWidth), html = max(strategy.scrollHeight, strategy.clientHeight, clippingAncestor.scrollHeight, clippingAncestor.clientHeight), y = -x.scrollLeft, 
        visualViewportBased = getBoundingClientRect(getDocumentElement(visualViewportBased)).left + getNodeScroll(visualViewportBased).scrollLeft, y += visualViewportBased, x = -x.scrollTop, "rtl" === getComputedStyle(clippingAncestor).direction && (y += max(strategy.clientWidth, clippingAncestor.clientWidth) - element), strategy = {width:element, height:html, x:y, y:x}) : isElement(clippingAncestor) ? (element = getBoundingClientRect(clippingAncestor, !0, "fixed" === strategy), strategy = element.top + 
        clippingAncestor.clientTop, element = element.left + clippingAncestor.clientLeft, html = isHTMLElement(clippingAncestor) ? getScale(clippingAncestor) : {x:1, y:1}, strategy = {width:clippingAncestor.clientWidth * html.x, height:clippingAncestor.clientHeight * html.y, x:element * html.x, y:strategy * html.y}) : (strategy = getVisualOffsets(element), strategy = {...clippingAncestor, x:clippingAncestor.x - strategy.x, y:clippingAncestor.y - strategy.y});
      }
      return core.rectToClientRect(strategy);
    }
    function hasFixedPositionAncestor(element, stopNode) {
      element = getParentNode(element);
      return element === stopNode || !isElement(element) || isLastTraversableNode(element) ? !1 : "fixed" === getComputedStyle(element).position || hasFixedPositionAncestor(element, stopNode);
    }
    function getClippingElementAncestors(element, cache) {
      var cachedResult = cache.get(element);
      if (cachedResult) {
        return cachedResult;
      }
      cachedResult = getOverflowAncestors(element, [], !1).filter(el => isElement(el) && "body" !== getNodeName(el));
      let currentContainingBlockComputedStyle = null;
      const elementIsFixed = "fixed" === getComputedStyle(element).position;
      let currentNode = elementIsFixed ? getParentNode(element) : element;
      for (; isElement(currentNode) && !isLastTraversableNode(currentNode);) {
        const computedStyle = getComputedStyle(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
        currentNodeIsContaining || "fixed" !== computedStyle.position || (currentContainingBlockComputedStyle = null);
        (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && "static" === computedStyle.position && currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? cachedResult = cachedResult.filter(ancestor => ancestor !== currentNode) : currentContainingBlockComputedStyle = 
        computedStyle;
        currentNode = getParentNode(currentNode);
      }
      cache.set(element, cachedResult);
      return cachedResult;
    }
    function getTrueOffsetParent(element, polyfill) {
      return isHTMLElement(element) && "fixed" !== getComputedStyle(element).position ? polyfill ? polyfill(element) : element.offsetParent : null;
    }
    function getOffsetParent(element, polyfill) {
      const window = getWindow(element);
      if (!isHTMLElement(element) || isTopLayer(element)) {
        return window;
      }
      let offsetParent = getTrueOffsetParent(element, polyfill);
      for (; offsetParent && ["table", "td", "th"].includes(getNodeName(offsetParent)) && "static" === getComputedStyle(offsetParent).position;) {
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
      }
      if (offsetParent && ("html" === getNodeName(offsetParent) || "body" === getNodeName(offsetParent) && "static" === getComputedStyle(offsetParent).position && !isContainingBlock(offsetParent))) {
        return window;
      }
      if (!(polyfill = offsetParent)) {
        a: {
          for (element = getParentNode(element); isHTMLElement(element) && !isLastTraversableNode(element);) {
            if (isContainingBlock(element)) {
              polyfill = element;
              break a;
            }
            element = getParentNode(element);
          }
          polyfill = null;
        }
      }
      return polyfill || window;
    }
    function observeMove(element, onMove) {
      function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        null == (_io = io) || _io.disconnect();
        io = null;
      }
      function refresh(skip, threshold) {
        function handleObserve(entries) {
          entries = entries[0].intersectionRatio;
          if (entries !== threshold) {
            if (!isFirstUpdate) {
              return refresh();
            }
            entries ? refresh(!1, entries) : timeoutId = setTimeout(() => {
              refresh(!1, 1e-7);
            }, 100);
          }
          isFirstUpdate = !1;
        }
        void 0 === skip && (skip = !1);
        void 0 === threshold && (threshold = 1);
        cleanup();
        const {left, top, width, height} = element.getBoundingClientRect();
        skip || onMove();
        if (width && height) {
          skip = floor(top);
          var insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top + height)), insetLeft = floor(left);
          skip = {rootMargin:-skip + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px", threshold:max(0, min(1, threshold)) || 1};
          var isFirstUpdate = !0;
          try {
            io = new IntersectionObserver(handleObserve, {...skip, root:root.ownerDocument});
          } catch (e) {
            io = new IntersectionObserver(handleObserve, skip);
          }
          io.observe(element);
        }
      }
      let io = null, timeoutId;
      const root = getDocumentElement(element);
      refresh(!0);
      return cleanup;
    }
    const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, noOffsets = {x:0, y:0}, topLayerSelectors = [":popover-open", ":modal"], platform = {convertOffsetParentRelativeRectToViewportRelativeRect:function(_ref) {
      let {elements, rect, offsetParent, strategy} = _ref;
      _ref = "fixed" === strategy;
      const documentElement = getDocumentElement(offsetParent);
      var topLayer = elements ? isTopLayer(elements.floating) : !1;
      if (offsetParent === documentElement || topLayer && _ref) {
        return rect;
      }
      topLayer = {scrollLeft:0, scrollTop:0};
      let scale = {x:1, y:1};
      var JSCompiler_object_inline_x_766 = 0, JSCompiler_object_inline_y_767 = 0;
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !_ref) {
        if ("body" !== getNodeName(offsetParent) || isOverflowElement(documentElement)) {
          topLayer = getNodeScroll(offsetParent);
        }
        isHTMLElement(offsetParent) && (_ref = getBoundingClientRect(offsetParent), scale = getScale(offsetParent), JSCompiler_object_inline_x_766 = _ref.x + offsetParent.clientLeft, JSCompiler_object_inline_y_767 = _ref.y + offsetParent.clientTop);
      }
      return {width:rect.width * scale.x, height:rect.height * scale.y, x:rect.x * scale.x - topLayer.scrollLeft * scale.x + JSCompiler_object_inline_x_766, y:rect.y * scale.y - topLayer.scrollTop * scale.y + JSCompiler_object_inline_y_767};
    }, getDocumentElement, getClippingRect:function(_ref) {
      let {element, boundary, rootBoundary, strategy} = _ref;
      _ref = [...("clippingAncestors" === boundary ? getClippingElementAncestors(element, this._c) : [].concat(boundary)), rootBoundary];
      _ref = _ref.reduce((accRect, clippingAncestor) => {
        clippingAncestor = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = max(clippingAncestor.top, accRect.top);
        accRect.right = min(clippingAncestor.right, accRect.right);
        accRect.bottom = min(clippingAncestor.bottom, accRect.bottom);
        accRect.left = max(clippingAncestor.left, accRect.left);
        return accRect;
      }, getClientRectFromClippingAncestor(element, _ref[0], strategy));
      return {width:_ref.right - _ref.left, height:_ref.bottom - _ref.top, x:_ref.left, y:_ref.top};
    }, getOffsetParent, getElementRects:async function(data) {
      const getDimensionsFn = this.getDimensions;
      var element = data.reference, offsetParent = await (this.getOffsetParent || getOffsetParent)(data.floating), strategy = data.strategy, isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      strategy = "fixed" === strategy;
      element = getBoundingClientRect(element, !0, strategy, offsetParent);
      let scroll = {scrollLeft:0, scrollTop:0};
      var JSCompiler_object_inline_x_868 = 0, JSCompiler_object_inline_y_869 = 0;
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !strategy) {
        if ("body" !== getNodeName(offsetParent) || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        isOffsetParentAnElement ? (isOffsetParentAnElement = getBoundingClientRect(offsetParent, !0, strategy, offsetParent), JSCompiler_object_inline_x_868 = isOffsetParentAnElement.x + offsetParent.clientLeft, JSCompiler_object_inline_y_869 = isOffsetParentAnElement.y + offsetParent.clientTop) : documentElement && (JSCompiler_object_inline_x_868 = getBoundingClientRect(getDocumentElement(documentElement)).left + getNodeScroll(documentElement).scrollLeft);
      }
      return {reference:{x:element.left + scroll.scrollLeft - JSCompiler_object_inline_x_868, y:element.top + scroll.scrollTop - JSCompiler_object_inline_y_869, width:element.width, height:element.height}, floating:{x:0, y:0, ...(await getDimensionsFn(data.floating))}};
    }, getClientRects:function(element) {
      return Array.from(element.getClientRects());
    }, getDimensions:function(element) {
      const {width, height} = getCssDimensions(element);
      return {width, height};
    }, getScale, isElement, isRTL:function(element) {
      return "rtl" === getComputedStyle(element).direction;
    }}, autoPlacement = core.autoPlacement, shift = core.shift, flip = core.flip, size = core.size, hide = core.hide, arrow = core.arrow, inline = core.inline, limitShift = core.limitShift;
    Object.defineProperty(exports, "detectOverflow", {enumerable:!0, get:function() {
      return core.detectOverflow;
    }});
    Object.defineProperty(exports, "offset", {enumerable:!0, get:function() {
      return core.offset;
    }});
    exports.arrow = arrow;
    exports.autoPlacement = autoPlacement;
    exports.autoUpdate = function(reference, floating, update, options) {
      function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        !prevRefRect || nextRefRect.x === prevRefRect.x && nextRefRect.y === prevRefRect.y && nextRefRect.width === prevRefRect.width && nextRefRect.height === prevRefRect.height || update();
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
      }
      void 0 === options && (options = {});
      const {ancestorScroll = !0, ancestorResize = !0, elementResize = "function" === typeof ResizeObserver, layoutShift = "function" === typeof IntersectionObserver, animationFrame = !1} = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
      ancestors.forEach(ancestor => {
        ancestorScroll && ancestor.addEventListener("scroll", update, {passive:!0});
        ancestorResize && ancestor.addEventListener("resize", update);
      });
      const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
      let reobserveFrame = -1, resizeObserver = null;
      elementResize && (resizeObserver = new ResizeObserver(_ref => {
        [_ref] = _ref;
        _ref && _ref.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          null == (_resizeObserver = resizeObserver) || _resizeObserver.observe(floating);
        }));
        update();
      }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
      let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
      animationFrame && frameLoop();
      update();
      return () => {
        var _resizeObserver2;
        ancestors.forEach(ancestor => {
          ancestorScroll && ancestor.removeEventListener("scroll", update);
          ancestorResize && ancestor.removeEventListener("resize", update);
        });
        null == cleanupIo || cleanupIo();
        null == (_resizeObserver2 = resizeObserver) || _resizeObserver2.disconnect();
        resizeObserver = null;
        animationFrame && cancelAnimationFrame(frameId);
      };
    };
    exports.computePosition = (reference, floating, options) => {
      const cache = new Map();
      options = {platform, ...options};
      return core.computePosition(reference, floating, {...options, platform:{...options.platform, _c:cache}});
    };
    exports.flip = flip;
    exports.getOverflowAncestors = getOverflowAncestors;
    exports.hide = hide;
    exports.inline = inline;
    exports.limitShift = limitShift;
    exports.platform = platform;
    exports.shift = shift;
    exports.size = size;
  });
};

//# sourceMappingURL=module$node_modules$$floating_ui$dom$dist$floating_ui_dom_umd.js.map
