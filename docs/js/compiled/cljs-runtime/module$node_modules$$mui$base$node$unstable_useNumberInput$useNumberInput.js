shadow$provide.module$node_modules$$mui$base$node$unstable_useNumberInput$useNumberInput = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function getInputValueAsString(v) {
    return v ? String(v.trim()) : String(v);
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getInputValueAsString = getInputValueAsString;
  exports.useNumberInput = function(parameters) {
    var _ref;
    const {min, max, step, shiftMultiplier = 10, defaultValue:defaultValueProp, disabled:disabledProp = !1, error:errorProp = !1, onBlur, onInputChange, onFocus, onChange, required:requiredProp = !1, readOnly:readOnlyProp = !1, value:valueProp, inputRef:inputRefProp, inputId:inputIdProp, componentName = "useNumberInput"} = parameters, formControlContext = (0,_FormControl.useFormControlContext)(), {current:isControlled} = React.useRef(null != valueProp);
    var handleInputRefWarning = React.useCallback(instance => {
      instance && "INPUT" !== instance.nodeName && !instance.focus && console.error("MUI: You have provided a `slots.input` to the input component\nthat does not correctly handle the `ref` prop.\nMake sure the `ref` prop is called with a HTMLInputElement.");
    }, []);
    const inputRef = React.useRef(null), handleInputRef = (0,_utils.unstable_useForkRef)(inputRef, inputRefProp, handleInputRefWarning), inputId = (0,_utils.unstable_useId)(inputIdProp), [focused, setFocused] = React.useState(!1);
    handleInputRefWarning = React.useCallback((event, field, fieldValue, reason) => {
      if ("value" === field && "string" !== typeof fieldValue) {
        switch(reason) {
          case "numberInput:clamp":
            null == onChange || onChange(event, fieldValue);
            break;
          case "numberInput:increment":
          case "numberInput:decrement":
          case "numberInput:incrementToMax":
          case "numberInput:decrementToMin":
            null == onChange || onChange(event, fieldValue);
        }
      }
    }, [onChange]);
    const numberInputActionContext = React.useMemo(() => ({min, max, step, shiftMultiplier, getInputValueAsString}), [min, max, step, shiftMultiplier]);
    var initialValue = null != (_ref = null != valueProp ? valueProp : defaultValueProp) ? _ref : null;
    _ref = {value:initialValue, inputValue:initialValue ? String(initialValue) : ""};
    initialValue = React.useMemo(() => ({value:valueProp}), [valueProp]);
    const [state, dispatch] = (0,_useControllableReducer.useControllableReducer)({reducer:_numberInputReducer.numberInputReducer, controlledProps:initialValue, initialState:_ref, onStateChange:handleInputRefWarning, actionContext:React.useMemo(() => numberInputActionContext, [numberInputActionContext]), componentName}), {value, inputValue} = state;
    React.useEffect(() => {
      !formControlContext && disabledProp && focused && (setFocused(!1), null == onBlur || onBlur());
    }, [formControlContext, disabledProp, focused, onBlur]);
    React.useEffect(() => {
      isControlled && (0,_utils2.isNumber)(value) && dispatch({type:_numberInputAction.NumberInputActionTypes.resetInputValue});
    }, [value, dispatch, isControlled]);
    const createHandleFocus = otherHandlers => event => {
      var _otherHandlers$onFocu;
      null == (_otherHandlers$onFocu = otherHandlers.onFocus) || _otherHandlers$onFocu.call(otherHandlers, event);
      if (!event.defaultMuiPrevented && !event.defaultPrevented) {
        if (formControlContext && formControlContext.onFocus) {
          var _formControlContext$o;
          null == formControlContext || null == (_formControlContext$o = formControlContext.onFocus) || _formControlContext$o.call(formControlContext);
        }
        setFocused(!0);
      }
    }, createHandleInputChange = otherHandlers => event => {
      var _formControlContext$o2, _otherHandlers$onInpu;
      if (!isControlled && null === event.target) {
        throw Error("MUI: Expected valid input target. Did you use a custom `slots.input` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.");
      }
      null == formControlContext || null == (_formControlContext$o2 = formControlContext.onChange) || _formControlContext$o2.call(formControlContext, event);
      null == (_otherHandlers$onInpu = otherHandlers.onInputChange) || _otherHandlers$onInpu.call(otherHandlers, event);
      event.defaultMuiPrevented || event.defaultPrevented || dispatch({type:_numberInputAction.NumberInputActionTypes.inputChange, event, inputValue:event.currentTarget.value});
    }, createHandleBlur = otherHandlers => event => {
      var _otherHandlers$onBlur;
      null == formControlContext || formControlContext.onBlur();
      null == (_otherHandlers$onBlur = otherHandlers.onBlur) || _otherHandlers$onBlur.call(otherHandlers, event);
      event.defaultMuiPrevented || event.defaultPrevented || (dispatch({type:_numberInputAction.NumberInputActionTypes.clamp, event, inputValue:event.currentTarget.value}), setFocused(!1));
    }, createHandleClick = otherHandlers => event => {
      var _otherHandlers$onClic;
      null == (_otherHandlers$onClic = otherHandlers.onClick) || _otherHandlers$onClic.call(otherHandlers, event);
      event.defaultMuiPrevented || event.defaultPrevented || inputRef.current && event.currentTarget === event.target && inputRef.current.focus();
    }, handleStep = direction => event => {
      dispatch({type:{up:_numberInputAction.NumberInputActionTypes.increment, down:_numberInputAction.NumberInputActionTypes.decrement}[direction], event, applyMultiplier:!!event.shiftKey});
    }, createHandleKeyDown = otherHandlers => event => {
      var _otherHandlers$onKeyD;
      null == (_otherHandlers$onKeyD = otherHandlers.onKeyDown) || _otherHandlers$onKeyD.call(otherHandlers, event);
      if (!event.defaultMuiPrevented && !event.defaultPrevented) {
        switch(SUPPORTED_KEYS.includes(event.key) && event.preventDefault(), event.key) {
          case "ArrowUp":
            dispatch({type:_numberInputAction.NumberInputActionTypes.increment, event, applyMultiplier:!!event.shiftKey});
            break;
          case "ArrowDown":
            dispatch({type:_numberInputAction.NumberInputActionTypes.decrement, event, applyMultiplier:!!event.shiftKey});
            break;
          case "PageUp":
            dispatch({type:_numberInputAction.NumberInputActionTypes.increment, event, applyMultiplier:!0});
            break;
          case "PageDown":
            dispatch({type:_numberInputAction.NumberInputActionTypes.decrement, event, applyMultiplier:!0});
            break;
          case "Home":
            dispatch({type:_numberInputAction.NumberInputActionTypes.incrementToMax, event});
            break;
          case "End":
            dispatch({type:_numberInputAction.NumberInputActionTypes.decrementToMin, event});
        }
      }
    }, handleStepperButtonMouseDown = event => {
      event.preventDefault();
      inputRef.current && inputRef.current.focus();
    }, stepperButtonCommonProps = {"aria-controls":inputId, tabIndex:-1}, isIncrementDisabled = disabledProp || ((0,_utils2.isNumber)(value) ? value >= (null != max ? max : Number.MAX_SAFE_INTEGER) : !1), isDecrementDisabled = disabledProp || ((0,_utils2.isNumber)(value) ? value <= (null != min ? min : Number.MIN_SAFE_INTEGER) : !1);
    return {disabled:disabledProp, error:errorProp, focused, formControlContext, getInputProps:(externalProps = {}) => {
      var _ref2, externalEventHandlers = (0,_extends2.default)({}, {onBlur, onFocus, onChange:onInputChange}, (0,_extractEventHandlers.extractEventHandlers)(externalProps, ["onClick"]));
      externalEventHandlers = (0,_extends2.default)({}, externalEventHandlers, {onFocus:createHandleFocus(externalEventHandlers), onChange:createHandleInputChange((0,_extends2.default)({}, externalEventHandlers, {onInputChange:externalEventHandlers.onChange})), onBlur:createHandleBlur(externalEventHandlers), onKeyDown:createHandleKeyDown(externalEventHandlers)});
      const displayValue = null != (_ref2 = focused ? inputValue : value) ? _ref2 : "";
      delete externalProps.onInputChange;
      return (0,_extends2.default)({type:"text", id:inputId, "aria-invalid":errorProp || void 0, defaultValue:void 0, value:displayValue, "aria-valuenow":displayValue, "aria-valuetext":String(displayValue), "aria-valuemin":min, "aria-valuemax":max, autoComplete:"off", autoCorrect:"off", spellCheck:"false", required:requiredProp, readOnly:readOnlyProp, "aria-disabled":disabledProp, disabled:disabledProp}, externalProps, {ref:handleInputRef}, externalEventHandlers);
    }, getIncrementButtonProps:(externalProps = {}) => (0,_extends2.default)({}, externalProps, stepperButtonCommonProps, {disabled:isIncrementDisabled, "aria-disabled":isIncrementDisabled, onMouseDown:handleStepperButtonMouseDown, onClick:handleStep("up")}), getDecrementButtonProps:(externalProps = {}) => (0,_extends2.default)({}, externalProps, stepperButtonCommonProps, {disabled:isDecrementDisabled, "aria-disabled":isDecrementDisabled, onMouseDown:handleStepperButtonMouseDown, onClick:handleStep("down")}), 
    getRootProps:(externalProps = {}) => {
      var propsEventHandlers = (0,_extractEventHandlers.extractEventHandlers)(parameters, ["onBlur", "onInputChange", "onFocus", "onChange"]);
      propsEventHandlers = (0,_extends2.default)({}, propsEventHandlers, (0,_extractEventHandlers.extractEventHandlers)(externalProps));
      return (0,_extends2.default)({}, externalProps, propsEventHandlers, {onClick:createHandleClick(propsEventHandlers)});
    }, required:requiredProp, value, inputValue, isIncrementDisabled, isDecrementDisabled};
  };
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends"));
  global(require("module$node_modules$$mui$utils$node$formatMuiErrorMessage$index"));
  var React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _utils = require("module$node_modules$$mui$utils$node$index"), _extractEventHandlers = require("module$node_modules$$mui$base$node$utils$extractEventHandlers"), _useControllableReducer = require("module$node_modules$$mui$base$node$utils$useControllableReducer"), _FormControl = require("module$node_modules$$mui$base$node$FormControl$index"), _numberInputAction = require("module$node_modules$$mui$base$node$unstable_useNumberInput$numberInputAction_types"), 
  _numberInputReducer = require("module$node_modules$$mui$base$node$unstable_useNumberInput$numberInputReducer"), _utils2 = require("module$node_modules$$mui$base$node$unstable_useNumberInput$utils");
  const SUPPORTED_KEYS = "ArrowUp ArrowDown PageUp PageDown Home End".split(" ");
};

//# sourceMappingURL=module$node_modules$$mui$base$node$unstable_useNumberInput$useNumberInput.js.map
