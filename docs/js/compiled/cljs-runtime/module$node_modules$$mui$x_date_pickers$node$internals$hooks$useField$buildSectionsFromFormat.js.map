{
"version":3,
"file":"module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$buildSectionsFromFormat.js",
"lineCount":103,
"mappings":"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",
"sources":["node_modules/@mui/x-date-pickers/node/internals/hooks/useField/buildSectionsFromFormat.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$buildSectionsFromFormat\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildSectionsFromFormat = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _useField = require(\"./useField.utils\");\nconst expandFormat = ({\n  utils,\n  format\n}) => {\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.');\n    }\n  }\n  return nextFormat;\n};\nconst getEscapedPartsFromFormat = ({\n  utils,\n  expandedFormat\n}) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(undefined, timezone), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nconst createSection = ({\n  utils,\n  timezone,\n  date,\n  shouldRespectLeadingZeros,\n  localeText,\n  localizedDigits,\n  now,\n  token,\n  startSeparator\n}) => {\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n  const sectionConfig = (0, _useField.getDateSectionConfigFromFormatToken)(utils, token);\n  const hasLeadingZerosInFormat = (0, _useField.doesSectionFormatHaveLeadingZeros)(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = date != null && utils.isValid(date);\n  let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n  let maxLength = null;\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);\n      }\n      maxLength = sectionConfig.maxLength;\n      if (isValidDate) {\n        sectionValue = (0, _useField.applyLocalizedDigits)((0, _useField.cleanLeadingZeros)((0, _useField.removeLocalizedDigits)(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n  return (0, _extends2.default)({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\nconst buildSections = params => {\n  const {\n    utils,\n    expandedFormat,\n    escapedParts\n  } = params;\n  const now = utils.date(undefined);\n  const sections = [];\n  let startSeparator = '';\n\n  // This RegExp tests if the beginning of a string corresponds to a supported token\n  const validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n  let i = 0;\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];\n\n    // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection((0, _extends2.default)({}, params, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n      i += firstWordInFormat.length;\n    }\n    // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i];\n\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n      i += 1;\n    }\n  }\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n  return sections;\n};\nconst postProcessSections = ({\n  isRTL,\n  formatDensity,\n  sections\n}) => {\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\nconst buildSectionsFromFormat = params => {\n  let expandedFormat = expandFormat(params);\n  if (params.isRTL && params.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n  const escapedParts = getEscapedPartsFromFormat((0, _extends2.default)({}, params, {\n    expandedFormat\n  }));\n  const sections = buildSections((0, _extends2.default)({}, params, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections((0, _extends2.default)({}, params, {\n    sections\n  }));\n};\nexports.buildSectionsFromFormat = buildSectionsFromFormat;\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","Object","defineProperty","value","buildSectionsFromFormat","_extends2","_useField","expandFormat","utils","format","formatExpansionOverflow","prevFormat","nextFormat","Error","getEscapedPartsFromFormat","expandedFormat","escapedParts","startChar","endChar","escapedCharacters","regExp","RegExp","match","exec","push","start","index","end","lastIndex","getSectionPlaceholder","timezone","localeText","sectionConfig","sectionFormat","type","fieldYearPlaceholder","digitAmount","formatByString","date","undefined","length","fieldMonthPlaceholder","contentType","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","createSection","shouldRespectLeadingZeros","localizedDigits","now","token","startSeparator","getDateSectionConfigFromFormatToken","hasLeadingZerosInFormat","doesSectionFormatHaveLeadingZeros","hasLeadingZerosInInput","isValidDate","isValid","sectionValue","maxLength","applyLocalizedDigits","cleanLeadingZeros","removeLocalizedDigits","default","placeholder","endSeparator","modified","buildSections","params","sections","validTokens","keys","formatTokenMap","sort","a","b","regExpFirstWordInFormat","regExpWordOnlyComposedOfTokens","join","regExpFirstTokenInWord","getEscapedPartOfCurrentChar","i","find","escapeIndex","escapedPartOfCurrentChar","isEscapedChar","firstWordInFormat","slice","test","word","firstWord","char","postProcessSections","isRTL","formatDensity","map","section","cleanSeparator","separator","cleanedSeparator","includes","enableAccessibleFieldDOMStructure","split","reverse"]
}
