shadow$provide.module$node_modules$$mui$base$node$useAutocomplete$useAutocomplete = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function stripDiacritics(string) {
    return "undefined" !== typeof string.normalize ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
  }
  function createFilterOptions(config = {}) {
    const {ignoreAccents = !0, ignoreCase = !0, limit, matchFrom = "any", stringify, trim = !1} = config;
    return (options, {inputValue, getOptionLabel}) => {
      let input = trim ? inputValue.trim() : inputValue;
      ignoreCase && (input = input.toLowerCase());
      ignoreAccents && (input = stripDiacritics(input));
      options = input ? options.filter(option => {
        option = (stringify || getOptionLabel)(option);
        ignoreCase && (option = option.toLowerCase());
        ignoreAccents && (option = stripDiacritics(option));
        return "start" === matchFrom ? 0 === option.indexOf(input) : -1 < option.indexOf(input);
      }) : options;
      return "number" === typeof limit ? options.slice(0, limit) : options;
    };
  }
  function findIndex(array, comp) {
    for (let i = 0; i < array.length; i += 1) {
      if (comp(array[i])) {
        return i;
      }
    }
    return -1;
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.createFilterOptions = createFilterOptions;
  exports.useAutocomplete = function(props) {
    function validOptionIndex(index, direction) {
      if (!listboxRef.current || 0 > index || index >= filteredOptions.length) {
        return -1;
      }
      let nextFocus = index;
      for (;;) {
        const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`), nextFocusDisabled = disabledItemsFocusable ? !1 : !option || option.disabled || "true" === option.getAttribute("aria-disabled");
        if (option && option.hasAttribute("tabindex") && !nextFocusDisabled) {
          return nextFocus;
        }
        nextFocus = "next" === direction ? (nextFocus + 1) % filteredOptions.length : (nextFocus - 1 + filteredOptions.length) % filteredOptions.length;
        if (nextFocus === index) {
          return -1;
        }
      }
    }
    const {unstable_isActiveElementInListbox = defaultIsActiveElementInListbox, unstable_classNamePrefix = "Mui", autoComplete = !1, autoHighlight = !1, autoSelect = !1, blurOnSelect = !1, clearOnBlur = !props.freeSolo, clearOnEscape = !1, componentName = "useAutocomplete", defaultValue = props.multiple ? [] : null, disableClearable = !1, disableCloseOnSelect = !1, disabled:disabledProp, disabledItemsFocusable = !1, disableListWrap = !1, filterOptions = defaultFilterOptions, filterSelectedOptions = 
    !1, freeSolo = !1, getOptionDisabled, getOptionKey, getOptionLabel:getOptionLabelProp = option => {
      var _option$label;
      return null != (_option$label = option.label) ? _option$label : option;
    }, groupBy, handleHomeEndKeys = !props.freeSolo, id:idProp, includeInputInList = !1, inputValue:inputValueProp, isOptionEqualToValue = (option, value) => option === value, multiple = !1, onChange, onClose, onHighlightChange, onInputChange, onOpen, open:openProp, openOnFocus = !1, options, readOnly = !1, selectOnFocus = !props.freeSolo, value:valueProp} = props, id = (0,_utils.unstable_useId)(idProp);
    let getOptionLabel = getOptionLabelProp;
    getOptionLabel = option => {
      const optionLabel = getOptionLabelProp(option);
      return "string" !== typeof optionLabel ? (console.error(`MUI: The \`getOptionLabel\` method of ${componentName} returned ${void 0 === optionLabel ? "undefined" : `${typeof optionLabel} (${optionLabel})`} instead of a string for ${JSON.stringify(option)}.`), String(optionLabel)) : optionLabel;
    };
    const ignoreFocus = React.useRef(!1), firstFocus = React.useRef(!0), inputRef = React.useRef(null), listboxRef = React.useRef(null), [anchorEl, setAnchorEl] = React.useState(null), [focusedTag, setFocusedTag] = React.useState(-1), defaultHighlighted = autoHighlight ? 0 : -1, highlightedIndexRef = React.useRef(defaultHighlighted), [value, setValueState] = (0,_utils.unstable_useControlled)({controlled:valueProp, default:defaultValue, name:componentName}), [inputValue, setInputValueState] = (0,_utils.unstable_useControlled)({controlled:inputValueProp, 
    default:"", name:componentName, state:"inputValue"}), [focused, setFocused] = React.useState(!1), resetInputValue = React.useCallback((event, newValue) => {
      if ((multiple ? value.length < newValue.length : null !== newValue) || clearOnBlur) {
        multiple ? newValue = "" : null == newValue ? newValue = "" : (newValue = getOptionLabel(newValue), newValue = "string" === typeof newValue ? newValue : ""), inputValue !== newValue && (setInputValueState(newValue), onInputChange && onInputChange(event, newValue, "reset"));
      }
    }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]), [open, setOpenState] = (0,_utils.unstable_useControlled)({controlled:openProp, default:!1, name:componentName, state:"open"}), [inputPristine, setInputPristine] = React.useState(!0), inputValueIsSelectedValue = !multiple && null != value && inputValue === getOptionLabel(value), popupOpen = open && !readOnly, filteredOptions = popupOpen ? filterOptions(options.filter(option => filterSelectedOptions && 
    (multiple ? value : [value]).some(value2 => null !== value2 && isOptionEqualToValue(option, value2)) ? !1 : !0), {inputValue:inputValueIsSelectedValue && inputPristine ? "" : inputValue, getOptionLabel}) : [], previousProps = (0,_utils.usePreviousProps)({filteredOptions, value, inputValue});
    React.useEffect(() => {
      const valueChange = value !== previousProps.value;
      focused && !valueChange || freeSolo && !valueChange || resetInputValue(null, value);
    }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
    const listboxAvailable = open && 0 < filteredOptions.length && !readOnly;
    null !== value && !freeSolo && 0 < options.length && (props = (multiple ? value : [value]).filter(value2 => !options.some(option => isOptionEqualToValue(option, value2))), 0 < props.length && console.warn([`MUI: The value provided to ${componentName} is invalid.`, `None of the options match with \`${1 < props.length ? JSON.stringify(props) : JSON.stringify(props[0])}\`.`, "You can use the `isOptionEqualToValue` prop to customize the equality test."].join("\n")));
    const focusTag = (0,_utils.unstable_useEventCallback)(tagToFocus => {
      -1 === tagToFocus ? inputRef.current.focus() : anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    });
    React.useEffect(() => {
      multiple && focusedTag > value.length - 1 && (setFocusedTag(-1), focusTag(-1));
    }, [value, multiple, focusedTag, focusTag]);
    const setHighlightedIndex = (0,_utils.unstable_useEventCallback)(({event, index, reason = "auto"}) => {
      highlightedIndexRef.current = index;
      -1 === index ? inputRef.current.removeAttribute("aria-activedescendant") : inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index}`);
      onHighlightChange && onHighlightChange(event, -1 === index ? null : filteredOptions[index], reason);
      if (listboxRef.current) {
        if (event = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`)) {
          event.classList.remove(`${unstable_classNamePrefix}-focused`), event.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
        }
        event = listboxRef.current;
        "listbox" !== listboxRef.current.getAttribute("role") && (event = listboxRef.current.parentElement.querySelector('[role\x3d"listbox"]'));
        if (event) {
          if (-1 === index) {
            event.scrollTop = 0;
          } else {
            if (index = listboxRef.current.querySelector(`[data-option-index="${index}"]`)) {
              index.classList.add(`${unstable_classNamePrefix}-focused`), "keyboard" === reason && index.classList.add(`${unstable_classNamePrefix}-focusVisible`), event.scrollHeight > event.clientHeight && "mouse" !== reason && "touch" !== reason && (reason = index.offsetTop + index.offsetHeight, reason > event.clientHeight + event.scrollTop ? event.scrollTop = reason - event.clientHeight : index.offsetTop - index.offsetHeight * (groupBy ? 1.3 : 0) < event.scrollTop && (event.scrollTop = index.offsetTop - 
              index.offsetHeight * (groupBy ? 1.3 : 0)));
            }
          }
        }
      }
    }), changeHighlightedIndex = (0,_utils.unstable_useEventCallback)(({event, diff, direction = "next", reason = "auto"}) => {
      popupOpen && (direction = validOptionIndex((() => {
        const maxIndex = filteredOptions.length - 1;
        if ("reset" === diff) {
          return defaultHighlighted;
        }
        if ("start" === diff) {
          return 0;
        }
        if ("end" === diff) {
          return maxIndex;
        }
        const newIndex = highlightedIndexRef.current + diff;
        return 0 > newIndex ? -1 === newIndex && includeInputInList ? -1 : disableListWrap && -1 !== highlightedIndexRef.current || 1 < Math.abs(diff) ? 0 : maxIndex : newIndex > maxIndex ? newIndex === maxIndex + 1 && includeInputInList ? -1 : disableListWrap || 1 < Math.abs(diff) ? maxIndex : 0 : newIndex;
      })(), direction), setHighlightedIndex({index:direction, reason, event}), autoComplete && "reset" !== diff && (-1 === direction ? inputRef.current.value = inputValue : (event = getOptionLabel(filteredOptions[direction]), inputRef.current.value = event, 0 === event.toLowerCase().indexOf(inputValue.toLowerCase()) && 0 < inputValue.length && inputRef.current.setSelectionRange(inputValue.length, event.length))));
    }), getPreviousHighlightedOptionIndex = () => {
      const isSameValue = (value1, value2) => {
        value1 = value1 ? getOptionLabel(value1) : "";
        value2 = value2 ? getOptionLabel(value2) : "";
        return value1 === value2;
      };
      if (-1 !== highlightedIndexRef.current && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i) => getOptionLabel(value[i]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
        const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
        if (previousHighlightedOption) {
          return findIndex(filteredOptions, option => getOptionLabel(option) === getOptionLabel(previousHighlightedOption));
        }
      }
      return -1;
    }, syncHighlightedIndex = React.useCallback(() => {
      if (popupOpen) {
        var previousHighlightedOptionIndex = getPreviousHighlightedOptionIndex();
        if (-1 !== previousHighlightedOptionIndex) {
          highlightedIndexRef.current = previousHighlightedOptionIndex;
        } else {
          var valueItem = multiple ? value[0] : value;
          if (0 === filteredOptions.length || null == valueItem) {
            changeHighlightedIndex({diff:"reset"});
          } else {
            if (listboxRef.current) {
              if (null != valueItem) {
                const currentOption = filteredOptions[highlightedIndexRef.current];
                multiple && currentOption && -1 !== findIndex(value, val => isOptionEqualToValue(currentOption, val)) || (previousHighlightedOptionIndex = findIndex(filteredOptions, optionItem => isOptionEqualToValue(optionItem, valueItem)), -1 === previousHighlightedOptionIndex ? changeHighlightedIndex({diff:"reset"}) : setHighlightedIndex({index:previousHighlightedOptionIndex}));
              } else {
                highlightedIndexRef.current >= filteredOptions.length - 1 ? setHighlightedIndex({index:filteredOptions.length - 1}) : setHighlightedIndex({index:highlightedIndexRef.current});
              }
            }
          }
        }
      }
    }, [filteredOptions.length, multiple ? !1 : value, filterSelectedOptions, changeHighlightedIndex, setHighlightedIndex, popupOpen, inputValue, multiple]), handleListboxRef = (0,_utils.unstable_useEventCallback)(node => {
      (0,_utils.unstable_setRef)(listboxRef, node);
      node && syncHighlightedIndex();
    });
    React.useEffect(() => {
      inputRef.current && "INPUT" === inputRef.current.nodeName || (inputRef.current && "TEXTAREA" === inputRef.current.nodeName ? console.warn([`A textarea element was provided to ${componentName} where input was expected.`, "This is not a supported scenario but it may work under certain conditions.\nA textarea keyboard navigation may conflict with Autocomplete controls (for example enter and arrow keys).\nMake sure to test keyboard navigation and add custom event handlers if necessary."].join("\n")) : 
      console.error([`MUI: Unable to find the input element. It was resolved to ${inputRef.current} while an HTMLInputElement was expected.`, `Instead, ${componentName} expects an input element.`, "", "useAutocomplete" === componentName ? "Make sure you have bound getInputProps correctly and that the normal ref/effect resolutions order is guaranteed." : "Make sure you have customized the input component correctly."].join("\n")));
    }, [componentName]);
    React.useEffect(() => {
      syncHighlightedIndex();
    }, [syncHighlightedIndex]);
    const handleOpen = event => {
      open || (setOpenState(!0), setInputPristine(!0), onOpen && onOpen(event));
    }, handleClose = (event, reason) => {
      open && (setOpenState(!1), onClose && onClose(event, reason));
    }, handleValue = (event, newValue, reason, details) => {
      if (multiple) {
        if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
          return;
        }
      } else if (value === newValue) {
        return;
      }
      onChange && onChange(event, newValue, reason, details);
      setValueState(newValue);
    }, isTouch = React.useRef(!1), selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
      let newValue = option;
      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];
        var matches = newValue.filter(val => isOptionEqualToValue(option, val));
        1 < matches.length && console.error([`MUI: The \`isOptionEqualToValue\` method of ${componentName} does not handle the arguments correctly.`, `The component expects a single value to match a given option but found ${matches.length} matches.`].join("\n"));
        matches = findIndex(newValue, valueItem => isOptionEqualToValue(option, valueItem));
        -1 === matches ? newValue.push(option) : "freeSolo" !== origin && (newValue.splice(matches, 1), reasonProp = "removeOption");
      }
      resetInputValue(event, newValue);
      handleValue(event, newValue, reasonProp, {option});
      disableCloseOnSelect || event && (event.ctrlKey || event.metaKey) || handleClose(event, reasonProp);
      (!0 === blurOnSelect || "touch" === blurOnSelect && isTouch.current || "mouse" === blurOnSelect && !isTouch.current) && inputRef.current.blur();
    }, handleFocusTag = (event, direction) => {
      if (multiple) {
        "" === inputValue && handleClose(event, "toggleInput");
        event = focusedTag;
        -1 === focusedTag ? "" === inputValue && "previous" === direction && (event = value.length - 1) : (event += "next" === direction ? 1 : -1, 0 > event && (event = 0), event === value.length && (event = -1));
        a: {
          if (-1 === event) {
            event = -1;
          } else {
            for (;;) {
              if ("next" === direction && event === value.length || "previous" === direction && -1 === event) {
                event = -1;
                break a;
              }
              const option = anchorEl.querySelector(`[data-tag-index="${event}"]`);
              if (option && option.hasAttribute("tabindex") && !option.disabled && "true" !== option.getAttribute("aria-disabled")) {
                break a;
              } else {
                event += "next" === direction ? 1 : -1;
              }
            }
          }
        }
        setFocusedTag(event);
        focusTag(event);
      }
    }, handleClear = event => {
      ignoreFocus.current = !0;
      setInputValueState("");
      onInputChange && onInputChange(event, "", "clear");
      handleValue(event, multiple ? [] : null, "clear");
    }, handleKeyDown = other => event => {
      if (other.onKeyDown) {
        other.onKeyDown(event);
      }
      if (!event.defaultMuiPrevented && (-1 !== focusedTag && -1 === ["ArrowLeft", "ArrowRight"].indexOf(event.key) && (setFocusedTag(-1), focusTag(-1)), 229 !== event.which)) {
        switch(event.key) {
          case "Home":
            popupOpen && handleHomeEndKeys && (event.preventDefault(), changeHighlightedIndex({diff:"start", direction:"next", reason:"keyboard", event}));
            break;
          case "End":
            popupOpen && handleHomeEndKeys && (event.preventDefault(), changeHighlightedIndex({diff:"end", direction:"previous", reason:"keyboard", event}));
            break;
          case "PageUp":
            event.preventDefault();
            changeHighlightedIndex({diff:-5, direction:"previous", reason:"keyboard", event});
            handleOpen(event);
            break;
          case "PageDown":
            event.preventDefault();
            changeHighlightedIndex({diff:5, direction:"next", reason:"keyboard", event});
            handleOpen(event);
            break;
          case "ArrowDown":
            event.preventDefault();
            changeHighlightedIndex({diff:1, direction:"next", reason:"keyboard", event});
            handleOpen(event);
            break;
          case "ArrowUp":
            event.preventDefault();
            changeHighlightedIndex({diff:-1, direction:"previous", reason:"keyboard", event});
            handleOpen(event);
            break;
          case "ArrowLeft":
            handleFocusTag(event, "previous");
            break;
          case "ArrowRight":
            handleFocusTag(event, "next");
            break;
          case "Enter":
            if (-1 !== highlightedIndexRef.current && popupOpen) {
              var option = filteredOptions[highlightedIndexRef.current], disabled = getOptionDisabled ? getOptionDisabled(option) : !1;
              event.preventDefault();
              disabled || (selectNewValue(event, option, "selectOption"), autoComplete && inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length));
            } else {
              freeSolo && "" !== inputValue && !1 === inputValueIsSelectedValue && (multiple && event.preventDefault(), selectNewValue(event, inputValue, "createOption", "freeSolo"));
            }
            break;
          case "Escape":
            popupOpen ? (event.preventDefault(), event.stopPropagation(), handleClose(event, "escape")) : clearOnEscape && ("" !== inputValue || multiple && 0 < value.length) && (event.preventDefault(), event.stopPropagation(), handleClear(event));
            break;
          case "Backspace":
            multiple && !readOnly && "" === inputValue && 0 < value.length && (option = -1 === focusedTag ? value.length - 1 : focusedTag, disabled = value.slice(), disabled.splice(option, 1), handleValue(event, disabled, "removeOption", {option:value[option]}));
            break;
          case "Delete":
            multiple && !readOnly && "" === inputValue && 0 < value.length && -1 !== focusedTag && (option = value.slice(), option.splice(focusedTag, 1), handleValue(event, option, "removeOption", {option:value[focusedTag]}));
        }
      }
    }, handleFocus = event => {
      setFocused(!0);
      openOnFocus && !ignoreFocus.current && handleOpen(event);
    }, handleBlur = event => {
      unstable_isActiveElementInListbox(listboxRef) ? inputRef.current.focus() : (setFocused(!1), firstFocus.current = !0, ignoreFocus.current = !1, autoSelect && -1 !== highlightedIndexRef.current && popupOpen ? selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur") : autoSelect && freeSolo && "" !== inputValue ? selectNewValue(event, inputValue, "blur", "freeSolo") : clearOnBlur && resetInputValue(event, value), handleClose(event, "blur"));
    }, handleInputChange = event => {
      const newValue = event.target.value;
      inputValue !== newValue && (setInputValueState(newValue), setInputPristine(!1), onInputChange && onInputChange(event, newValue, "input"));
      "" === newValue ? disableClearable || multiple || handleValue(event, null, "clear") : handleOpen(event);
    }, handleOptionMouseMove = event => {
      const index = Number(event.currentTarget.getAttribute("data-option-index"));
      highlightedIndexRef.current !== index && setHighlightedIndex({event, index, reason:"mouse"});
    }, handleOptionTouchStart = event => {
      setHighlightedIndex({event, index:Number(event.currentTarget.getAttribute("data-option-index")), reason:"touch"});
      isTouch.current = !0;
    }, handleOptionClick = event => {
      const index = Number(event.currentTarget.getAttribute("data-option-index"));
      selectNewValue(event, filteredOptions[index], "selectOption");
      isTouch.current = !1;
    }, handleTagDelete = index => event => {
      const newValue = value.slice();
      newValue.splice(index, 1);
      handleValue(event, newValue, "removeOption", {option:value[index]});
    }, handlePopupIndicator = event => {
      open ? handleClose(event, "toggleInput") : handleOpen(event);
    }, handleMouseDown = event => {
      event.currentTarget.contains(event.target) && event.target.getAttribute("id") !== id && event.preventDefault();
    }, handleClick = event => {
      event.currentTarget.contains(event.target) && (inputRef.current.focus(), selectOnFocus && firstFocus.current && 0 === inputRef.current.selectionEnd - inputRef.current.selectionStart && inputRef.current.select(), firstFocus.current = !1);
    }, handleInputMouseDown = event => {
      disabledProp || "" !== inputValue && open || handlePopupIndicator(event);
    };
    props = (props = freeSolo && 0 < inputValue.length) || (multiple ? 0 < value.length : null !== value);
    let groupedOptions = filteredOptions;
    if (groupBy) {
      const indexBy = new Map();
      let warn = !1;
      groupedOptions = filteredOptions.reduce((acc, option, index) => {
        const group = groupBy(option);
        0 < acc.length && acc[acc.length - 1].group === group ? acc[acc.length - 1].options.push(option) : (indexBy.get(group) && !warn && (console.warn(`MUI: The options provided combined with the \`groupBy\` method of ${componentName} returns duplicated headers.`, "You can solve the issue by sorting the options with the output of `groupBy`."), warn = !0), indexBy.set(group, !0), acc.push({key:index, index, group, options:[option]}));
        return acc;
      }, []);
    }
    disabledProp && focused && handleBlur();
    return {getRootProps:(other = {}) => (0,_extends2.default)({"aria-owns":listboxAvailable ? `${id}-listbox` : null}, other, {onKeyDown:handleKeyDown(other), onMouseDown:handleMouseDown, onClick:handleClick}), getInputLabelProps:() => ({id:`${id}-label`, htmlFor:id}), getInputProps:() => ({id, value:inputValue, onBlur:handleBlur, onFocus:handleFocus, onChange:handleInputChange, onMouseDown:handleInputMouseDown, "aria-activedescendant":popupOpen ? "" : null, "aria-autocomplete":autoComplete ? "both" : 
    "list", "aria-controls":listboxAvailable ? `${id}-listbox` : void 0, "aria-expanded":listboxAvailable, autoComplete:"off", ref:inputRef, autoCapitalize:"none", spellCheck:"false", role:"combobox", disabled:disabledProp}), getClearProps:() => ({tabIndex:-1, type:"button", onClick:handleClear}), getPopupIndicatorProps:() => ({tabIndex:-1, type:"button", onClick:handlePopupIndicator}), getTagProps:({index}) => (0,_extends2.default)({key:index, "data-tag-index":index, tabIndex:-1}, !readOnly && {onDelete:handleTagDelete(index)}), 
    getListboxProps:() => ({role:"listbox", id:`${id}-listbox`, "aria-labelledby":`${id}-label`, ref:handleListboxRef, onMouseDown:event => {
      event.preventDefault();
    }}), getOptionProps:({index, option}) => {
      var _getOptionKey;
      const selected = (multiple ? value : [value]).some(value2 => null != value2 && isOptionEqualToValue(option, value2)), disabled = getOptionDisabled ? getOptionDisabled(option) : !1;
      return {key:null != (_getOptionKey = null == getOptionKey ? void 0 : getOptionKey(option)) ? _getOptionKey : getOptionLabel(option), tabIndex:-1, role:"option", id:`${id}-option-${index}`, onMouseMove:handleOptionMouseMove, onClick:handleOptionClick, onTouchStart:handleOptionTouchStart, "data-option-index":index, "aria-disabled":disabled, "aria-selected":selected};
    }, id, inputValue, value, dirty:props, expanded:popupOpen && anchorEl, popupOpen, focused:focused || -1 !== focusedTag, anchorEl, setAnchorEl, focusedTag, groupedOptions};
  };
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _utils = require("module$node_modules$$mui$utils$node$index");
  const defaultFilterOptions = createFilterOptions(), defaultIsActiveElementInListbox = listboxRef => {
    var _listboxRef$current$p;
    return null !== listboxRef.current && (null == (_listboxRef$current$p = listboxRef.current.parentElement) ? void 0 : _listboxRef$current$p.contains(document.activeElement));
  };
};

//# sourceMappingURL=module$node_modules$$mui$base$node$useAutocomplete$useAutocomplete.js.map
