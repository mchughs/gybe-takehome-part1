shadow$provide.module$node_modules$$mui$base$node$useCompound$useCompoundParent = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function sortSubitems(subitems) {
    const subitemsArray = Array.from(subitems.keys()).map(key => {
      const subitem = subitems.get(key);
      return {key, subitem};
    });
    subitemsArray.sort((a, b) => {
      a = a.subitem.ref.current;
      b = b.subitem.ref.current;
      return null === a || null === b || a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;
    });
    return new Map(subitemsArray.map(item => [item.key, item.subitem]));
  }
  "use client";
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.CompoundComponentContext = void 0;
  exports.useCompoundParent = function() {
    const [subitems, setSubitems] = React.useState(new Map()), subitemKeys = React.useRef(new Set()), deregisterItem = React.useCallback(function(id) {
      subitemKeys.current.delete(id);
      setSubitems(previousState => {
        previousState = new Map(previousState);
        previousState.delete(id);
        return previousState;
      });
    }, []), registerItem = React.useCallback(function(id, item) {
      let providedOrGeneratedId;
      providedOrGeneratedId = "function" === typeof id ? id(subitemKeys.current) : id;
      subitemKeys.current.add(providedOrGeneratedId);
      setSubitems(previousState => {
        previousState = new Map(previousState);
        previousState.set(providedOrGeneratedId, item);
        return previousState;
      });
      return {id:providedOrGeneratedId, deregister:() => deregisterItem(providedOrGeneratedId)};
    }, [deregisterItem]), sortedSubitems = React.useMemo(() => sortSubitems(subitems), [subitems]), getItemIndex = React.useCallback(function(id) {
      return Array.from(sortedSubitems.keys()).indexOf(id);
    }, [sortedSubitems]);
    return {contextValue:React.useMemo(() => ({getItemIndex, registerItem, totalSubitemCount:subitems.size}), [getItemIndex, registerItem, subitems.size]), subitems:sortedSubitems};
  };
  var React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index"));
  (exports.CompoundComponentContext = React.createContext(null)).displayName = "CompoundComponentContext";
};

//# sourceMappingURL=module$node_modules$$mui$base$node$useCompound$useCompoundParent.js.map
