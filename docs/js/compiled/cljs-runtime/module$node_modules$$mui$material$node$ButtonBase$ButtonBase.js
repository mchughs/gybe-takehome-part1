shadow$provide.module$node_modules$$mui$material$node$ButtonBase$ButtonBase = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  "use client";
  var _interopRequireDefault = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = exports.ButtonBaseRoot = void 0;
  var _extends2 = _interopRequireDefault(require("module$node_modules$$babel$runtime$helpers$extends")), _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose")), React = _interopRequireWildcard(require("module$node_modules$react$index"));
  global = _interopRequireDefault(require("module$node_modules$prop_types$index"));
  var _clsx = _interopRequireDefault(require("module$node_modules$clsx$dist$clsx"));
  module = _interopRequireDefault(require("module$node_modules$$mui$utils$node$refType$index"));
  var _elementTypeAcceptingRef = _interopRequireDefault(require("module$node_modules$$mui$utils$node$elementTypeAcceptingRef$index")), _composeClasses = _interopRequireDefault(require("module$node_modules$$mui$utils$node$composeClasses$index")), _styled = _interopRequireDefault(require("module$node_modules$$mui$material$node$styles$styled")), _useThemeProps = _interopRequireDefault(require("module$node_modules$$mui$material$node$styles$useThemeProps")), _useForkRef = _interopRequireDefault(require("module$node_modules$$mui$material$node$utils$useForkRef")), 
  _useEventCallback = _interopRequireDefault(require("module$node_modules$$mui$material$node$utils$useEventCallback")), _useIsFocusVisible = _interopRequireDefault(require("module$node_modules$$mui$material$node$utils$useIsFocusVisible")), _TouchRipple = _interopRequireDefault(require("module$node_modules$$mui$material$node$ButtonBase$TouchRipple")), _buttonBaseClasses = _interopRequireWildcard(require("module$node_modules$$mui$material$node$ButtonBase$buttonBaseClasses")), _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  const _excluded = "action centerRipple children className component disabled disableRipple disableTouchRipple focusRipple focusVisibleClassName LinkComponent onBlur onClick onContextMenu onDragLeave onFocus onFocusVisible onKeyDown onKeyUp onMouseDown onMouseLeave onMouseUp onTouchEnd onTouchMove onTouchStart tabIndex TouchRippleProps touchRippleRef type".split(" "), useUtilityClasses = ownerState => {
    const {disabled, focusVisible, focusVisibleClassName, classes} = ownerState;
    ownerState = (0,_composeClasses.default)({root:["root", disabled && "disabled", focusVisible && "focusVisible"]}, _buttonBaseClasses.getButtonBaseUtilityClass, classes);
    focusVisible && focusVisibleClassName && (ownerState.root += ` ${focusVisibleClassName}`);
    return ownerState;
  }, ButtonBaseRoot = exports.ButtonBaseRoot = (0,_styled.default)("button", {name:"MuiButtonBase", slot:"Root", overridesResolver:(props, styles) => styles.root})({display:"inline-flex", alignItems:"center", justifyContent:"center", position:"relative", boxSizing:"border-box", WebkitTapHighlightColor:"transparent", backgroundColor:"transparent", outline:0, border:0, margin:0, borderRadius:0, padding:0, cursor:"pointer", userSelect:"none", verticalAlign:"middle", MozAppearance:"none", WebkitAppearance:"none", 
  textDecoration:"none", color:"inherit", "\x26::-moz-focus-inner":{borderStyle:"none"}, [`&.${_buttonBaseClasses.default.disabled}`]:{pointerEvents:"none", cursor:"default"}, "@media print":{colorAdjust:"exact"}});
  require = React.forwardRef(function(inProps, ref) {
    function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
      return (0,_useEventCallback.default)(event => {
        eventCallback && eventCallback(event);
        if (!skipRippleAction && rippleRef.current) {
          rippleRef.current[rippleAction](event);
        }
        return !0;
      });
    }
    var props = (0,_useThemeProps.default)({props:inProps, name:"MuiButtonBase"});
    const {action, centerRipple = !1, children, className, component = "button", disabled = !1, disableRipple = !1, disableTouchRipple = !1, focusRipple = !1, LinkComponent = "a", onBlur, onClick, onContextMenu, onDragLeave, onFocus, onFocusVisible, onKeyDown, onKeyUp, onMouseDown, onMouseLeave, onMouseUp, onTouchEnd, onTouchMove, onTouchStart, tabIndex = 0, TouchRippleProps, touchRippleRef, type} = props;
    inProps = (0,_objectWithoutPropertiesLoose2.default)(props, _excluded);
    const buttonRef = React.useRef(null), rippleRef = React.useRef(null), handleRippleRef = (0,_useForkRef.default)(rippleRef, touchRippleRef), {isFocusVisibleRef, onFocus:handleFocusVisible, onBlur:handleBlurVisible, ref:focusVisibleRef} = (0,_useIsFocusVisible.default)(), [focusVisible, setFocusVisible] = React.useState(!1);
    disabled && focusVisible && setFocusVisible(!1);
    React.useImperativeHandle(action, () => ({focusVisible:() => {
      setFocusVisible(!0);
      buttonRef.current.focus();
    }}), []);
    const [mountedState, setMountedState] = React.useState(!1);
    React.useEffect(() => {
      setMountedState(!0);
    }, []);
    const enableTouchRipple = mountedState && !disableRipple && !disabled;
    React.useEffect(() => {
      focusVisible && focusRipple && !disableRipple && mountedState && rippleRef.current.pulsate();
    }, [disableRipple, focusRipple, focusVisible, mountedState]);
    const handleMouseDown = useRippleHandler("start", onMouseDown), handleContextMenu = useRippleHandler("stop", onContextMenu), handleDragLeave = useRippleHandler("stop", onDragLeave), handleMouseUp = useRippleHandler("stop", onMouseUp), handleMouseLeave = useRippleHandler("stop", event => {
      focusVisible && event.preventDefault();
      onMouseLeave && onMouseLeave(event);
    }), handleTouchStart = useRippleHandler("start", onTouchStart), handleTouchEnd = useRippleHandler("stop", onTouchEnd), handleTouchMove = useRippleHandler("stop", onTouchMove), handleBlur = useRippleHandler("stop", event => {
      handleBlurVisible(event);
      !1 === isFocusVisibleRef.current && setFocusVisible(!1);
      onBlur && onBlur(event);
    }, !1), handleFocus = (0,_useEventCallback.default)(event => {
      buttonRef.current || (buttonRef.current = event.currentTarget);
      handleFocusVisible(event);
      !0 === isFocusVisibleRef.current && (setFocusVisible(!0), onFocusVisible && onFocusVisible(event));
      onFocus && onFocus(event);
    }), isNonNativeButton = () => {
      const button = buttonRef.current;
      return component && "button" !== component && !("A" === button.tagName && button.href);
    }, keydownRef = React.useRef(!1), handleKeyDown = (0,_useEventCallback.default)(event => {
      focusRipple && !keydownRef.current && focusVisible && rippleRef.current && " " === event.key && (keydownRef.current = !0, rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      }));
      event.target === event.currentTarget && isNonNativeButton() && " " === event.key && event.preventDefault();
      onKeyDown && onKeyDown(event);
      event.target === event.currentTarget && isNonNativeButton() && "Enter" === event.key && !disabled && (event.preventDefault(), onClick && onClick(event));
    }), handleKeyUp = (0,_useEventCallback.default)(event => {
      focusRipple && " " === event.key && rippleRef.current && focusVisible && !event.defaultPrevented && (keydownRef.current = !1, rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      }));
      onKeyUp && onKeyUp(event);
      onClick && event.target === event.currentTarget && isNonNativeButton() && " " === event.key && !event.defaultPrevented && onClick(event);
    });
    let ComponentProp = component;
    "button" === ComponentProp && (inProps.href || inProps.to) && (ComponentProp = LinkComponent);
    const buttonProps = {};
    "button" === ComponentProp ? (buttonProps.type = void 0 === type ? "button" : type, buttonProps.disabled = disabled) : (inProps.href || inProps.to || (buttonProps.role = "button"), disabled && (buttonProps["aria-disabled"] = disabled));
    ref = (0,_useForkRef.default)(ref, focusVisibleRef, buttonRef);
    React.useEffect(() => {
      enableTouchRipple && !rippleRef.current && console.error("MUI: The `component` prop provided to ButtonBase is invalid.\nPlease make sure the children prop is rendered in this custom component.");
    }, [enableTouchRipple]);
    props = (0,_extends2.default)({}, props, {centerRipple, component, disabled, disableRipple, disableTouchRipple, focusRipple, tabIndex, focusVisible});
    const classes = useUtilityClasses(props);
    return (0,_jsxRuntime.jsxs)(ButtonBaseRoot, (0,_extends2.default)({as:ComponentProp, className:(0,_clsx.default)(classes.root, className), ownerState:props, onBlur:handleBlur, onClick, onContextMenu:handleContextMenu, onFocus:handleFocus, onKeyDown:handleKeyDown, onKeyUp:handleKeyUp, onMouseDown:handleMouseDown, onMouseLeave:handleMouseLeave, onMouseUp:handleMouseUp, onDragLeave:handleDragLeave, onTouchEnd:handleTouchEnd, onTouchMove:handleTouchMove, onTouchStart:handleTouchStart, ref, tabIndex:disabled ? 
    -1 : tabIndex, type}, buttonProps, inProps, {children:[children, enableTouchRipple ? (0,_jsxRuntime.jsx)(_TouchRipple.default, (0,_extends2.default)({ref:handleRippleRef, center:centerRipple}, TouchRippleProps)) : null]}));
  });
  require.propTypes = {action:module.default, centerRipple:global.default.bool, children:global.default.node, classes:global.default.object, className:global.default.string, component:_elementTypeAcceptingRef.default, disabled:global.default.bool, disableRipple:global.default.bool, disableTouchRipple:global.default.bool, focusRipple:global.default.bool, focusVisibleClassName:global.default.string, href:global.default.any, LinkComponent:global.default.elementType, onBlur:global.default.func, onClick:global.default.func, 
  onContextMenu:global.default.func, onDragLeave:global.default.func, onFocus:global.default.func, onFocusVisible:global.default.func, onKeyDown:global.default.func, onKeyUp:global.default.func, onMouseDown:global.default.func, onMouseLeave:global.default.func, onMouseUp:global.default.func, onTouchEnd:global.default.func, onTouchMove:global.default.func, onTouchStart:global.default.func, sx:global.default.oneOfType([global.default.arrayOf(global.default.oneOfType([global.default.func, global.default.object, 
  global.default.bool])), global.default.func, global.default.object]), tabIndex:global.default.number, TouchRippleProps:global.default.object, touchRippleRef:global.default.oneOfType([global.default.func, global.default.shape({current:global.default.shape({pulsate:global.default.func.isRequired, start:global.default.func.isRequired, stop:global.default.func.isRequired})})]), type:global.default.oneOfType([global.default.oneOf(["button", "reset", "submit"]), global.default.string])};
  exports.default = require;
};

//# sourceMappingURL=module$node_modules$$mui$material$node$ButtonBase$ButtonBase.js.map
