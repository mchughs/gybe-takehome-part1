shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$utils$getDefaultReferenceDate = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getSectionTypeGranularity = exports.getDefaultReferenceDate = exports.SECTION_TYPE_GRANULARITY = void 0;
  var _timeUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$time_utils"), _dateUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$date_utils");
  const SECTION_TYPE_GRANULARITY = exports.SECTION_TYPE_GRANULARITY = {year:1, month:2, day:3, hours:4, minutes:5, seconds:6, milliseconds:7};
  exports.getSectionTypeGranularity = sections => Math.max(...sections.map(section => SECTION_TYPE_GRANULARITY[section.type] ?? 1));
  const roundDate = (utils, granularity, date) => {
    if (granularity === SECTION_TYPE_GRANULARITY.year) {
      return utils.startOfYear(date);
    }
    if (granularity === SECTION_TYPE_GRANULARITY.month) {
      return utils.startOfMonth(date);
    }
    if (granularity === SECTION_TYPE_GRANULARITY.day) {
      return utils.startOfDay(date);
    }
    granularity < SECTION_TYPE_GRANULARITY.minutes && (date = utils.setMinutes(date, 0));
    granularity < SECTION_TYPE_GRANULARITY.seconds && (date = utils.setSeconds(date, 0));
    granularity < SECTION_TYPE_GRANULARITY.milliseconds && (date = utils.setMilliseconds(date, 0));
    return date;
  };
  exports.getDefaultReferenceDate = ({props, utils, granularity, timezone, getTodayDate:inGetTodayDate}) => {
    timezone = inGetTodayDate ? inGetTodayDate() : roundDate(utils, granularity, (0,_dateUtils.getTodayDate)(utils, timezone));
    null != props.minDate && utils.isAfterDay(props.minDate, timezone) && (timezone = roundDate(utils, granularity, props.minDate));
    null != props.maxDate && utils.isBeforeDay(props.maxDate, timezone) && (timezone = roundDate(utils, granularity, props.maxDate));
    inGetTodayDate = (0,_timeUtils.createIsAfterIgnoreDatePart)(props.disableIgnoringDatePartForTimeValidation ?? !1, utils);
    null != props.minTime && inGetTodayDate(props.minTime, timezone) && (timezone = roundDate(utils, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : (0,_dateUtils.mergeDateAndTime)(utils, timezone, props.minTime)));
    null != props.maxTime && inGetTodayDate(timezone, props.maxTime) && (timezone = roundDate(utils, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : (0,_dateUtils.mergeDateAndTime)(utils, timezone, props.maxTime)));
    return timezone;
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$utils$getDefaultReferenceDate.js.map
