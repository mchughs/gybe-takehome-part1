shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldState = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.useFieldState = void 0;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _useControlled = global(require("module$node_modules$$mui$utils$node$useControlled$index")), _styles = require("module$node_modules$$mui$material$node$styles$index"), _useUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useUtils"), _useField = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils"), _buildSectionsFromFormat = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$buildSectionsFromFormat"), 
  _useValueWithTimezone = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useValueWithTimezone"), _getDefaultReferenceDate = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$getDefaultReferenceDate");
  exports.useFieldState = params => {
    const utils = (0,_useUtils.useUtils)(), localeText = (0,_useUtils.useLocaleText)(), adapter = (0,_useUtils.useLocalizationContext)(), isRTL = "rtl" === (0,_styles.useTheme)().direction, {valueManager, fieldValueManager, valueType, validator, internalProps, internalProps:{value:valueProp, defaultValue, referenceDate:referenceDateProp, onChange, format, formatDensity = "dense", selectedSections:selectedSectionsProp, onSelectedSectionsChange, shouldRespectLeadingZeros = !1, timezone:timezoneProp, 
    enableAccessibleFieldDOMStructure = !1}} = params, {timezone, value:valueFromTheOutside, handleValueChange} = (0,_useValueWithTimezone.useValueWithTimezone)({timezone:timezoneProp, value:valueProp, defaultValue, onChange, valueManager}), localizedDigits = React.useMemo(() => (0,_useField.getLocalizedDigits)(utils), [utils]);
    params = React.useMemo(() => (0,_useField.getSectionsBoundaries)(utils, localizedDigits, timezone), [utils, localizedDigits, timezone]);
    const getSectionsFromValue = React.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils, value, fallbackSections, date => (0,_buildSectionsFromFormat.buildSectionsFromFormat)({utils, timezone, localeText, localizedDigits, format, date, formatDensity, shouldRespectLeadingZeros, enableAccessibleFieldDOMStructure, isRTL})), [fieldValueManager, format, localeText, localizedDigits, isRTL, shouldRespectLeadingZeros, utils, formatDensity, timezone, enableAccessibleFieldDOMStructure]), 
    [state, setState] = React.useState(() => {
      var sections = getSectionsFromValue(valueFromTheOutside);
      (0,_useField.validateSections)(sections, valueType);
      const stateWithoutReferenceDate = {sections, value:valueFromTheOutside, referenceValue:valueManager.emptyValue, tempValueStrAndroid:null};
      sections = (0,_getDefaultReferenceDate.getSectionTypeGranularity)(sections);
      sections = valueManager.getInitialReferenceValue({referenceDate:referenceDateProp, value:valueFromTheOutside, utils, props:internalProps, granularity:sections, timezone});
      return (0,_extends2.default)({}, stateWithoutReferenceDate, {referenceValue:sections});
    }), [selectedSections, innerSetSelectedSections] = (0,_useControlled.default)({controlled:selectedSectionsProp, default:null, name:"useField", state:"selectedSections"}), setSelectedSections = newSelectedSections => {
      innerSetSelectedSections(newSelectedSections);
      onSelectedSectionsChange?.(newSelectedSections);
    }, parsedSelectedSections = React.useMemo(() => (0,_useField.parseSelectedSections)(selectedSections, state.sections), [selectedSections, state.sections]), activeSectionIndex = "all" === parsedSelectedSections ? 0 : parsedSelectedSections, publishValue = ({value, referenceValue, sections}) => {
      setState(prevState => (0,_extends2.default)({}, prevState, {sections, value, referenceValue, tempValueStrAndroid:null}));
      if (!valueManager.areValuesEqual(utils, state.value, value)) {
        var context = {validationError:validator({adapter, value, props:(0,_extends2.default)({}, internalProps, {value, timezone})})};
        handleValueChange(value, context);
      }
    }, setSectionValue = (sectionIndex, newSectionValue) => {
      const newSections = [...state.sections];
      newSections[sectionIndex] = (0,_extends2.default)({}, newSections[sectionIndex], {value:newSectionValue, modified:!0});
      return newSections;
    };
    React.useEffect(() => {
      const sections = getSectionsFromValue(state.value);
      (0,_useField.validateSections)(sections, valueType);
      setState(prevState => (0,_extends2.default)({}, prevState, {sections}));
    }, [format, utils.locale, isRTL]);
    React.useEffect(() => {
      (valueManager.areValuesEqual(utils, state.value, valueFromTheOutside) ? valueManager.getTimezone(utils, state.value) !== valueManager.getTimezone(utils, valueFromTheOutside) : 1) && setState(prevState => (0,_extends2.default)({}, prevState, {value:valueFromTheOutside, referenceValue:fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, prevState.referenceValue), sections:getSectionsFromValue(valueFromTheOutside)}));
    }, [valueFromTheOutside]);
    return {state, activeSectionIndex, parsedSelectedSections, setSelectedSections, clearValue:() => {
      publishValue({value:valueManager.emptyValue, referenceValue:state.referenceValue, sections:getSectionsFromValue(valueManager.emptyValue)});
    }, clearActiveSection:() => {
      if (null != activeSectionIndex) {
        var activeSection = state.sections[activeSectionIndex], activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection), hasNoOtherNonEmptySections = activeDateManager.getSections(state.sections).filter(section => "" !== section.value).length === ("" === activeSection.value ? 0 : 1);
        activeSection = setSectionValue(activeSectionIndex, "");
        hasNoOtherNonEmptySections = hasNoOtherNonEmptySections ? null : utils.getInvalidDate();
        activeDateManager = activeDateManager.getNewValuesFromNewActiveDate(hasNoOtherNonEmptySections);
        publishValue((0,_extends2.default)({}, activeDateManager, {sections:activeSection}));
      }
    }, updateSectionValue:({activeSection, newSectionValue, shouldGoToNextSection}) => {
      shouldGoToNextSection && activeSectionIndex < state.sections.length - 1 && setSelectedSections(activeSectionIndex + 1);
      activeSection = fieldValueManager.getActiveDateManager(utils, state, activeSection);
      const newSections = setSectionValue(activeSectionIndex, newSectionValue);
      newSectionValue = activeSection.getSections(newSections);
      shouldGoToNextSection = (0,_useField.getDateFromDateSections)(utils, newSectionValue, localizedDigits);
      let values;
      null != shouldGoToNextSection && utils.isValid(shouldGoToNextSection) ? (newSectionValue = (0,_useField.mergeDateIntoReferenceDate)(utils, timezone, shouldGoToNextSection, newSectionValue, activeSection.referenceDate, !0), values = activeSection.getNewValuesFromNewActiveDate(newSectionValue), activeSection = !0) : (values = activeSection.getNewValuesFromNewActiveDate(shouldGoToNextSection), activeSection = (null != shouldGoToNextSection && !utils.isValid(shouldGoToNextSection)) !== (null != 
      activeSection.date && !utils.isValid(activeSection.date)));
      return activeSection ? publishValue((0,_extends2.default)({}, values, {sections:newSections})) : setState(prevState => (0,_extends2.default)({}, prevState, values, {sections:newSections, tempValueStrAndroid:null}));
    }, updateValueFromValueStr:valueStr => {
      valueStr = fieldValueManager.parseValueStr(valueStr, state.referenceValue, (dateStr, referenceDate) => {
        dateStr = utils.parse(dateStr, format);
        if (null == dateStr || !utils.isValid(dateStr)) {
          return null;
        }
        const sections = (0,_buildSectionsFromFormat.buildSectionsFromFormat)({utils, timezone, localeText, localizedDigits, format, date:dateStr, formatDensity, shouldRespectLeadingZeros, enableAccessibleFieldDOMStructure, isRTL});
        return (0,_useField.mergeDateIntoReferenceDate)(utils, timezone, dateStr, sections, referenceDate, !1);
      });
      const newReferenceValue = fieldValueManager.updateReferenceValue(utils, valueStr, state.referenceValue);
      publishValue({value:valueStr, referenceValue:newReferenceValue, sections:getSectionsFromValue(valueStr, state.sections)});
    }, setTempAndroidValueStr:tempValueStrAndroid => setState(prev => (0,_extends2.default)({}, prev, {tempValueStrAndroid})), getSectionsFromValue, sectionsValueBoundaries:params, localizedDigits, timezone};
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldState.js.map
