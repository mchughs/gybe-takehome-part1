shadow$provide.module$node_modules$$mui$base$node$useSelect$useSelect = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function defaultFormValueProvider(selectedOption) {
    return Array.isArray(selectedOption) ? 0 === selectedOption.length ? "" : JSON.stringify(selectedOption.map(o => o.value)) : null == (null == selectedOption ? void 0 : selectedOption.value) ? "" : "string" === typeof selectedOption.value || "number" === typeof selectedOption.value ? selectedOption.value : JSON.stringify(selectedOption.value);
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.useSelect = function(props) {
    const {areOptionsEqual, buttonRef:buttonRefProp, defaultOpen = !1, defaultValue:defaultValueProp, disabled = !1, listboxId:listboxIdProp, listboxRef:listboxRefProp, multiple = !1, name, required, onChange, onHighlightChange, onOpenChange, open:openProp, options:optionsParam, getOptionAsString = _defaultOptionStringifier.defaultOptionStringifier, getSerializedValue = defaultFormValueProvider, value:valueProp, componentName = "useSelect"} = props, buttonRef = React.useRef(null);
    var handleButtonRef = (0,_utils.unstable_useForkRef)(buttonRefProp, buttonRef);
    const listboxRef = React.useRef(null), listboxId = (0,_utils.unstable_useId)(listboxIdProp);
    let defaultValue;
    void 0 === valueProp && void 0 === defaultValueProp ? defaultValue = [] : void 0 !== defaultValueProp && (defaultValue = multiple ? defaultValueProp : null == defaultValueProp ? [] : [defaultValueProp]);
    const value = React.useMemo(() => {
      if (void 0 !== valueProp) {
        return multiple ? valueProp : null == valueProp ? [] : [valueProp];
      }
    }, [valueProp, multiple]), {subitems, contextValue:compoundComponentContextValue} = (0,_useCompound.useCompoundParent)(), options = React.useMemo(() => null != optionsParam ? new Map(optionsParam.map((option, index) => [option.value, {value:option.value, label:option.label, disabled:option.disabled, ref:React.createRef(), id:`${listboxId}_${index}`}])) : subitems, [optionsParam, subitems, listboxId]);
    var handleListboxRef = (0,_utils.unstable_useForkRef)(listboxRefProp, listboxRef);
    const {getRootProps:getButtonRootProps, active:buttonActive, focusVisible:buttonFocusVisible, rootRef:mergedButtonRef} = (0,_useButton.useButton)({disabled, rootRef:handleButtonRef}), optionValues = React.useMemo(() => Array.from(options.keys()), [options]), getOptionByValue = React.useCallback(valueToGet => {
      if (void 0 !== areOptionsEqual) {
        const similarValue = optionValues.find(optionValue => areOptionsEqual(optionValue, valueToGet));
        return options.get(similarValue);
      }
      return options.get(valueToGet);
    }, [options, areOptionsEqual, optionValues]);
    handleButtonRef = React.useCallback(valueToCheck => {
      var _option$disabled;
      valueToCheck = getOptionByValue(valueToCheck);
      return null != (_option$disabled = null == valueToCheck ? void 0 : valueToCheck.disabled) ? _option$disabled : !1;
    }, [getOptionByValue]);
    const stringifyOption = React.useCallback(valueToCheck => (valueToCheck = getOptionByValue(valueToCheck)) ? getOptionAsString(valueToCheck) : "", [getOptionByValue, getOptionAsString]), controlledState = React.useMemo(() => ({selectedValues:value, open:openProp}), [value, openProp]), getItemId = React.useCallback(itemValue => {
      var _options$get;
      return null == (_options$get = options.get(itemValue)) ? void 0 : _options$get.id;
    }, [options]), handleSelectionChange = React.useCallback((event, newValues) => {
      if (multiple) {
        null == onChange || onChange(event, newValues);
      } else {
        var _newValues$;
        null == onChange || onChange(event, null != (_newValues$ = newValues[0]) ? _newValues$ : null);
      }
    }, [multiple, onChange]), handleHighlightChange = React.useCallback((event, newValue) => {
      null == onHighlightChange || onHighlightChange(event, null != newValue ? newValue : null);
    }, [onHighlightChange]), handleStateChange = React.useCallback((event, field, fieldValue) => {
      if ("open" === field && (null == onOpenChange || onOpenChange(fieldValue), !1 === fieldValue && "blur" !== (null == event ? void 0 : event.type))) {
        var _buttonRef$current;
        null == (_buttonRef$current = buttonRef.current) || _buttonRef$current.focus();
      }
    }, [onOpenChange]), getItemDomElement = React.useCallback(itemId => {
      var _subitems$get$ref$cur, _subitems$get;
      return null == itemId ? null : null != (_subitems$get$ref$cur = null == (_subitems$get = subitems.get(itemId)) ? void 0 : _subitems$get.ref.current) ? _subitems$get$ref$cur : null;
    }, [subitems]);
    handleListboxRef = {getInitialState:() => {
      var _defaultValue;
      return {highlightedValue:null, selectedValues:null != (_defaultValue = defaultValue) ? _defaultValue : [], open:defaultOpen};
    }, getItemId, controlledProps:controlledState, focusManagement:"DOM", getItemDomElement, itemComparer:areOptionsEqual, isItemDisabled:handleButtonRef, rootRef:handleListboxRef, onChange:handleSelectionChange, onHighlightChange:handleHighlightChange, onStateChange:handleStateChange, reducerActionContext:React.useMemo(() => ({multiple}), [multiple]), items:optionValues, getItemAsString:stringifyOption, selectionMode:multiple ? "multiple" : "single", stateReducer:_selectReducer.selectReducer, componentName};
    const {dispatch, getRootProps:getListboxRootProps, contextValue:listContextValue, state:{open, highlightedValue:highlightedOption, selectedValues:selectedOptions}, rootRef:mergedListRootRef} = (0,_useList.useList)(handleListboxRef), isInitiallyOpen = React.useRef(open);
    (0,_utils.unstable_useEnhancedEffect)(() => {
      if (open && null !== highlightedOption) {
        var _getOptionByValue, optionRef = null == (_getOptionByValue = getOptionByValue(highlightedOption)) ? void 0 : _getOptionByValue.ref;
        listboxRef.current && null != optionRef && optionRef.current && (isInitiallyOpen.current || optionRef.current.focus({preventScroll:!0}), _getOptionByValue = listboxRef.current.getBoundingClientRect(), optionRef = optionRef.current.getBoundingClientRect(), optionRef.top < _getOptionByValue.top ? listboxRef.current.scrollTop -= _getOptionByValue.top - optionRef.top : optionRef.bottom > _getOptionByValue.bottom && (listboxRef.current.scrollTop += optionRef.bottom - _getOptionByValue.bottom));
      }
    }, [open, highlightedOption, getOptionByValue]);
    const getOptionMetadata = React.useCallback(optionValue => getOptionByValue(optionValue), [getOptionByValue]), createHandleButtonClick = externalEventHandlers => event => {
      var _externalEventHandler;
      null == externalEventHandlers || null == (_externalEventHandler = externalEventHandlers.onClick) || _externalEventHandler.call(externalEventHandlers, event);
      event.defaultMuiPrevented || dispatch({type:_useSelect.SelectActionTypes.buttonClick, event});
    }, createHandleButtonKeyDown = otherHandlers => event => {
      var _otherHandlers$onKeyD;
      null == (_otherHandlers$onKeyD = otherHandlers.onKeyDown) || _otherHandlers$onKeyD.call(otherHandlers, event);
      event.defaultMuiPrevented || "ArrowDown" !== event.key && "ArrowUp" !== event.key || (event.preventDefault(), dispatch({type:_useList.ListActionTypes.keyDown, key:event.key, event}));
    }, getButtonOwnRootProps = (otherHandlers = {}) => ({onClick:createHandleButtonClick(otherHandlers), onKeyDown:createHandleButtonKeyDown(otherHandlers)}), getSelectTriggerProps = (otherHandlers = {}) => (0,_extends2.default)({}, otherHandlers, getButtonOwnRootProps(otherHandlers), {role:"combobox", "aria-expanded":open, "aria-controls":listboxId}), createListboxHandleBlur = otherHandlers => event => {
      var _otherHandlers$onBlur, _listboxRef$current;
      null == (_otherHandlers$onBlur = otherHandlers.onBlur) || _otherHandlers$onBlur.call(otherHandlers, event);
      !event.defaultMuiPrevented && (null != (_listboxRef$current = listboxRef.current) && _listboxRef$current.contains(event.relatedTarget) || event.relatedTarget === buttonRef.current) && (event.defaultMuiPrevented = !0);
    }, getOwnListboxHandlers = (otherHandlers = {}) => ({onBlur:createListboxHandleBlur(otherHandlers)});
    React.useDebugValue({selectedOptions, highlightedOption, open});
    handleListboxRef = React.useMemo(() => (0,_extends2.default)({}, listContextValue, compoundComponentContextValue), [listContextValue, compoundComponentContextValue]);
    props = props.multiple ? selectedOptions : 0 < selectedOptions.length ? selectedOptions[0] : null;
    let selectedOptionsMetadata;
    if (multiple) {
      selectedOptionsMetadata = props.map(v => getOptionMetadata(v)).filter(o => void 0 !== o);
    } else {
      var _getOptionMetadata;
      selectedOptionsMetadata = null != (_getOptionMetadata = getOptionMetadata(props)) ? _getOptionMetadata : null;
    }
    const createHandleHiddenInputChange = externalEventHandlers => event => {
      var _externalEventHandler2;
      null == externalEventHandlers || null == (_externalEventHandler2 = externalEventHandlers.onChange) || _externalEventHandler2.call(externalEventHandlers, event);
      event.defaultMuiPrevented || (_externalEventHandler2 = options.get(event.target.value), "" === event.target.value ? dispatch({type:_useList.ListActionTypes.clearSelection}) : void 0 !== _externalEventHandler2 && dispatch({type:_useSelect.SelectActionTypes.browserAutoFill, item:_externalEventHandler2.value, event}));
    };
    return {buttonActive, buttonFocusVisible, buttonRef:mergedButtonRef, contextValue:handleListboxRef, disabled, dispatch, getButtonProps:(externalProps = {}) => {
      const externalEventHandlers = (0,_extractEventHandlers.extractEventHandlers)(externalProps), combinedProps = (0,_combineHooksSlotProps.combineHooksSlotProps)(getSelectTriggerProps, getButtonRootProps);
      return (0,_extends2.default)({}, externalProps, combinedProps(externalEventHandlers));
    }, getHiddenInputProps:(externalProps = {}) => {
      const externalEventHandlers = (0,_extractEventHandlers.extractEventHandlers)(externalProps);
      return (0,_extends2.default)({name, tabIndex:-1, "aria-hidden":!0, required:required ? !0 : void 0, value:getSerializedValue(selectedOptionsMetadata), style:_utils.visuallyHidden}, externalProps, {onChange:createHandleHiddenInputChange(externalEventHandlers)});
    }, getListboxProps:(externalProps = {}) => {
      const externalEventHandlers = (0,_extractEventHandlers.extractEventHandlers)(externalProps), getCombinedRootProps = (0,_combineHooksSlotProps.combineHooksSlotProps)(getOwnListboxHandlers, getListboxRootProps);
      return (0,_extends2.default)({id:listboxId, role:"listbox", "aria-multiselectable":multiple ? "true" : void 0}, externalProps, getCombinedRootProps(externalEventHandlers));
    }, getOptionMetadata, listboxRef:mergedListRootRef, open, options:optionValues, value:props, highlightedOption};
  };
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _utils = require("module$node_modules$$mui$utils$node$index"), _useButton = require("module$node_modules$$mui$base$node$useButton$index"), _useSelect = require("module$node_modules$$mui$base$node$useSelect$useSelect_types"), _useList = require("module$node_modules$$mui$base$node$useList$index"), _defaultOptionStringifier = require("module$node_modules$$mui$base$node$useSelect$defaultOptionStringifier"), _useCompound = require("module$node_modules$$mui$base$node$useCompound$index"), 
  _extractEventHandlers = require("module$node_modules$$mui$base$node$utils$extractEventHandlers"), _selectReducer = require("module$node_modules$$mui$base$node$useSelect$selectReducer"), _combineHooksSlotProps = require("module$node_modules$$mui$base$node$utils$combineHooksSlotProps");
};

//# sourceMappingURL=module$node_modules$$mui$base$node$useSelect$useSelect.js.map
