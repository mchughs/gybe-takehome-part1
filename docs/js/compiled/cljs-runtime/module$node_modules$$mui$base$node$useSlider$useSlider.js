shadow$provide.module$node_modules$$mui$base$node$useSlider$useSlider = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function asc(a, b) {
    return a - b;
  }
  function findClosest(values, currentValue) {
    var _values$reduce;
    ({index:values} = null != (_values$reduce = values.reduce((acc, value, index) => {
      value = Math.abs(currentValue - value);
      return null === acc || value < acc.distance || value === acc.distance ? {distance:value, index} : acc;
    }, null)) ? _values$reduce : {});
    return values;
  }
  function trackFinger(event, touchId) {
    if (void 0 !== touchId.current && event.changedTouches) {
      for (let i = 0; i < event.changedTouches.length; i += 1) {
        const touch = event.changedTouches[i];
        if (touch.identifier === touchId.current) {
          return {x:touch.clientX, y:touch.clientY};
        }
      }
      return !1;
    }
    return {x:event.clientX, y:event.clientY};
  }
  function valueToPercent(value, min, max) {
    return 100 * (value - min) / (max - min);
  }
  function setValueIndex({values, newValue, index}) {
    values = values.slice();
    values[index] = newValue;
    return values.sort(asc);
  }
  function focusThumb({sliderRef, activeIndex, setActive}) {
    var _sliderRef$current, _doc$activeElement;
    const doc = (0,_utils.unstable_ownerDocument)(sliderRef.current);
    if (null == (_sliderRef$current = sliderRef.current) || !_sliderRef$current.contains(doc.activeElement) || Number(null == doc || null == (_doc$activeElement = doc.activeElement) ? void 0 : _doc$activeElement.getAttribute("data-index")) !== activeIndex) {
      var _sliderRef$current2;
      null == (_sliderRef$current2 = sliderRef.current) || _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
    }
    setActive && setActive(activeIndex);
  }
  function areValuesEqual(newValue, oldValue) {
    return "number" === typeof newValue && "number" === typeof oldValue ? newValue === oldValue : "object" === typeof newValue && "object" === typeof oldValue ? (0,_utils2.areArraysEqual)(newValue, oldValue) : !1;
  }
  function doesSupportTouchActionNone() {
    void 0 === cachedSupportsTouchActionNone && (cachedSupportsTouchActionNone = "undefined" !== typeof CSS && "function" === typeof CSS.supports ? CSS.supports("touch-action", "none") : !0);
    return cachedSupportsTouchActionNone;
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.Identity = void 0;
  exports.useSlider = function(parameters) {
    const {"aria-labelledby":ariaLabelledby, defaultValue, disabled = !1, disableSwap = !1, isRtl = !1, marks:marksProp = !1, max = 100, min = 0, name, onChange, onChangeCommitted, orientation = "horizontal", rootRef:ref, scale = Identity, step = 1, shiftStep = 10, tabIndex, value:valueProp} = parameters, touchId = React.useRef(), [active, setActive] = React.useState(-1), [open, setOpen] = React.useState(-1), [dragging, setDragging] = React.useState(!1), moveCount = React.useRef(0), [valueDerived, 
    setValueState] = (0,_utils.unstable_useControlled)({controlled:valueProp, default:null != defaultValue ? defaultValue : min, name:"Slider"}), handleChange = onChange && ((event, value, thumbIndex) => {
      event = event.nativeEvent || event;
      event = new event.constructor(event.type, event);
      Object.defineProperty(event, "target", {writable:!0, value:{value, name}});
      onChange(event, value, thumbIndex);
    }), range = Array.isArray(valueDerived);
    let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
    values = values.map(value => null == value ? min : (0,_utils.clamp)(value, min, max));
    const marks = !0 === marksProp && null !== step ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({value:min + step * index})) : marksProp || [], marksValues = marks.map(mark => mark.value), {isFocusVisibleRef, onBlur:handleBlurVisible, onFocus:handleFocusVisible, ref:focusVisibleRef} = (0,_utils.unstable_useIsFocusVisible)(), [focusedThumbIndex, setFocusedThumbIndex] = React.useState(-1), sliderRef = React.useRef();
    var handleFocusRef = (0,_utils.unstable_useForkRef)(focusVisibleRef, sliderRef);
    const handleRef = (0,_utils.unstable_useForkRef)(ref, handleFocusRef), createHandleHiddenInputFocus = otherHandlers => event => {
      var _otherHandlers$onFocu;
      const index = Number(event.currentTarget.getAttribute("data-index"));
      handleFocusVisible(event);
      !0 === isFocusVisibleRef.current && setFocusedThumbIndex(index);
      setOpen(index);
      null == otherHandlers || null == (_otherHandlers$onFocu = otherHandlers.onFocus) || _otherHandlers$onFocu.call(otherHandlers, event);
    }, createHandleHiddenInputBlur = otherHandlers => event => {
      var _otherHandlers$onBlur;
      handleBlurVisible(event);
      !1 === isFocusVisibleRef.current && setFocusedThumbIndex(-1);
      setOpen(-1);
      null == otherHandlers || null == (_otherHandlers$onBlur = otherHandlers.onBlur) || _otherHandlers$onBlur.call(otherHandlers, event);
    }, changeValue = (event, valueInput) => {
      const index = Number(event.currentTarget.getAttribute("data-index"));
      var value = values[index], marksIndex = marksValues.indexOf(value);
      if (marks && null == step) {
        const maxMarksValue = marksValues[marksValues.length - 1];
        valueInput = valueInput > maxMarksValue ? maxMarksValue : valueInput < marksValues[0] ? marksValues[0] : valueInput < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
      valueInput = (0,_utils.clamp)(valueInput, min, max);
      range && (disableSwap && (valueInput = (0,_utils.clamp)(valueInput, values[index - 1] || -Infinity, values[index + 1] || Infinity)), value = valueInput, valueInput = setValueIndex({values, newValue:valueInput, index}), marksIndex = index, disableSwap || (marksIndex = valueInput.indexOf(value)), focusThumb({sliderRef, activeIndex:marksIndex}));
      setValueState(valueInput);
      setFocusedThumbIndex(index);
      handleChange && !areValuesEqual(valueInput, valueDerived) && handleChange(event, valueInput, index);
      onChangeCommitted && onChangeCommitted(event, valueInput);
    }, createHandleHiddenInputKeyDown = otherHandlers => event => {
      var _otherHandlers$onKeyD;
      if (null !== step) {
        var index = Number(event.currentTarget.getAttribute("data-index"));
        index = values[index];
        let newValue = null;
        if (("ArrowLeft" === event.key || "ArrowDown" === event.key) && event.shiftKey || "PageDown" === event.key) {
          newValue = Math.max(index - shiftStep, min);
        } else if (("ArrowRight" === event.key || "ArrowUp" === event.key) && event.shiftKey || "PageUp" === event.key) {
          newValue = Math.min(index + shiftStep, max);
        }
        null !== newValue && (changeValue(event, newValue), event.preventDefault());
      }
      null == otherHandlers || null == (_otherHandlers$onKeyD = otherHandlers.onKeyDown) || _otherHandlers$onKeyD.call(otherHandlers, event);
    };
    (0,_utils.unstable_useEnhancedEffect)(() => {
      if (disabled && sliderRef.current.contains(document.activeElement)) {
        var _document$activeEleme;
        null == (_document$activeEleme = document.activeElement) || _document$activeEleme.blur();
      }
    }, [disabled]);
    disabled && -1 !== active && setActive(-1);
    disabled && -1 !== focusedThumbIndex && setFocusedThumbIndex(-1);
    const createHandleHiddenInputChange = otherHandlers => event => {
      var _otherHandlers$onChan;
      null == (_otherHandlers$onChan = otherHandlers.onChange) || _otherHandlers$onChan.call(otherHandlers, event);
      changeValue(event, event.target.valueAsNumber);
    }, previousIndex = React.useRef();
    let axis = orientation;
    isRtl && "horizontal" === orientation && (axis += "-reverse");
    const getFingerNewValue = ({finger, move = !1}) => {
      var {current:slider} = sliderRef;
      const {width, height, bottom, left} = slider.getBoundingClientRect();
      finger = 0 === axis.indexOf("vertical") ? (bottom - finger.y) / height : (finger.x - left) / width;
      -1 !== axis.indexOf("-reverse") && (finger = 1 - finger);
      slider = (max - min) * finger + min;
      if (step) {
        finger = Number;
        slider = Math.round((slider - min) / step) * step + min;
        var JSCompiler_temp_const = slider.toFixed;
        if (1 > Math.abs(step)) {
          var JSCompiler_inline_result = step.toExponential().split("e-");
          const matissaDecimalPart = JSCompiler_inline_result[0].split(".")[1];
          JSCompiler_inline_result = (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(JSCompiler_inline_result[1], 10);
        } else {
          JSCompiler_inline_result = (JSCompiler_inline_result = step.toString().split(".")[1]) ? JSCompiler_inline_result.length : 0;
        }
        slider = finger(JSCompiler_temp_const.call(slider, JSCompiler_inline_result));
      } else {
        finger = findClosest(marksValues, slider), slider = marksValues[finger];
      }
      slider = (0,_utils.clamp)(slider, min, max);
      finger = 0;
      range && (finger = move ? previousIndex.current : findClosest(values, slider), disableSwap && (slider = (0,_utils.clamp)(slider, values[finger - 1] || -Infinity, values[finger + 1] || Infinity)), JSCompiler_temp_const = slider, slider = setValueIndex({values, newValue:slider, index:finger}), disableSwap && move || (finger = slider.indexOf(JSCompiler_temp_const), previousIndex.current = finger));
      return {newValue:slider, activeIndex:finger};
    }, handleTouchMove = (0,_utils.unstable_useEventCallback)(nativeEvent => {
      const finger = trackFinger(nativeEvent, touchId);
      if (finger) {
        if (moveCount.current += 1, "mousemove" === nativeEvent.type && 0 === nativeEvent.buttons) {
          handleTouchEnd(nativeEvent);
        } else {
          var {newValue, activeIndex} = getFingerNewValue({finger, move:!0});
          focusThumb({sliderRef, activeIndex, setActive});
          setValueState(newValue);
          !dragging && 2 < moveCount.current && setDragging(!0);
          handleChange && !areValuesEqual(newValue, valueDerived) && handleChange(nativeEvent, newValue, activeIndex);
        }
      }
    }), handleTouchEnd = (0,_utils.unstable_useEventCallback)(nativeEvent => {
      var finger = trackFinger(nativeEvent, touchId);
      setDragging(!1);
      finger && ({newValue:finger} = getFingerNewValue({finger, move:!0}), setActive(-1), "touchend" === nativeEvent.type && setOpen(-1), onChangeCommitted && onChangeCommitted(nativeEvent, finger), touchId.current = void 0, stopListening());
    }), handleTouchStart = (0,_utils.unstable_useEventCallback)(nativeEvent => {
      if (!disabled) {
        doesSupportTouchActionNone() || nativeEvent.preventDefault();
        var touch = nativeEvent.changedTouches[0];
        null != touch && (touchId.current = touch.identifier);
        touch = trackFinger(nativeEvent, touchId);
        if (!1 !== touch) {
          const {newValue, activeIndex} = getFingerNewValue({finger:touch});
          focusThumb({sliderRef, activeIndex, setActive});
          setValueState(newValue);
          handleChange && !areValuesEqual(newValue, valueDerived) && handleChange(nativeEvent, newValue, activeIndex);
        }
        moveCount.current = 0;
        nativeEvent = (0,_utils.unstable_ownerDocument)(sliderRef.current);
        nativeEvent.addEventListener("touchmove", handleTouchMove, {passive:!0});
        nativeEvent.addEventListener("touchend", handleTouchEnd, {passive:!0});
      }
    }), stopListening = React.useCallback(() => {
      const doc = (0,_utils.unstable_ownerDocument)(sliderRef.current);
      doc.removeEventListener("mousemove", handleTouchMove);
      doc.removeEventListener("mouseup", handleTouchEnd);
      doc.removeEventListener("touchmove", handleTouchMove);
      doc.removeEventListener("touchend", handleTouchEnd);
    }, [handleTouchEnd, handleTouchMove]);
    React.useEffect(() => {
      const {current:slider} = sliderRef;
      slider.addEventListener("touchstart", handleTouchStart, {passive:doesSupportTouchActionNone()});
      return () => {
        slider.removeEventListener("touchstart", handleTouchStart);
        stopListening();
      };
    }, [stopListening, handleTouchStart]);
    React.useEffect(() => {
      disabled && stopListening();
    }, [disabled, stopListening]);
    const createHandleMouseDown = otherHandlers => event => {
      var _otherHandlers$onMous;
      null == (_otherHandlers$onMous = otherHandlers.onMouseDown) || _otherHandlers$onMous.call(otherHandlers, event);
      if (!disabled && !event.defaultPrevented && 0 === event.button) {
        event.preventDefault();
        _otherHandlers$onMous = trackFinger(event, touchId);
        if (!1 !== _otherHandlers$onMous) {
          const {newValue, activeIndex} = getFingerNewValue({finger:_otherHandlers$onMous});
          focusThumb({sliderRef, activeIndex, setActive});
          setValueState(newValue);
          handleChange && !areValuesEqual(newValue, valueDerived) && handleChange(event, newValue, activeIndex);
        }
        moveCount.current = 0;
        event = (0,_utils.unstable_ownerDocument)(sliderRef.current);
        event.addEventListener("mousemove", handleTouchMove, {passive:!0});
        event.addEventListener("mouseup", handleTouchEnd);
      }
    };
    handleFocusRef = valueToPercent(range ? values[0] : min, min, max);
    const trackLeap = valueToPercent(values[values.length - 1], min, max) - handleFocusRef, createHandleMouseOver = otherHandlers => event => {
      var _otherHandlers$onMous2;
      null == (_otherHandlers$onMous2 = otherHandlers.onMouseOver) || _otherHandlers$onMous2.call(otherHandlers, event);
      event = Number(event.currentTarget.getAttribute("data-index"));
      setOpen(event);
    }, createHandleMouseLeave = otherHandlers => event => {
      var _otherHandlers$onMous3;
      null == (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) || _otherHandlers$onMous3.call(otherHandlers, event);
      setOpen(-1);
    };
    return {active, axis, axisProps, dragging, focusedThumbIndex, getHiddenInputProps:(externalProps = {}) => {
      var _parameters$step, externalHandlers = (0,_utils2.extractEventHandlers)(externalProps);
      const ownEventHandlers = {onChange:createHandleHiddenInputChange(externalHandlers || {}), onFocus:createHandleHiddenInputFocus(externalHandlers || {}), onBlur:createHandleHiddenInputBlur(externalHandlers || {}), onKeyDown:createHandleHiddenInputKeyDown(externalHandlers || {})};
      externalHandlers = (0,_extends2.default)({}, externalHandlers, ownEventHandlers);
      return (0,_extends2.default)({tabIndex, "aria-labelledby":ariaLabelledby, "aria-orientation":orientation, "aria-valuemax":scale(max), "aria-valuemin":scale(min), name, type:"range", min:parameters.min, max:parameters.max, step:null === parameters.step && parameters.marks ? "any" : null != (_parameters$step = parameters.step) ? _parameters$step : void 0, disabled}, externalProps, externalHandlers, {style:(0,_extends2.default)({}, _utils.visuallyHidden, {direction:isRtl ? "rtl" : "ltr", width:"100%", 
      height:"100%"})});
    }, getRootProps:(externalProps = {}) => {
      var externalHandlers = (0,_utils2.extractEventHandlers)(externalProps);
      const ownEventHandlers = {onMouseDown:createHandleMouseDown(externalHandlers || {})};
      externalHandlers = (0,_extends2.default)({}, externalHandlers, ownEventHandlers);
      return (0,_extends2.default)({}, externalProps, {ref:handleRef}, externalHandlers);
    }, getThumbProps:(externalProps = {}) => {
      const externalHandlers = (0,_utils2.extractEventHandlers)(externalProps), ownEventHandlers = {onMouseOver:createHandleMouseOver(externalHandlers || {}), onMouseLeave:createHandleMouseLeave(externalHandlers || {})};
      return (0,_extends2.default)({}, externalProps, externalHandlers, ownEventHandlers);
    }, marks, open, range, rootRef:handleRef, trackLeap, trackOffset:handleFocusRef, values, getThumbStyle:index => ({pointerEvents:-1 !== active && active !== index ? "none" : void 0})};
  };
  exports.valueToPercent = valueToPercent;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _utils = require("module$node_modules$$mui$utils$node$index"), _utils2 = require("module$node_modules$$mui$base$node$utils$index");
  const axisProps = {horizontal:{offset:percent => ({left:`${percent}%`}), leap:percent => ({width:`${percent}%`})}, "horizontal-reverse":{offset:percent => ({right:`${percent}%`}), leap:percent => ({width:`${percent}%`})}, vertical:{offset:percent => ({bottom:`${percent}%`}), leap:percent => ({height:`${percent}%`})}}, Identity = x => x;
  exports.Identity = Identity;
  let cachedSupportsTouchActionNone;
};

//# sourceMappingURL=module$node_modules$$mui$base$node$useSlider$useSlider.js.map
