shadow$provide.module$node_modules$spacetime$builds$spacetime_cjs = function(global, require, module, exports) {
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? module.exports = factory() : "function" === typeof define && define.amd ? define(factory) : (global = "undefined" !== typeof globalThis ? globalThis : global || self, global.spacetime = factory());
  })(this, function() {
    function isLeapYear(year) {
      return 0 === year % 4 && 0 !== year % 100 || 0 === year % 400;
    }
    function isDate(d) {
      return "[object Date]" === Object.prototype.toString.call(d) && !isNaN(d.valueOf());
    }
    function isObject(input) {
      return "[object Object]" === Object.prototype.toString.call(input);
    }
    function zeroPad(str, len = 2) {
      str += "";
      return str.length >= len ? str : Array(len - str.length + 1).join("0") + str;
    }
    function ordinal(i) {
      let j = i % 10, k = i % 100;
      return 1 === j && 11 !== k ? i + "st" : 2 === j && 12 !== k ? i + "nd" : 3 === j && 13 !== k ? i + "rd" : i + "th";
    }
    function toCardinal(str) {
      str = String(str);
      str = str.replace(/([0-9])(st|nd|rd|th)$/i, "$1");
      return parseInt(str, 10);
    }
    function normalize$2(str = "") {
      str = str.toLowerCase().trim();
      str = str.replace(/ies$/, "y");
      str = str.replace(/s$/, "");
      str = str.replace(/-/g, "");
      return "day" === str || "days" === str ? "date" : "min" === str || "mins" === str ? "minute" : str;
    }
    function getEpoch(tmp) {
      return "number" === typeof tmp ? tmp : isDate(tmp) ? tmp.getTime() : tmp.epoch ? tmp.epoch : null;
    }
    function beADate(d, s) {
      return !1 === isObject(d) ? s.clone().set(d) : d;
    }
    function formatTimezone(offset, delimiter = "") {
      const sign = 0 < offset ? "+" : "-";
      var absOffset = Math.abs(offset);
      offset = zeroPad(parseInt("" + absOffset, 10));
      absOffset = zeroPad(absOffset % 1 * 60);
      return `${sign}${offset}${delimiter}${absOffset}`;
    }
    function buildMapping() {
      const obj = {sep:8};
      for (var i = 0; i < shortMonths.length; i++) {
        obj[shortMonths[i]] = i;
      }
      for (i = 0; i < longMonths.length; i++) {
        obj[longMonths[i]] = i;
      }
      return obj;
    }
    function getDiff(a, b) {
      const isBefore = a.isBefore(b), later = isBefore ? b : a;
      let earlier = isBefore ? a : b;
      earlier = earlier.clone();
      const diff = {years:0, months:0, days:0, hours:0, minutes:0, seconds:0};
      Object.keys(diff).forEach(unit => {
        if (!earlier.isSame(later, unit)) {
          var max = earlier.diff(later, unit);
          earlier = earlier.add(max, unit);
          diff[unit] = max;
        }
      });
      isBefore && Object.keys(diff).forEach(u => {
        0 !== diff[u] && (diff[u] *= -1);
      });
      return diff;
    }
    function set$2(i18n = {}) {
      units$2 = {second:i18n.second || units$2.second, seconds:i18n.seconds || units$2.seconds, minute:i18n.minute || units$2.minute, minutes:i18n.minutes || units$2.minutes, hour:i18n.hour || units$2.hour, hours:i18n.hours || units$2.hours, day:i18n.day || units$2.day, days:i18n.days || units$2.days, month:i18n.month || units$2.month, months:i18n.months || units$2.months, year:i18n.year || units$2.year, years:i18n.years || units$2.years};
    }
    function pluralize(value, unit) {
      return 1 === value ? (unit = unit.slice(0, -1), value + " " + (units$2[unit] || "")) : value + " " + (units$2[unit] || "");
    }
    const toUtc = (dstChange, offset, year) => {
      const [month, rest] = dstChange.split("/"), [day, hour] = rest.split(":");
      return Date.UTC(year, month - 1, day, hour) - 36E5 * offset;
    };
    var inSummerTime$1 = (epoch, start, end, summerOffset, winterOffset) => {
      const year = (new Date(epoch)).getUTCFullYear();
      start = toUtc(start, winterOffset, year);
      end = toUtc(end, summerOffset, year);
      return epoch >= start && epoch < end;
    }, data = {"9|s":"2/dili,2/jayapura", "9|n":"2/chita,2/khandyga,2/pyongyang,2/seoul,2/tokyo,2/yakutsk,11/palau,japan,rok", "9.5|s|04/07:03-\x3e10/06:02":"4/adelaide,4/broken_hill,4/south,4/yancowinna", "9.5|s":"4/darwin,4/north", "8|s|03/13:01-\x3e10/02:00":"12/casey", "8|s":"2/kuala_lumpur,2/makassar,2/singapore,4/perth,2/ujung_pandang,4/west,singapore", "8|n":"2/brunei,2/choibalsan,2/hong_kong,2/irkutsk,2/kuching,2/macau,2/manila,2/shanghai,2/taipei,2/ulaanbaatar,2/chongqing,2/chungking,2/harbin,2/macao,2/ulan_bator,hongkong,prc,roc", 
    "8.75|s":"4/eucla", "7|s":"12/davis,2/jakarta,9/christmas", "7|n":"2/bangkok,2/barnaul,2/hovd,2/krasnoyarsk,2/novokuznetsk,2/novosibirsk,2/phnom_penh,2/pontianak,2/ho_chi_minh,2/tomsk,2/vientiane,2/saigon", "6|s":"12/vostok", "6|n":"2/almaty,2/bishkek,2/dhaka,2/omsk,2/qyzylorda,2/qostanay,2/thimphu,2/urumqi,9/chagos,2/dacca,2/kashgar,2/thimbu", "6.5|n":"2/yangon,9/cocos,2/rangoon", "5|s":"12/mawson,9/kerguelen", "5|n":"2/aqtau,2/aqtobe,2/ashgabat,2/atyrau,2/dushanbe,2/karachi,2/oral,2/samarkand,2/tashkent,2/yekaterinburg,9/maldives,2/ashkhabad", 
    "5.75|n":"2/kathmandu,2/katmandu", "5.5|n":"2/kolkata,2/colombo,2/calcutta", "4|s":"9/reunion", "4|n":"2/baku,2/dubai,2/muscat,2/tbilisi,2/yerevan,8/astrakhan,8/samara,8/saratov,8/ulyanovsk,8/volgograd,9/mahe,9/mauritius,2/volgograd", "4.5|n":"2/kabul", "3|s":"12/syowa,9/antananarivo", "3|n|04/26:00-\x3e10/31:24":"0/cairo,egypt", "3|n|04/20:02-\x3e10/26:02":"2/gaza,2/hebron", "3|n|03/31:03-\x3e10/27:04":"2/famagusta,2/nicosia,8/athens,8/bucharest,8/helsinki,8/kyiv,8/mariehamn,8/riga,8/sofia,8/tallinn,8/uzhgorod,8/vilnius,8/zaporozhye,8/nicosia,8/kiev,eet", 
    "3|n|03/31:02-\x3e10/27:03":"8/chisinau,8/tiraspol", "3|n|03/31:00-\x3e10/26:24":"2/beirut", "3|n|03/29:02-\x3e10/27:02":"2/jerusalem,2/tel_aviv,israel", "3|n":"0/addis_ababa,0/asmara,0/asmera,0/dar_es_salaam,0/djibouti,0/juba,0/kampala,0/mogadishu,0/nairobi,2/aden,2/amman,2/baghdad,2/bahrain,2/damascus,2/kuwait,2/qatar,2/riyadh,8/istanbul,8/kirov,8/minsk,8/moscow,8/simferopol,9/comoro,9/mayotte,2/istanbul,turkey,w-su", "3.5|n":"2/tehran,iran", "2|s|03/31:02-\x3e10/27:02":"12/troll", "2|s":"0/gaborone,0/harare,0/johannesburg,0/lubumbashi,0/lusaka,0/maputo,0/maseru,0/mbabane", 
    "2|n|03/31:02-\x3e10/27:03":"0/ceuta,arctic/longyearbyen,8/amsterdam,8/andorra,8/belgrade,8/berlin,8/bratislava,8/brussels,8/budapest,8/busingen,8/copenhagen,8/gibraltar,8/ljubljana,8/luxembourg,8/madrid,8/malta,8/monaco,8/oslo,8/paris,8/podgorica,8/prague,8/rome,8/san_marino,8/sarajevo,8/skopje,8/stockholm,8/tirane,8/vaduz,8/vatican,8/vienna,8/warsaw,8/zagreb,8/zurich,3/jan_mayen,poland,cet,met", "2|n":"0/blantyre,0/bujumbura,0/khartoum,0/kigali,0/tripoli,8/kaliningrad,libya", "1|s":"0/brazzaville,0/kinshasa,0/luanda,0/windhoek", 
    "1|n|03/31:01-\x3e10/27:02":"3/canary,3/faroe,3/madeira,8/dublin,8/guernsey,8/isle_of_man,8/jersey,8/lisbon,8/london,3/faeroe,eire,8/belfast,gb-eire,gb,portugal,wet", "1|n":"0/algiers,0/bangui,0/douala,0/lagos,0/libreville,0/malabo,0/ndjamena,0/niamey,0/porto-novo,0/tunis", "14|n":"11/kiritimati", "13|s":"11/apia,11/tongatapu", "13|n":"11/enderbury,11/kanton,11/fakaofo", "12|s|04/07:03-\x3e09/29:02":"12/mcmurdo,11/auckland,12/south_pole,nz", "12|s":"11/fiji", "12|n":"2/anadyr,2/kamchatka,2/srednekolymsk,11/funafuti,11/kwajalein,11/majuro,11/nauru,11/tarawa,11/wake,11/wallis,kwajalein", 
    "12.75|s|04/07:03-\x3e04/07:02":"11/chatham,nz-chat", "11|s|04/07:03-\x3e10/06:02":"12/macquarie", "11|s":"11/bougainville", "11|n":"2/magadan,2/sakhalin,11/efate,11/guadalcanal,11/kosrae,11/noumea,11/pohnpei,11/ponape", "11.5|n|04/07:03-\x3e10/06:02":"11/norfolk", "10|s|04/07:03-\x3e10/06:02":"4/currie,4/hobart,4/melbourne,4/sydney,4/act,4/canberra,4/nsw,4/tasmania,4/victoria", "10|s":"12/dumontdurville,4/brisbane,4/lindeman,11/port_moresby,4/queensland", "10|n":"2/ust-nera,2/vladivostok,11/guam,11/saipan,11/chuuk,11/truk,11/yap", 
    "10.5|s|04/07:01-\x3e10/06:02":"4/lord_howe,4/lhi", "0|s|03/10:03-\x3e04/14:02":"0/casablanca,0/el_aaiun", "0|n|03/31:00-\x3e10/27:01":"1/scoresbysund,3/azores", "0|n":"0/abidjan,0/accra,0/bamako,0/banjul,0/bissau,0/conakry,0/dakar,0/freetown,0/lome,0/monrovia,0/nouakchott,0/ouagadougou,0/sao_tome,1/danmarkshavn,3/reykjavik,3/st_helena,13/gmt,13/utc,0/timbuktu,13/greenwich,13/uct,13/universal,13/zulu,gmt-0,gmt+0,gmt0,greenwich,iceland,uct,universal,utc,zulu,13/unknown,factory", "-9|n|03/10:02-\x3e11/03:02":"1/adak,1/atka,us/aleutian", 
    "-9|n":"11/gambier", "-9.5|n":"11/marquesas", "-8|n|03/10:02-\x3e11/03:02":"1/anchorage,1/juneau,1/metlakatla,1/nome,1/sitka,1/yakutat,us/alaska", "-8|n":"11/pitcairn", "-7|n|03/10:02-\x3e11/03:02":"1/los_angeles,1/santa_isabel,1/tijuana,1/vancouver,1/ensenada,6/pacific,10/bajanorte,us/pacific-new,us/pacific", "-7|n":"1/creston,1/dawson,1/dawson_creek,1/fort_nelson,1/hermosillo,1/mazatlan,1/phoenix,1/whitehorse,6/yukon,10/bajasur,us/arizona,mst", "-6|s|04/06:22-\x3e09/07:22":"11/easter,7/easterisland", 
    "-6|n|04/07:02-\x3e10/27:02":"1/merida", "-6|n|03/10:02-\x3e11/03:02":"1/boise,1/cambridge_bay,1/denver,1/edmonton,1/inuvik,1/north_dakota,1/ojinaga,1/ciudad_juarez,1/yellowknife,1/shiprock,6/mountain,navajo,us/mountain", "-6|n":"1/bahia_banderas,1/belize,1/chihuahua,1/costa_rica,1/el_salvador,1/guatemala,1/managua,1/mexico_city,1/monterrey,1/regina,1/swift_current,1/tegucigalpa,11/galapagos,6/east-saskatchewan,6/saskatchewan,10/general", "-5|s":"1/lima,1/rio_branco,1/porto_acre,5/acre", "-5|n|03/10:02-\x3e11/03:02":"1/chicago,1/matamoros,1/menominee,1/rainy_river,1/rankin_inlet,1/resolute,1/winnipeg,1/indiana/knox,1/indiana/tell_city,1/north_dakota/beulah,1/north_dakota/center,1/north_dakota/new_salem,1/knox_in,6/central,us/central,us/indiana-starke", 
    "-5|n":"1/bogota,1/cancun,1/cayman,1/coral_harbour,1/eirunepe,1/guayaquil,1/jamaica,1/panama,1/atikokan,jamaica,est", "-4|s|04/06:24-\x3e09/08:00":"1/santiago,7/continental", "-4|s|03/23:24-\x3e10/06:00":"1/asuncion", "-4|s":"1/campo_grande,1/cuiaba,1/la_paz,1/manaus,5/west", "-4|n|03/10:02-\x3e11/03:02":"1/detroit,1/grand_turk,1/indiana,1/indianapolis,1/iqaluit,1/kentucky,1/louisville,1/montreal,1/nassau,1/new_york,1/nipigon,1/pangnirtung,1/port-au-prince,1/thunder_bay,1/toronto,1/indiana/marengo,1/indiana/petersburg,1/indiana/vevay,1/indiana/vincennes,1/indiana/winamac,1/kentucky/monticello,1/fort_wayne,1/indiana/indianapolis,1/kentucky/louisville,6/eastern,us/east-indiana,us/eastern,us/michigan", 
    "-4|n|03/10:00-\x3e11/03:01":"1/havana,cuba", "-4|n":"1/anguilla,1/antigua,1/aruba,1/barbados,1/blanc-sablon,1/boa_vista,1/caracas,1/curacao,1/dominica,1/grenada,1/guadeloupe,1/guyana,1/kralendijk,1/lower_princes,1/marigot,1/martinique,1/montserrat,1/port_of_spain,1/porto_velho,1/puerto_rico,1/santo_domingo,1/st_barthelemy,1/st_kitts,1/st_lucia,1/st_thomas,1/st_vincent,1/tortola,1/virgin", "-3|s":"1/argentina,1/buenos_aires,1/catamarca,1/cordoba,1/fortaleza,1/jujuy,1/mendoza,1/montevideo,1/punta_arenas,1/sao_paulo,12/palmer,12/rothera,3/stanley,1/argentina/la_rioja,1/argentina/rio_gallegos,1/argentina/salta,1/argentina/san_juan,1/argentina/san_luis,1/argentina/tucuman,1/argentina/ushuaia,1/argentina/comodrivadavia,1/argentina/buenos_aires,1/argentina/catamarca,1/argentina/cordoba,1/argentina/jujuy,1/argentina/mendoza,1/argentina/rosario,1/rosario,5/east", 
    "-3|n|03/10:02-\x3e11/03:02":"1/glace_bay,1/goose_bay,1/halifax,1/moncton,1/thule,3/bermuda,6/atlantic", "-3|n":"1/araguaina,1/bahia,1/belem,1/cayenne,1/maceio,1/paramaribo,1/recife,1/santarem", "-2|n|03/30:22-\x3e10/26:23":"1/nuuk,1/godthab", "-2|n|03/10:02-\x3e11/03:02":"1/miquelon", "-2|n":"1/noronha,3/south_georgia,5/denoronha", "-2.5|n|03/10:02-\x3e11/03:02":"1/st_johns,6/newfoundland", "-1|n":"3/cape_verde", "-11|n":"11/midway,11/niue,11/pago_pago,11/samoa,us/samoa", "-10|n":"11/honolulu,11/johnston,11/rarotonga,11/tahiti,us/hawaii,hst"}, 
    prefixes = "africa america asia atlantic australia brazil canada chile europe indian mexico pacific antarctica etc".split(" ");
    let all = {};
    Object.keys(data).forEach(k => {
      let split = k.split("|"), obj = {offset:Number(split[0]), hem:split[1]};
      split[2] && (obj.dst = split[2]);
      data[k].split(",").forEach(str => {
        str = str.replace(/(^[0-9]+)\//, (before, num) => {
          num = Number(num);
          return prefixes[num] + "/";
        });
        all[str] = obj;
      });
    });
    all.utc = {offset:0, hem:"n"};
    for (let i = -14; 14 >= i; i += 0.5) {
      let num = i;
      0 < num && (num = "+" + num);
      let name = "etc/gmt" + num;
      all[name] = {offset:-1 * i, hem:"n"};
      name = "utc/gmt" + num;
      all[name] = {offset:-1 * i, hem:"n"};
    }
    const safeIntl = () => {
      if ("undefined" === typeof Intl || "undefined" === typeof Intl.DateTimeFormat) {
        return null;
      }
      var format = Intl.DateTimeFormat();
      return "undefined" === typeof format || "undefined" === typeof format.resolvedOptions ? null : (format = format.resolvedOptions().timeZone) ? format.toLowerCase() : null;
    }, isOffset = /(\-?[0-9]+)h(rs)?/i, isNumber = /(\-?[0-9]+)/, utcOffset = /utc([\-+]?[0-9]+)/i, gmtOffset = /gmt([\-+]?[0-9]+)/i, toIana = function(num) {
      num = Number(num);
      return -13 <= num && 13 >= num ? (num *= -1, "etc/gmt" + ((0 < num ? "+" : "") + num)) : null;
    };
    var parseOffset$3 = function(tz) {
      let m = tz.match(isOffset);
      if (null !== m) {
        return toIana(m[1]);
      }
      m = tz.match(utcOffset);
      if (null !== m) {
        return toIana(m[1]);
      }
      m = tz.match(gmtOffset);
      if (null !== m) {
        return toIana(-1 * Number(m[1]));
      }
      m = tz.match(isNumber);
      return null !== m ? toIana(m[1]) : null;
    };
    let local = (() => {
      let timezone = safeIntl();
      return null === timezone ? "utc" : timezone;
    })();
    const cities = Object.keys(all).reduce((h, k) => {
      let city = k.split("/")[1] || "";
      city = city.replace(/_/g, " ");
      h[city] = k;
      return h;
    }, {});
    var findTz = (str, zones) => {
      if (!str) {
        return zones.hasOwnProperty(local) || (console.warn(`Unrecognized IANA id '${local}'. Setting fallback tz to UTC.`), local = "utc"), local;
      }
      "string" !== typeof str && console.error("Timezone must be a string - recieved: '", str, "'\n");
      var tz = str.trim();
      tz = tz.toLowerCase();
      if (!0 === zones.hasOwnProperty(tz)) {
        return tz;
      }
      tz = tz.replace(/ time/g, "");
      tz = tz.replace(/ (standard|daylight|summer)/g, "");
      tz = tz.replace(/\b(east|west|north|south)ern/g, "$1");
      tz = tz.replace(/\b(africa|america|australia)n/g, "$1");
      tz = tz.replace(/\beuropean/g, "europe");
      tz = tz.replace(/islands/g, "island");
      if (!0 === zones.hasOwnProperty(tz)) {
        return tz;
      }
      if (!0 === cities.hasOwnProperty(tz)) {
        return cities[tz];
      }
      if (!0 === /[0-9]/.test(tz) && (zones = parseOffset$3(tz))) {
        return zones;
      }
      throw Error("Spacetime: Cannot find timezone named: '" + str + "'. Please enter an IANA timezone id.");
    };
    const defaults$1 = {year:(new Date()).getFullYear(), month:0, date:1}, getNow = function(s) {
      s.epoch = Date.now();
      Object.keys(s._today || {}).forEach(k => {
        "function" === typeof s[k] && (s = s[k](s._today[k]));
      });
      return s;
    }, dates = {now:s => getNow(s), today:s => getNow(s), tonight:s => {
      s = getNow(s);
      return s = s.hour(18);
    }, tomorrow:s => {
      s = getNow(s);
      s = s.add(1, "day");
      return s = s.startOf("day");
    }, yesterday:s => {
      s = getNow(s);
      s = s.subtract(1, "day");
      return s = s.startOf("day");
    }, christmas:s => {
      let year = getNow(s).year();
      return s = s.set([year, 11, 25, 18, 0, 0]);
    }, "new years":s => {
      let year = getNow(s).year();
      return s = s.set([year, 11, 31, 18, 0, 0]);
    }};
    dates["new years eve"] = dates["new years"];
    let o = {millisecond:1, second:1000, minute:60000, hour:3.6e6, day:8.64e7};
    o.date = o.day;
    o.month = 25488E5;
    o.week = 6.048e8;
    o.year = 3.154e10;
    Object.keys(o).forEach(k => {
      o[k + "s"] = o[k];
    });
    const walk = (s, n, fn, unit, previous) => {
      var current = s.d[fn]();
      if (current !== n) {
        var startUnit = null === previous ? null : s.d[previous](), original = s.epoch;
        current = n - current;
        s.epoch += o[unit] * current;
        "day" === unit && 28 < Math.abs(current) && 28 > n && (s.epoch += o.hour);
        null !== previous && startUnit !== s.d[previous]() && (s.epoch = original);
        for (unit = o[unit] / 2; s.d[fn]() < n;) {
          s.epoch += unit;
        }
        for (; s.d[fn]() > n;) {
          s.epoch -= unit;
        }
        null !== previous && startUnit !== s.d[previous]() && (s.epoch = original);
      }
    }, units$4 = {year:{valid:n => -4000 < n && 4000 > n, walkTo:(s, n) => walk(s, n, "getFullYear", "year", null)}, month:{valid:n => 0 <= n && 11 >= n, walkTo:(s, n) => {
      var d = s.d;
      let current = d.getMonth(), original = s.epoch;
      d = d.getFullYear();
      if (current !== n) {
        s.epoch += 28 * o.day * (n - current);
        d !== s.d.getFullYear() && (s.epoch = original);
        for (; s.d.getMonth() < n;) {
          s.epoch += o.day;
        }
        for (; s.d.getMonth() > n;) {
          s.epoch -= o.day;
        }
      }
    }}, date:{valid:n => 0 < n && 31 >= n, walkTo:(s, n) => walk(s, n, "getDate", "day", "getMonth")}, hour:{valid:n => 0 <= n && 24 > n, walkTo:(s, n) => walk(s, n, "getHours", "hour", "getDate")}, minute:{valid:n => 0 <= n && 60 > n, walkTo:(s, n) => walk(s, n, "getMinutes", "minute", "getHours")}, second:{valid:n => 0 <= n && 60 > n, walkTo:(s, n) => {
      s.epoch = s.seconds(n).epoch;
    }}, millisecond:{valid:n => 0 <= n && 1000 > n, walkTo:(s, n) => {
      s.epoch = s.milliseconds(n).epoch;
    }}};
    var walkTo$1 = (s, wants) => {
      let keys = Object.keys(units$4), old = s.clone();
      for (let i = 0; i < keys.length; i++) {
        let k = keys[i], n = wants[k];
        void 0 === n && (n = old[k]());
        "string" === typeof n && (n = parseInt(n, 10));
        if (!units$4[k].valid(n)) {
          s.epoch = null;
          !1 === s.silent && console.warn("invalid " + k + ": " + n);
          break;
        }
        units$4[k].walkTo(s, n);
      }
    }, monthLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    let shortMonths = "jan feb mar apr may jun jul aug sep oct nov dec".split(" "), longMonths = "january february march april may june july august september october november december".split(" ");
    var parseOffset$1 = (s, offset) => {
      if (!offset) {
        return s;
      }
      offset = offset.trim().toLowerCase();
      let num;
      /^[\+-]?[0-9]{2}:[0-9]{2}$/.test(offset) && (!0 === /:00/.test(offset) && (offset = offset.replace(/:00/, "")), !0 === /:30/.test(offset) && (offset = offset.replace(/:30/, ".5")));
      /^[\+-]?[0-9]{4}$/.test(offset) && (offset = offset.replace(/30$/, ".5"));
      num = parseFloat(offset);
      100 < Math.abs(num) && (num /= 100);
      if (0 === num || "Z" === offset || "z" === offset) {
        return s.tz = "etc/gmt", s;
      }
      num *= -1;
      0 <= num && (num = "+" + num);
      offset = "etc/gmt" + num;
      s.timezones[offset] && (s.tz = offset);
      return s;
    };
    const parseMs = function(str = "") {
      str = String(str);
      3 < str.length ? str = str.substring(0, 3) : 1 === str.length ? str += "00" : 2 === str.length && (str += "0");
      return Number(str) || 0;
    };
    var parseTime$1 = (s, str = "") => {
      str = str.replace(/^\s+/, "").toLowerCase();
      var arr = str.match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:\.]?([0-9]{1,4})?/);
      if (null !== arr) {
        let [, h, m, sec, ms] = arr;
        h = Number(h);
        if (0 > h || 24 < h) {
          return s.startOf("day");
        }
        m = Number(m);
        if (2 > arr[2].length || 0 > m || 59 < m) {
          return s.startOf("day");
        }
        s = s.hour(h);
        s = s.minute(m);
        s = s.seconds(sec || 0);
        s = s.millisecond(parseMs(ms));
        arr = str.match(/[\b0-9] ?(am|pm)\b/);
        null !== arr && arr[1] && (s = s.ampm(arr[1]));
        return s;
      }
      arr = str.match(/([0-9]+) ?(am|pm)/);
      if (null !== arr && arr[1]) {
        str = Number(arr[1]);
        if (12 < str || 1 > str) {
          return s.startOf("day");
        }
        s = s.hour(arr[1] || 0);
        s = s.ampm(arr[2]);
        return s = s.startOf("hour");
      }
      return s = s.startOf("day");
    };
    let months$1 = buildMapping();
    const validate$1 = obj => !0 !== monthLength.hasOwnProperty(obj.month) ? !1 : 1 === obj.month ? isLeapYear(obj.year) && 29 >= obj.date ? !0 : 28 >= obj.date : obj.date <= (monthLength[obj.month] || 0) ? !0 : !1, parseYear = (str = "", today) => {
      str = str.trim();
      if (!0 === /^'[0-9][0-9]$/.test(str)) {
        return today = Number(str.replace(/'/, "")), 50 < today ? 1900 + today : 2000 + today;
      }
      str = parseInt(str, 10);
      !str && today && (str = today.year);
      return str = str || (new Date()).getFullYear();
    }, parseMonth = function(str) {
      str = str.toLowerCase().trim();
      return "sept" === str ? months$1.sep : months$1[str];
    };
    var parsers = [].concat([{reg:/^(\-?0?0?[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\-\+:]+)?$/i, parse:(s, m) => {
      let obj = {year:m[1], month:parseInt(m[2], 10) - 1, date:m[3]};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      parseOffset$1(s, m[5]);
      walkTo$1(s, obj);
      return s = parseTime$1(s, m[4]);
    }}, {reg:/^([0-9]{4})[\-\/\. ]([0-9]{1,2})[\-\/\. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse:(s, m) => {
      let obj = {year:m[1], month:parseInt(m[2], 10) - 1, date:parseInt(m[3], 10)};
      12 <= obj.month && (obj.date = parseInt(m[2], 10), obj.month = parseInt(m[3], 10) - 1);
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, m[4]);
    }}, {reg:/^([0-9]{4})[\-\/\. ]([a-z]+)[\-\/\. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse:(s, m) => {
      let obj = {year:parseYear(m[1], s._today), month:parseMonth(m[2]), date:toCardinal(m[3] || "")};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, m[4]);
    }}], [{reg:/^([0-9]{1,2})[\-\/.]([0-9]{1,2})[\-\/.]?([0-9]{4})?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i, parse:(s, arr) => {
      var month = parseInt(arr[1], 10) - 1;
      let date = parseInt(arr[2], 10);
      if (s.british || 12 <= month) {
        date = parseInt(arr[1], 10), month = parseInt(arr[2], 10) - 1;
      }
      month = {date, month, year:parseYear(arr[3], s._today) || (new Date()).getFullYear()};
      if (!1 === validate$1(month)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, month);
      return s = parseTime$1(s, arr[4]);
    }}, {reg:/^([a-z]+)[\-\/\. ]([0-9]{1,2})[\-\/\. ]?([0-9]{4}|'[0-9]{2})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse:(s, arr) => {
      let obj = {year:parseYear(arr[3], s._today), month:parseMonth(arr[1]), date:toCardinal(arr[2] || "")};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, arr[4]);
    }}, {reg:/^([a-z]+) ([0-9]{1,2})( [0-9]{4})?( ([0-9:]+( ?am| ?pm| ?gmt)?))?$/i, parse:(s, arr) => {
      let obj = {year:parseYear(arr[3], s._today), month:parseMonth(arr[1]), date:toCardinal(arr[2] || "")};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, arr[4]);
    }}, {reg:/^([a-z]+) ([0-9]{1,2}) ([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2})( \+[0-9]{4})?( [0-9]{4})?$/i, parse:(s, arr) => {
      let [, month, date, time, tz, year] = arr;
      arr = {year:parseYear(year, s._today), month:parseMonth(month), date:toCardinal(date || "")};
      if (!1 === validate$1(arr)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, arr);
      s = parseOffset$1(s, tz);
      return s = parseTime$1(s, time);
    }}], [{reg:/^([0-9]{1,2})[\-\/]([a-z]+)[\-\/]?([0-9]{4})?$/i, parse:(s, m) => {
      let obj = {year:parseYear(m[3], s._today), month:parseMonth(m[2]), date:toCardinal(m[1] || "")};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, m[4]);
    }}, {reg:/^([0-9]{1,2})( [a-z]+)( [0-9]{4}| '[0-9]{2})? ?([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i, parse:(s, m) => {
      let obj = {year:parseYear(m[3], s._today), month:parseMonth(m[2]), date:toCardinal(m[1])};
      if (!obj.month || !1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, m[4]);
    }}, {reg:/^([0-9]{1,2})[\. -/]([a-z]+)[\. -/]([0-9]{4})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse:(s, m) => {
      let obj = {date:Number(m[1]), month:parseMonth(m[2]), year:Number(m[3])};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      s = s.startOf("day");
      return s = parseTime$1(s, m[4]);
    }}], [{reg:/^([0-9]{4})[\-\/]([0-9]{2})$/i, parse:(s, m) => {
      let obj = {year:m[1], month:parseInt(m[2], 10) - 1, date:1};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, m[4]);
    }}, {reg:/^([a-z]+) ([0-9]{4})$/i, parse:(s, arr) => {
      let obj = {year:parseYear(arr[2], s._today), month:parseMonth(arr[1]), date:s._today.date || 1};
      if (!1 === validate$1(obj)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, obj);
      return s = parseTime$1(s, arr[4]);
    }}, {reg:/^(q[0-9])( of)?( [0-9]{4})?/i, parse:(s, arr) => {
      s = s.quarter(arr[1] || "");
      if (arr = arr[3] || "") {
        arr = arr.trim(), s = s.year(arr);
      }
      return s;
    }}, {reg:/^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i, parse:(s, arr) => {
      s = s.season(arr[1] || "");
      if (arr = arr[3] || "") {
        arr = arr.trim(), s = s.year(arr);
      }
      return s;
    }}, {reg:/^[0-9,]+ ?b\.?c\.?$/i, parse:(s, arr) => {
      arr = arr[0] || "";
      arr = arr.replace(/^([0-9,]+) ?b\.?c\.?$/i, "-$1");
      let d = new Date();
      arr = {year:parseInt(arr.trim(), 10), month:d.getMonth(), date:d.getDate()};
      if (!1 === validate$1(arr)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, arr);
      return s = parseTime$1(s);
    }}, {reg:/^[0-9,]+ ?(a\.?d\.?|c\.?e\.?)$/i, parse:(s, arr) => {
      arr = arr[0] || "";
      arr = arr.replace(/,/g, "");
      let d = new Date();
      arr = {year:parseInt(arr.trim(), 10), month:d.getMonth(), date:d.getDate()};
      if (!1 === validate$1(arr)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, arr);
      return s = parseTime$1(s);
    }}, {reg:/^[0-9]{4}( ?a\.?d\.?)?$/i, parse:(s, arr) => {
      let today = s._today;
      today.month && !today.date && (today.date = 1);
      let d = new Date();
      arr = {year:parseYear(arr[0], today), month:today.month || d.getMonth(), date:today.date || d.getDate()};
      if (!1 === validate$1(arr)) {
        return s.epoch = null, s;
      }
      walkTo$1(s, arr);
      return s = parseTime$1(s);
    }}]);
    const {parseArray, parseObject, parseNumber} = {parseArray:(s, arr, today) => {
      if (0 === arr.length) {
        return s;
      }
      let order = "year month date hour minute second millisecond".split(" ");
      for (let i = 0; i < order.length; i++) {
        s = s[order[i]](arr[i] || today[order[i]] || defaults$1[order[i]] || 0);
      }
      return s;
    }, parseObject:(s, obj, today) => {
      if (0 === Object.keys(obj).length) {
        return s;
      }
      obj = Object.assign({}, defaults$1, today, obj);
      let keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        let unit = keys[i];
        void 0 !== s[unit] && "function" === typeof s[unit] && null !== obj[unit] && void 0 !== obj[unit] && "" !== obj[unit] && (s = s[unit](obj[unit] || today[unit] || defaults$1[unit] || 0));
      }
      return s;
    }, parseNumber:function(s, input) {
      0 < input && 2500000000 > input && !1 === s.silent && (console.warn("  - Warning: You are setting the date to January 1970."), console.warn("       -   did input seconds instead of milliseconds?"));
      s.epoch = input;
      return s;
    }}, defaults = {year:(new Date()).getFullYear(), month:0, date:1};
    var handleInput = (s, input) => {
      var today = s._today || defaults;
      if ("number" === typeof input) {
        return parseNumber(s, input);
      }
      s.epoch = Date.now();
      if (s._today && isObject(s._today) && 0 < Object.keys(s._today).length) {
        var res = parseObject(s, today, defaults);
        res.isValid() && (s.epoch = res.epoch);
      }
      if (null === input || void 0 === input || "" === input) {
        return s;
      }
      if (!0 === isDate(input)) {
        return s.epoch = input.getTime(), s;
      }
      if ("[object Array]" === Object.prototype.toString.call(input) === !0) {
        return s = parseArray(s, input, today);
      }
      if (!0 === isObject(input)) {
        return input.epoch ? (s.epoch = input.epoch, s.tz = input.tz, s) : s = parseObject(s, input, today);
      }
      if ("string" !== typeof input) {
        return s;
      }
      input = input.replace(/\b(mon|tues?|wed|wednes|thur?s?|fri|sat|satur|sun)(day)?\b/i, "");
      input = input.replace(/([0-9])(th|rd|st|nd)/, "$1");
      input = input.replace(/,/g, "");
      input = input.replace(/ +/g, " ").trim();
      if (!0 === dates.hasOwnProperty(input)) {
        return s = dates[input](s);
      }
      a: {
        for (today = 0; today < parsers.length; today++) {
          if (res = input.match(parsers[today].reg)) {
            if (res = parsers[today].parse(s, res, void 0), null !== res && res.isValid()) {
              s = res;
              break a;
            }
          }
        }
        !1 === s.silent && console.warn("Warning: couldn't parse date-string: '" + input + "'");
        s.epoch = null;
      }
      return s;
    };
    let shortDays = "sun mon tue wed thu fri sat".split(" "), longDays = "sunday monday tuesday wednesday thursday friday saturday".split(" ");
    const aliases$1 = {mo:1, tu:2, we:3, th:4, fr:5, sa:6, su:7, tues:2, weds:3, wedn:3, thur:4, thurs:4};
    let titleCaseEnabled = !0;
    var isoOffset$1 = s => (s = s.timezone().current.offset) ? formatTimezone(s, ":") : "Z";
    const applyCaseFormat = str => titleCaseEnabled ? (str = str ? str[0].toUpperCase() + str.substr(1) : "", str) : str, format = {day:s => applyCaseFormat(s.dayName()), "day-short":s => applyCaseFormat(shortDays[s.day()]), "day-number":s => s.day(), "day-ordinal":s => ordinal(s.day()), "day-pad":s => zeroPad(s.day()), date:s => s.date(), "date-ordinal":s => ordinal(s.date()), "date-pad":s => zeroPad(s.date()), month:s => applyCaseFormat(s.monthName()), "month-short":s => applyCaseFormat(shortMonths[s.month()]), 
    "month-number":s => s.month(), "month-ordinal":s => ordinal(s.month()), "month-pad":s => zeroPad(s.month()), "iso-month":s => zeroPad(s.month() + 1), year:s => {
      s = s.year();
      if (0 < s) {
        return s;
      }
      s = Math.abs(s);
      return s + " BC";
    }, "year-short":s => {
      let year = s.year();
      if (0 < year) {
        return `'${String(s.year()).substr(2, 4)}`;
      }
      year = Math.abs(year);
      return year + " BC";
    }, "iso-year":s => {
      var year = s.year();
      s = 0 > year;
      year = zeroPad(Math.abs(year), 4);
      s && (year = zeroPad(year, 6), year = "-" + year);
      return year;
    }, time:s => s.time(), "time-24":s => `${s.hour24()}:${zeroPad(s.minute())}`, hour:s => s.hour12(), "hour-pad":s => zeroPad(s.hour12()), "hour-24":s => s.hour24(), "hour-24-pad":s => zeroPad(s.hour24()), minute:s => s.minute(), "minute-pad":s => zeroPad(s.minute()), second:s => s.second(), "second-pad":s => zeroPad(s.second()), millisecond:s => s.millisecond(), "millisecond-pad":s => zeroPad(s.millisecond(), 3), ampm:s => s.ampm(), AMPM:s => s.ampm().toUpperCase(), quarter:s => "Q" + s.quarter(), 
    season:s => s.season(), era:s => s.era(), json:s => s.json(), timezone:s => s.timezone().name, offset:s => isoOffset$1(s), numeric:s => `${s.year()}/${zeroPad(s.month() + 1)}/${zeroPad(s.date())}`, "numeric-us":s => `${zeroPad(s.month() + 1)}/${zeroPad(s.date())}/${s.year()}`, "numeric-uk":s => `${zeroPad(s.date())}/${zeroPad(s.month() + 1)}/${s.year()}`, "mm/dd":s => `${zeroPad(s.month() + 1)}/${zeroPad(s.date())}`, iso:s => {
      let year = s.format("iso-year"), month = zeroPad(s.month() + 1), date = zeroPad(s.date()), hour = zeroPad(s.h24()), minute = zeroPad(s.minute()), second = zeroPad(s.second()), ms = zeroPad(s.millisecond(), 3);
      s = isoOffset$1(s);
      return `${year}-${month}-${date}T${hour}:${minute}:${second}.${ms}${s}`;
    }, "iso-short":s => {
      let month = zeroPad(s.month() + 1), date = zeroPad(s.date());
      s = s.year();
      0 <= s ? s = zeroPad(s, 4) : (s = Math.abs(s), s = "-" + zeroPad(s, 4));
      return `${s}-${month}-${date}`;
    }, "iso-utc":s => (new Date(s.epoch)).toISOString(), nice:s => `${shortMonths[s.month()]} ${ordinal(s.date())}, ${s.time()}`, "nice-24":s => `${shortMonths[s.month()]} ${ordinal(s.date())}, ${s.hour24()}:${zeroPad(s.minute())}`, "nice-year":s => `${shortMonths[s.month()]} ${ordinal(s.date())}, ${s.year()}`, "nice-day":s => `${shortDays[s.day()]} ${applyCaseFormat(shortMonths[s.month()])} ${ordinal(s.date())}`, "nice-full":s => `${s.dayName()} ${applyCaseFormat(s.monthName())} ${ordinal(s.date())}, ${s.time()}`, 
    "nice-full-24":s => `${s.dayName()} ${applyCaseFormat(s.monthName())} ${ordinal(s.date())}, ${s.hour24()}:${zeroPad(s.minute())}`}, aliases = {"day-name":"day", "month-name":"month", "iso 8601":"iso", "time-h24":"time-24", "time-12":"time", "time-h12":"time", tz:"timezone", "day-num":"day-number", "month-num":"month-number", "month-iso":"iso-month", "year-iso":"iso-year", "nice-short":"nice", "nice-short-24":"nice-24", mdy:"numeric-us", dmy:"numeric-uk", ymd:"numeric", "yyyy/mm/dd":"numeric", 
    "mm/dd/yyyy":"numeric-us", "dd/mm/yyyy":"numeric-us", "little-endian":"numeric-uk", "big-endian":"numeric", "day-nice":"nice-day"};
    Object.keys(aliases).forEach(k => format[k] = format[aliases[k]]);
    var format$1 = (s, str = "") => {
      if (!0 !== s.isValid()) {
        return "";
      }
      if (format.hasOwnProperty(str)) {
        let out = format[str](s) || "";
        "json" !== str && (out = String(out), "ampm" !== str.toLowerCase() && (out = applyCaseFormat(out)));
        return out;
      }
      return -1 !== str.indexOf("{") ? str = str.replace(/\{(.+?)\}/g, (_, fmt) => {
        fmt = fmt.toLowerCase().trim();
        return format.hasOwnProperty(fmt) ? (_ = String(format[fmt](s)), "ampm" !== fmt.toLowerCase() ? applyCaseFormat(_) : _) : "";
      }) : s.format("iso-short");
    };
    const mapping = {G:s => s.era(), GG:s => s.era(), GGG:s => s.era(), GGGG:s => "AD" === s.era() ? "Anno Domini" : "Before Christ", y:s => s.year(), yy:s => zeroPad(Number(String(s.year()).substr(2, 4))), yyy:s => s.year(), yyyy:s => s.year(), yyyyy:s => "0" + s.year(), Q:s => s.quarter(), QQ:s => s.quarter(), QQQ:s => s.quarter(), QQQQ:s => s.quarter(), M:s => s.month() + 1, MM:s => zeroPad(s.month() + 1), MMM:s => s.format("month-short"), MMMM:s => s.format("month"), w:s => s.week(), ww:s => 
    zeroPad(s.week()), d:s => s.date(), dd:s => zeroPad(s.date()), D:s => s.dayOfYear(), DD:s => zeroPad(s.dayOfYear()), DDD:s => zeroPad(s.dayOfYear(), 3), E:s => s.format("day-short"), EE:s => s.format("day-short"), EEE:s => s.format("day-short"), EEEE:s => s.format("day"), EEEEE:s => s.format("day")[0], e:s => s.day(), ee:s => s.day(), eee:s => s.format("day-short"), eeee:s => s.format("day"), eeeee:s => s.format("day")[0], a:s => s.ampm().toUpperCase(), aa:s => s.ampm().toUpperCase(), aaa:s => 
    s.ampm().toUpperCase(), aaaa:s => s.ampm().toUpperCase(), h:s => s.h12(), hh:s => zeroPad(s.h12()), H:s => s.hour(), HH:s => zeroPad(s.hour()), m:s => s.minute(), mm:s => zeroPad(s.minute()), s:s => s.second(), ss:s => zeroPad(s.second()), SSS:s => zeroPad(s.millisecond(), 3), A:s => s.epoch - s.startOf("day").epoch, z:s => s.timezone().name, zz:s => s.timezone().name, zzz:s => s.timezone().name, zzzz:s => s.timezone().name, Z:s => formatTimezone(s.timezone().current.offset), ZZ:s => formatTimezone(s.timezone().current.offset), 
    ZZZ:s => formatTimezone(s.timezone().current.offset), ZZZZ:s => formatTimezone(s.timezone().current.offset, ":")}, addAlias = (char, to, n) => {
      let name = char, toName = to;
      for (let i = 0; i < n; i += 1) {
        mapping[name] = mapping[toName], name += char, toName += to;
      }
    };
    addAlias("q", "Q", 4);
    addAlias("L", "M", 4);
    addAlias("Y", "y", 4);
    addAlias("c", "e", 4);
    addAlias("k", "H", 2);
    addAlias("K", "h", 2);
    addAlias("S", "s", 2);
    addAlias("v", "z", 4);
    addAlias("V", "Z", 4);
    const escapeChars = function(arr) {
      for (let i = 0; i < arr.length; i += 1) {
        if ("'" === arr[i]) {
          for (let o = i + 1; o < arr.length; o += 1) {
            arr[o] && (arr[i] += arr[o]);
            if ("'" === arr[o]) {
              arr[o] = null;
              break;
            }
            arr[o] = null;
          }
        }
      }
      return arr.filter(ch => ch);
    }, combineRepeated = function(arr) {
      for (let i = 0; i < arr.length; i += 1) {
        let c = arr[i];
        for (let o = i + 1; o < arr.length; o += 1) {
          if (arr[o] === c) {
            arr[i] += arr[o], arr[o] = null;
          } else {
            break;
          }
        }
      }
      arr = arr.filter(ch => ch);
      return arr = arr.map(str => {
        "''" === str && (str = "'");
        return str;
      });
    };
    var unixFmt$1 = (s, str) => {
      str = str.split("");
      str = escapeChars(str);
      str = combineRepeated(str);
      return str.reduce((txt, c) => {
        void 0 !== mapping[c] ? txt += mapping[c](s) || "" : (/^'.{1,}'$/.test(c) && (c = c.replace(/'/g, "")), txt += c);
        return txt;
      }, "");
    };
    const units$3 = "year season quarter month week day quarterHour hour minute".split(" "), doUnit = function(s, k) {
      let start = s.clone().startOf(k);
      k = s.clone().endOf(k).epoch - start.epoch;
      return parseFloat(((s.epoch - start.epoch) / k).toFixed(2));
    };
    var progress$1 = (s, unit) => {
      if (unit) {
        return unit = normalize$2(unit), doUnit(s, unit);
      }
      let obj = {};
      units$3.forEach(k => {
        obj[k] = doUnit(s, k);
      });
      return obj;
    };
    const climb = (a, b, unit) => {
      let i = 0;
      for (a = a.clone(); a.isBefore(b);) {
        a = a.add(1, unit), i += 1;
      }
      a.isAfter(b, unit) && --i;
      return i;
    };
    var diffOne$1 = (a, b, unit) => a.isBefore(b) ? climb(a, b, unit) : -1 * climb(b, a, unit);
    const reverseDiff = function(obj) {
      Object.keys(obj).forEach(k => {
        obj[k] *= -1;
      });
      return obj;
    };
    var toISO$1 = function(diff) {
      let iso;
      iso = "P" + ((Math.abs(diff.years) || 0) + "Y");
      iso += (Math.abs(diff.months) || 0) + "M";
      iso += (Math.abs(diff.days) || 0) + "DT";
      iso += (Math.abs(diff.hours) || 0) + "H";
      iso += (Math.abs(diff.minutes) || 0) + "M";
      return iso += (Math.abs(diff.seconds) || 0) + "S";
    };
    let units$2 = {second:"second", seconds:"seconds", minute:"minute", minutes:"minutes", hour:"hour", hours:"hours", day:"day", days:"days", month:"month", months:"months", year:"year", years:"years"}, past = "past", future = "future", present = "present", now = "now", almost = "almost", over = "over", pastDistance = value => `${value} ago`, futureDistance = value => `in ${value}`;
    const qualifiers = {months:{almost:10, over:4}, days:{almost:25, over:10}, hours:{almost:20, over:8}, minutes:{almost:50, over:20}, seconds:{almost:50, over:20}};
    var soften = function(diff) {
      let rounded = null, qualified = null, abbreviated = [], englishValues = [];
      Object.keys(diff).forEach((unit, i, units) => {
        const value = Math.abs(diff[unit]);
        if (0 !== value) {
          abbreviated.push(value + unit[0]);
          var englishValue = pluralize(value, unit);
          englishValues.push(englishValue);
          rounded || (rounded = qualified = englishValue, 4 < i || (i = units[i + 1], units = Math.abs(diff[i]), units > qualifiers[i].almost ? (rounded = pluralize(value + 1, unit), qualified = almost + " " + rounded) : units > qualifiers[i].over && (qualified = over + " " + englishValue)));
        }
      });
      return {qualified, rounded, abbreviated, englishValues};
    }, since$1 = (start, end) => {
      end = beADate(end, start);
      const diff = getDiff(start, end);
      if (!0 === Object.keys(diff).every(u => !diff[u])) {
        return {diff, rounded:now, qualified:now, precise:now, abbreviated:[], iso:"P0Y0M0DT0H0M0S", direction:present};
      }
      let precise, direction = future, {rounded, qualified, englishValues, abbreviated} = soften(diff);
      precise = englishValues.splice(0, 2).join(", ");
      !0 === start.isAfter(end) ? (rounded = pastDistance(rounded), qualified = pastDistance(qualified), precise = pastDistance(precise), direction = past) : (rounded = futureDistance(rounded), qualified = futureDistance(qualified), precise = futureDistance(precise));
      start = toISO$1(diff);
      return {diff, rounded, qualified, precise, abbreviated, iso:start, direction};
    }, seasons = {north:[["spring", 2, 1], ["summer", 5, 1], ["fall", 8, 1], ["autumn", 8, 1], ["winter", 11, 1]], south:[["fall", 2, 1], ["autumn", 2, 1], ["winter", 5, 1], ["spring", 8, 1], ["summer", 11, 1]]}, quarters = [null, [0, 1], [3, 1], [6, 1], [9, 1]];
    const units$1 = {second:s => {
      walkTo$1(s, {millisecond:0});
      return s;
    }, minute:s => {
      walkTo$1(s, {second:0, millisecond:0});
      return s;
    }, quarterhour:s => {
      let minute = s.minutes();
      s = 45 <= minute ? s.minutes(45) : 30 <= minute ? s.minutes(30) : 15 <= minute ? s.minutes(15) : s.minutes(0);
      walkTo$1(s, {second:0, millisecond:0});
      return s;
    }, hour:s => {
      walkTo$1(s, {minute:0, second:0, millisecond:0});
      return s;
    }, day:s => {
      walkTo$1(s, {hour:0, minute:0, second:0, millisecond:0});
      return s;
    }, week:s => {
      let original = s.clone();
      s = s.day(s._weekStart);
      s.isAfter(original) && (s = s.subtract(1, "week"));
      walkTo$1(s, {hour:0, minute:0, second:0, millisecond:0});
      return s;
    }, month:s => {
      walkTo$1(s, {date:1, hour:0, minute:0, second:0, millisecond:0});
      return s;
    }, quarter:s => {
      let q = s.quarter();
      quarters[q] && walkTo$1(s, {month:quarters[q][0], date:quarters[q][1], hour:0, minute:0, second:0, millisecond:0});
      return s;
    }, season:s => {
      let current = s.season(), hem = "north";
      "South" === s.hemisphere() && (hem = "south");
      for (let i = 0; i < seasons[hem].length; i++) {
        if (seasons[hem][i][0] === current) {
          let year = s.year();
          "winter" === current && 3 > s.month() && --year;
          walkTo$1(s, {year, month:seasons[hem][i][1], date:seasons[hem][i][2], hour:0, minute:0, second:0, millisecond:0});
          break;
        }
      }
      return s;
    }, year:s => {
      walkTo$1(s, {month:0, date:1, hour:0, minute:0, second:0, millisecond:0});
      return s;
    }, decade:s => {
      s = s.startOf("year");
      var year = s.year();
      year = 10 * parseInt(year / 10, 10);
      return s = s.year(year);
    }, century:s => {
      s = s.startOf("year");
      var year = s.year();
      year = 100 * parseInt(year / 100, 10);
      return s = s.year(year);
    }};
    units$1.date = units$1.day;
    const isDay = function(unit) {
      return shortDays.find(s => s === unit) || longDays.find(s => s === unit) ? !0 : !1;
    }, titleCase = str => {
      str = str[0].toUpperCase() + str.substr(1);
      str = str.replace(/[\/_-]([a-z])/gi, s => s.toUpperCase());
      str = str.replace(/_(of|es)_/i, s => s.toLowerCase());
      str = str.replace(/\/gmt/i, "/GMT");
      str = str.replace(/\/Dumontdurville$/i, "/DumontDUrville");
      str = str.replace(/\/Mcmurdo$/i, "/McMurdo");
      return str = str.replace(/\/Port-au-prince$/i, "/Port-au-Prince");
    };
    var timezone$1 = s => {
      var zones = s.timezones, tz = s.tz;
      !1 === zones.hasOwnProperty(tz) && (tz = findTz(s.tz, zones));
      if (null === tz) {
        return !1 === s.silent && console.warn("Warn: could not find given or local timezone - '" + s.tz + "'"), {current:{epochShift:0}};
      }
      zones = zones[tz];
      tz = {name:titleCase(tz), hasDst:!!zones.dst, default_offset:zones.offset, hemisphere:"s" === zones.hem ? "South" : "North", current:{}};
      if (tz.hasDst) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = zones.dst) ? JSCompiler_inline_result.split("-\x3e") : [];
        tz.change = {start:JSCompiler_inline_result[0], back:JSCompiler_inline_result[1]};
      }
      let winter = JSCompiler_inline_result = zones.offset;
      !0 === tz.hasDst && (winter = "North" === tz.hemisphere ? JSCompiler_inline_result - 1 : zones.offset + 1);
      !1 === tz.hasDst ? (tz.current.offset = JSCompiler_inline_result, tz.current.isDST = !1) : !0 === inSummerTime$1(s.epoch, tz.change.start, tz.change.back, JSCompiler_inline_result, winter) ? (tz.current.offset = JSCompiler_inline_result, tz.current.isDST = "North" === tz.hemisphere) : (tz.current.offset = winter, tz.current.isDST = "South" === tz.hemisphere);
      return tz;
    };
    const units = "century decade year month date day hour minute second millisecond".split(" "), methods$4 = {set:function(input, tz) {
      let s = this.clone();
      s = handleInput(s, input);
      tz && (this.tz = findTz(tz));
      return s;
    }, timezone:function() {
      return timezone$1(this);
    }, isDST:function() {
      return timezone$1(this).current.isDST;
    }, hasDST:function() {
      return timezone$1(this).hasDst;
    }, offset:function() {
      return 60 * timezone$1(this).current.offset;
    }, hemisphere:function() {
      return timezone$1(this).hemisphere;
    }, format:function(fmt) {
      return format$1(this, fmt);
    }, unixFmt:function(fmt) {
      return unixFmt$1(this, fmt);
    }, startOf:function(unit) {
      {
        let s = this.clone();
        unit = normalize$2(unit);
        units$1[unit] ? unit = units$1[unit](s) : "summer" === unit || "winter" === unit ? (s = s.season(unit), unit = units$1.season(s)) : unit = s;
      }
      return unit;
    }, endOf:function(unit) {
      {
        let s = this.clone();
        unit = normalize$2(unit);
        units$1[unit] && (s = units$1[unit](s), s = s.add(1, unit), s = s.subtract(1, "millisecond"));
        unit = s;
      }
      return unit;
    }, leapYear:function() {
      let year = this.year();
      return isLeapYear(year);
    }, progress:function(unit) {
      return progress$1(this, unit);
    }, nearest:function(unit) {
      var s = this;
      let prog = s.progress();
      unit = normalize$2(unit);
      "quarterhour" === unit && (unit = "quarterHour");
      void 0 !== prog[unit] ? (0.5 < prog[unit] && (s = s.add(1, unit)), s = s.startOf(unit)) : !1 === s.silent && console.warn("no known unit '" + unit + "'");
      return s;
    }, diff:function(d, unit) {
      {
        var a = this;
        var b = beADate(d, a);
        d = !1;
        a.isAfter(b) && (d = a, a = b, b = d, d = !0);
        var msDiff = b.epoch - a.epoch;
        msDiff = {milliseconds:msDiff, seconds:parseInt(msDiff / 1000, 10)};
        msDiff.minutes = parseInt(msDiff.seconds / 60, 10);
        msDiff.hours = parseInt(msDiff.minutes / 60, 10);
        var tmp = a.clone();
        let years = b.year() - tmp.year();
        tmp = tmp.year(b.year());
        tmp.isAfter(b) && --years;
        msDiff.years = years;
        a.add(msDiff.years, "year");
        msDiff.months = 12 * msDiff.years;
        tmp = a.add(msDiff.months, "month");
        msDiff.months += diffOne$1(tmp, b, "month");
        msDiff.quarters = 4 * msDiff.years;
        msDiff.quarters += parseInt(msDiff.months % 12 / 3, 10);
        msDiff.weeks = 52 * msDiff.years;
        tmp = a.add(msDiff.weeks, "week");
        msDiff.weeks += diffOne$1(tmp, b, "week");
        msDiff.days = 7 * msDiff.weeks;
        tmp = a.add(msDiff.days, "day");
        msDiff.days += diffOne$1(tmp, b, "day");
        a = msDiff;
        d && (a = reverseDiff(a));
        unit ? (unit = normalize$2(unit), !0 !== /s$/.test(unit) && (unit += "s"), "dates" === unit && (unit = "days"), unit = a[unit]) : unit = a;
      }
      return unit;
    }, since:function(d) {
      d || (d = this.clone().set());
      return since$1(this, d);
    }, next:function(unit) {
      return this.add(1, unit).startOf(unit);
    }, last:function(unit) {
      return this.subtract(1, unit).startOf(unit);
    }, isValid:function() {
      return this.epoch || 0 === this.epoch ? !isNaN(this.d.getTime()) : !1;
    }, goto:function(tz) {
      let s = this.clone();
      s.tz = findTz(tz, s.timezones);
      return s;
    }, every:function(unit, to) {
      if ("object" === typeof unit && "string" === typeof to) {
        var tmp = to;
        to = unit;
        unit = tmp;
      }
      tmp = this;
      if (unit && to) {
        unit = normalize$2(unit);
        to = tmp.clone().set(to);
        if (tmp.isAfter(to)) {
          var tmp$jscomp$0 = tmp;
          tmp = to;
          to = tmp$jscomp$0;
        }
        tmp$jscomp$0 = tmp.clone();
        isDay(unit) ? (tmp$jscomp$0 = tmp$jscomp$0.next(unit), unit = "week") : tmp$jscomp$0.startOf(unit).isBefore(tmp) && (tmp$jscomp$0 = tmp$jscomp$0.next(unit));
        for (tmp = []; tmp$jscomp$0.isBefore(to);) {
          tmp.push(tmp$jscomp$0), tmp$jscomp$0 = tmp$jscomp$0.add(1, unit);
        }
      } else {
        tmp = [];
      }
      return tmp;
    }, isAwake:function() {
      let hour = this.hour();
      return 8 > hour || 22 < hour ? !1 : !0;
    }, isAsleep:function() {
      return !this.isAwake();
    }, daysInMonth:function() {
      switch(this.month()) {
        case 0:
          return 31;
        case 1:
          return this.leapYear() ? 29 : 28;
        case 2:
          return 31;
        case 3:
          return 30;
        case 4:
          return 31;
        case 5:
          return 30;
        case 6:
          return 31;
        case 7:
          return 31;
        case 8:
          return 30;
        case 9:
          return 31;
        case 10:
          return 30;
        case 11:
          return 31;
        default:
          throw Error("Invalid Month state.");
      }
    }, log:function() {
      console.log("");
      console.log(format$1(this, "nice-short"));
      return this;
    }, logYear:function() {
      console.log("");
      console.log(format$1(this, "full-short"));
      return this;
    }, json:function() {
      return units.reduce((h, unit) => {
        h[unit] = this[unit]();
        return h;
      }, {});
    }, debug:function() {
      let tz = this.timezone(), date = this.format("MM") + " " + this.format("date-ordinal") + " " + this.year();
      date += "\n     - " + this.format("time");
      console.log("\n\n", date + "\n     - " + tz.name + " (" + tz.current.offset + ")");
      return this;
    }, from:function(d) {
      d = this.clone().set(d);
      return d.since(this);
    }, fromNow:function() {
      return this.clone().set(Date.now()).since(this);
    }, weekStart:function(input) {
      if ("number" === typeof input) {
        return this._weekStart = input, this;
      }
      if ("string" === typeof input) {
        input = input.toLowerCase().trim();
        let num = shortDays.indexOf(input);
        -1 === num && (num = longDays.indexOf(input));
        -1 === num && (num = 1);
        this._weekStart = num;
      } else {
        console.warn("Spacetime Error: Cannot understand .weekStart() input:", input);
      }
      return this;
    }};
    methods$4.inDST = methods$4.isDST;
    methods$4.round = methods$4.nearest;
    methods$4.each = methods$4.every;
    const validate = n => {
      "string" === typeof n && (n = parseInt(n, 10));
      return n;
    }, order$1 = "year month date hour minute second millisecond".split(" "), confirm = (s, tmp, unit) => {
      unit = order$1.indexOf(unit);
      unit = order$1.slice(unit, order$1.length);
      for (let i = 0; i < unit.length; i++) {
        let want = tmp[unit[i]]();
        s[unit[i]](want);
      }
      return s;
    }, fwdBkwd = function(s, old, goFwd, unit) {
      !0 === goFwd && s.isBefore(old) ? s = s.add(1, unit) : !1 === goFwd && s.isAfter(old) && (s = s.minus(1, unit));
      return s;
    }, minutes = function(s, n, goFwd) {
      n = validate(n);
      let old = s.clone();
      n = (s.minute() - n) * o.minute;
      s.epoch -= n;
      confirm(s, old, "second");
      s = fwdBkwd(s, old, goFwd, "hour");
      return s.epoch;
    }, hours = function(s, n, goFwd) {
      n = validate(n);
      24 <= n ? n = 24 : 0 > n && (n = 0);
      let old = s.clone(), diff = s.hour() - n, shift = diff * o.hour;
      s.epoch -= shift;
      s.date() !== old.date() && (s = old.clone(), 1 < diff && --diff, 1 > diff && (diff += 1), shift = diff * o.hour, s.epoch -= shift);
      walkTo$1(s, {hour:n});
      confirm(s, old, "minute");
      s = fwdBkwd(s, old, goFwd, "day");
      return s.epoch;
    }, year = function(s, n) {
      "string" === typeof n && /^'[0-9]{2}$/.test(n) && (n = n.replace(/'/, "").trim(), n = Number(n), n = 30 < n ? 1900 + n : 2000 + n);
      n = validate(n);
      walkTo$1(s, {year:n});
      return s.epoch;
    };
    let morning = "am", evening = "pm";
    const clearMinutes = s => {
      s = s.minute(0);
      s = s.second(0);
      return s = s.millisecond(1);
    }, methods = Object.assign({}, {millisecond:function(num) {
      if (void 0 !== num) {
        let s = this.clone();
        var s$jscomp$0 = s;
        num = validate(num);
        let current = s$jscomp$0.millisecond();
        s.epoch = s$jscomp$0.epoch - (current - num);
        return s;
      }
      return this.d.getMilliseconds();
    }, second:function(num, goFwd) {
      if (void 0 !== num) {
        let s = this.clone();
        var s$jscomp$0 = s;
        var n = validate(num);
        num = s$jscomp$0.clone();
        n = (s$jscomp$0.second() - n) * o.second;
        s$jscomp$0.epoch -= n;
        s$jscomp$0 = fwdBkwd(s$jscomp$0, num, goFwd, "minute");
        s.epoch = s$jscomp$0.epoch;
        return s;
      }
      return this.d.getSeconds();
    }, minute:function(num, goFwd) {
      if (void 0 !== num) {
        let s = this.clone();
        s.epoch = minutes(s, num, goFwd);
        return s;
      }
      return this.d.getMinutes();
    }, hour:function(num, goFwd) {
      var d = this.d;
      return void 0 !== num ? (d = this.clone(), d.epoch = hours(d, num, goFwd), d) : d.getHours();
    }, hourFloat:function(num, goFwd) {
      if (void 0 !== num) {
        var s = this.clone();
        let minute;
        minute = num % 1 * 60;
        num = parseInt(num, 10);
        s.epoch = hours(s, num, goFwd);
        s.epoch = minutes(s, minute, goFwd);
        return s;
      }
      s = this.d;
      goFwd = s.getHours();
      s = s.getMinutes();
      return goFwd + s / 60;
    }, hour12:function(str, goFwd) {
      var d = this.d;
      if (void 0 !== str) {
        d = this.clone();
        if (str = ("" + str).match(/^([0-9]+)(am|pm)$/)) {
          let hour = parseInt(str[1], 10);
          "pm" === str[2] && (hour += 12);
          d.epoch = hours(d, hour, goFwd);
        }
        return d;
      }
      goFwd = d.getHours();
      12 < goFwd && (goFwd -= 12);
      0 === goFwd && (goFwd = 12);
      return goFwd;
    }, time:function(str, goFwd) {
      if (void 0 !== str) {
        let s = this.clone();
        str = str.toLowerCase().trim();
        a: {
          var s$jscomp$0 = s, m = str.match(/([0-9]{1,2})[:h]([0-9]{1,2})(:[0-9]{1,2})? ?(am|pm)?/);
          if (!m) {
            m = str.match(/([0-9]{1,2}) ?(am|pm)/);
            if (!m) {
              goFwd = s$jscomp$0.epoch;
              break a;
            }
            m.splice(2, 0, "0");
            m.splice(3, 0, "");
          }
          var h24 = !1;
          str = parseInt(m[1], 10);
          let minute = parseInt(m[2], 10);
          60 <= minute && (minute = 59);
          12 < str && (h24 = !0);
          !1 === h24 && ("am" === m[4] && 12 === str && (str = 0), "pm" === m[4] && 12 > str && (str += 12));
          m[3] = m[3] || "";
          m[3] = m[3].replace(/:/, "");
          m = parseInt(m[3], 10) || 0;
          h24 = s$jscomp$0.clone();
          s$jscomp$0 = s$jscomp$0.hour(str);
          s$jscomp$0 = s$jscomp$0.minute(minute);
          s$jscomp$0 = s$jscomp$0.second(m);
          s$jscomp$0 = s$jscomp$0.millisecond(0);
          s$jscomp$0 = fwdBkwd(s$jscomp$0, h24, goFwd, "day");
          goFwd = s$jscomp$0.epoch;
        }
        s.epoch = goFwd;
        return s;
      }
      return `${this.h12()}:${zeroPad(this.minute())}${this.ampm()}`;
    }, ampm:function(input, goFwd) {
      var which = morning;
      let hour = this.hour();
      12 <= hour && (which = evening);
      if ("string" !== typeof input) {
        return which;
      }
      which = this.clone();
      input = input.toLowerCase().trim();
      return 12 <= hour && "am" === input ? which.hour(hour - 12, goFwd) : 12 > hour && "pm" === input ? which.hour(hour + 12, goFwd) : which;
    }, dayTime:function(str, goFwd) {
      if (void 0 !== str) {
        const times = {morning:"7:00", breakfast:"7:00", noon:"12:00", lunch:"12:00", afternoon:"14:00", evening:"18:00", dinner:"18:00", night:"23:00", midnight:"00:00"};
        let s = this.clone();
        str = (str || "").toLowerCase();
        !0 === times.hasOwnProperty(str) && (s = s.time(times[str], goFwd));
        return s;
      }
      str = this.hour();
      return 6 > str ? "night" : 12 > str ? "morning" : 17 > str ? "afternoon" : 22 > str ? "evening" : "night";
    }, iso:function(num) {
      return void 0 !== num ? this.set(num) : this.format("iso");
    }}, {date:function(num, goFwd) {
      if (void 0 !== num) {
        let s = this.clone();
        if (num = parseInt(num, 10)) {
          var s$jscomp$0 = s;
          num = validate(num);
          if (28 < num) {
            var month = s$jscomp$0.month();
            let max = monthLength[month];
            1 === month && 29 === num && isLeapYear(s$jscomp$0.year()) && (max = 29);
            num > max && (num = max);
          }
          0 >= num && (num = 1);
          month = s$jscomp$0.clone();
          walkTo$1(s$jscomp$0, {date:num});
          s$jscomp$0 = fwdBkwd(s$jscomp$0, month, goFwd, "month");
          s.epoch = s$jscomp$0.epoch;
        }
        return s;
      }
      return this.d.getDate();
    }, day:function(input, goFwd) {
      if (void 0 === input) {
        return this.d.getDay();
      }
      let original = this.clone(), want = input;
      "string" === typeof input && (input = input.toLowerCase(), aliases$1.hasOwnProperty(input) ? want = aliases$1[input] : (want = shortDays.indexOf(input), -1 === want && (want = longDays.indexOf(input))));
      input = this.d.getDay() - want;
      !0 === goFwd && 0 < input && (input -= 7);
      !1 === goFwd && 0 > input && (input += 7);
      goFwd = this.subtract(input, "days");
      walkTo$1(goFwd, {hour:original.hour(), minute:original.minute(), second:original.second()});
      return goFwd;
    }, dayName:function(input, goFwd) {
      if (void 0 === input) {
        return longDays[this.day()];
      }
      let s = this.clone();
      return s = s.day(input, goFwd);
    }}, {dayOfYear:function(num, goFwd) {
      if (void 0 !== num) {
        var s = this.clone(), s$jscomp$0 = s;
        num = validate(num);
        let old = s$jscomp$0.clone();
        --num;
        0 >= num ? num = 0 : 365 <= num && (num = isLeapYear(s$jscomp$0.year()) ? 365 : 364);
        s$jscomp$0 = s$jscomp$0.startOf("year");
        s$jscomp$0 = s$jscomp$0.add(num, "day");
        confirm(s$jscomp$0, old, "hour");
        s$jscomp$0 = fwdBkwd(s$jscomp$0, old, goFwd, "year");
        s.epoch = s$jscomp$0.epoch;
        return s;
      }
      goFwd = 0;
      s$jscomp$0 = this.d.getMonth();
      for (num = 1; num <= s$jscomp$0; num++) {
        s = new Date(), s.setDate(1), s.setFullYear(this.d.getFullYear()), s.setHours(1), s.setMinutes(1), s.setMonth(num), s.setHours(-2), goFwd += s.getDate();
      }
      return goFwd + this.d.getDate();
    }, week:function(num, goFwd) {
      if (void 0 !== num) {
        var s = this.clone(), JSCompiler_temp_const = s, s$jscomp$0 = this;
        let old = s$jscomp$0.clone();
        num = validate(num);
        s$jscomp$0 = s$jscomp$0.month(0);
        s$jscomp$0 = s$jscomp$0.date(1);
        s$jscomp$0 = s$jscomp$0.day("monday");
        "december" === s$jscomp$0.monthName() && 28 <= s$jscomp$0.date() && (s$jscomp$0 = s$jscomp$0.add(1, "week"));
        s$jscomp$0 = s$jscomp$0.add(num - 1, "weeks");
        s$jscomp$0 = fwdBkwd(s$jscomp$0, old, goFwd, "year");
        JSCompiler_temp_const.epoch = s$jscomp$0.epoch;
        return s = clearMinutes(s);
      }
      goFwd = this.clone();
      goFwd = goFwd.month(0);
      goFwd = goFwd.date(1);
      goFwd = clearMinutes(goFwd);
      goFwd = goFwd.day("monday");
      11 === goFwd.month() && 25 <= goFwd.date() && (goFwd = goFwd.add(1, "week"));
      JSCompiler_temp_const = 1;
      1 === goFwd.date() && (JSCompiler_temp_const = 0);
      goFwd = goFwd.minus(1, "second");
      s$jscomp$0 = this.epoch;
      if (goFwd.epoch > s$jscomp$0) {
        return 1;
      }
      s = 0;
      num = 4 * this.month();
      goFwd.epoch += o.week * num;
      for (s += num; 52 >= s; s++) {
        if (goFwd.epoch > s$jscomp$0) {
          return s + JSCompiler_temp_const;
        }
        goFwd = goFwd.add(1, "week");
      }
      return 52;
    }, month:function(input, goFwd) {
      if (void 0 !== input) {
        let s = this.clone();
        var s$jscomp$0 = s;
        "string" === typeof input && ("sept" === input && (input = "sep"), input = buildMapping()[input.toLowerCase()]);
        input = validate(input);
        12 <= input && (input = 11);
        0 >= input && (input = 0);
        let d = s$jscomp$0.date();
        d > monthLength[input] && (d = monthLength[input]);
        let old = s$jscomp$0.clone();
        walkTo$1(s$jscomp$0, {month:input, d});
        s$jscomp$0 = fwdBkwd(s$jscomp$0, old, goFwd, "year");
        s.epoch = s$jscomp$0.epoch;
        return s;
      }
      return this.d.getMonth();
    }, monthName:function(input, goFwd) {
      if (void 0 !== input) {
        let s = this.clone();
        return s = s.month(input, goFwd);
      }
      return longMonths[this.month()];
    }, quarter:function(num, goFwd) {
      if (void 0 !== num && ("string" === typeof num && (num = num.replace(/^q/i, ""), num = parseInt(num, 10)), quarters[num])) {
        let s = this.clone();
        s = s.month(quarters[num][0], goFwd);
        s = s.date(1, goFwd);
        return s = s.startOf("day");
      }
      num = this.d.getMonth();
      for (goFwd = 1; goFwd < quarters.length; goFwd++) {
        if (num < quarters[goFwd][0]) {
          return goFwd - 1;
        }
      }
      return 4;
    }, season:function(input, goFwd) {
      let hem = "north";
      "South" === this.hemisphere() && (hem = "south");
      if (void 0 !== input) {
        let s = this.clone();
        for (let i = 0; i < seasons[hem].length; i++) {
          input === seasons[hem][i][0] && (s = s.month(seasons[hem][i][1], goFwd), s = s.date(1), s = s.startOf("day"));
        }
        return s;
      }
      input = this.d.getMonth();
      for (goFwd = 0; goFwd < seasons[hem].length - 1; goFwd++) {
        if (input >= seasons[hem][goFwd][1] && input < seasons[hem][goFwd + 1][1]) {
          return seasons[hem][goFwd][0];
        }
      }
      return "north" === hem ? "winter" : "summer";
    }, year:function(num) {
      if (void 0 !== num) {
        let s = this.clone();
        s.epoch = year(s, num);
        return s;
      }
      return this.d.getFullYear();
    }, era:function(str) {
      if (void 0 !== str) {
        let s = this.clone();
        str = str.toLowerCase();
        let year$1 = s.d.getFullYear();
        "bc" === str && 0 < year$1 && (s.epoch = year(s, -1 * year$1));
        "ad" === str && 0 > year$1 && (s.epoch = year(s, -1 * year$1));
        return s;
      }
      return 0 > this.d.getFullYear() ? "BC" : "AD";
    }, decade:function(input) {
      if (void 0 !== input) {
        input = String(input);
        input = input.replace(/([0-9])'?s$/, "$1");
        input = input.replace(/([0-9])(th|rd|st|nd)/, "$1");
        if (!input) {
          return console.warn("Spacetime: Invalid decade input"), this;
        }
        2 === input.length && /[0-9][0-9]/.test(input) && (input = "19" + input);
        input = Number(input);
        if (isNaN(input)) {
          return this;
        }
        input = 10 * Math.floor(input / 10);
        return this.year(input);
      }
      return this.startOf("decade").year();
    }, century:function(input) {
      if (void 0 !== input) {
        "string" === typeof input && (input = input.replace(/([0-9])(th|rd|st|nd)/, "$1"), input = input.replace(/([0-9]+) ?(b\.?c\.?|a\.?d\.?)/i, (a, b, c) => {
          c.match(/b\.?c\.?/i) && (b = "-" + b);
          return b;
        }), input = input.replace(/c$/, ""));
        let year = Number(input);
        if (isNaN(input)) {
          return console.warn("Spacetime: Invalid century input"), this;
        }
        0 === year && (year = 1);
        return this.year(0 <= year ? 100 * (year - 1) : 100 * (year + 1));
      }
      input = this.startOf("century").year();
      input = Math.floor(input / 100);
      return 0 > input ? input - 1 : input + 1;
    }, millenium:function(input) {
      if (void 0 !== input) {
        if ("string" === typeof input && (input = input.replace(/([0-9])(th|rd|st|nd)/, "$1"), input = Number(input), isNaN(input))) {
          return console.warn("Spacetime: Invalid millenium input"), this;
        }
        0 < input && --input;
        input *= 1000;
        0 === input && (input = 1);
        return this.year(input);
      }
      input = Math.floor(this.year() / 1000);
      0 <= input && (input += 1);
      return input;
    }});
    methods.milliseconds = methods.millisecond;
    methods.seconds = methods.second;
    methods.minutes = methods.minute;
    methods.hours = methods.hour;
    methods.hour24 = methods.hour;
    methods.h12 = methods.hour12;
    methods.h24 = methods.hour24;
    methods.days = methods.day;
    const getMonthLength = function(month, year) {
      return 1 === month && isLeapYear(year) ? 29 : monthLength[month];
    }, months = (want, old) => {
      if (0 < want.month) {
        var years$jscomp$0 = parseInt(want.month / 12, 10);
        want.year = old.year() + years$jscomp$0;
        want.month %= 12;
      } else if (0 > want.month) {
        years$jscomp$0 = Math.abs(want.month);
        let years = parseInt(years$jscomp$0 / 12, 10);
        0 !== years$jscomp$0 % 12 && (years += 1);
        want.year = old.year() - years;
        want.month %= 12;
        want.month += 12;
        12 === want.month && (want.month = 0);
      }
      return want;
    }, days = (want, old, sum) => {
      let year = old.year();
      old = old.month();
      let max = getMonthLength(old, year);
      for (; sum > max;) {
        sum -= max, old += 1, 12 <= old && (old -= 12, year += 1), max = getMonthLength(old, year);
      }
      want.month = old;
      want.date = sum;
      return want;
    }, daysBack = (want, old, sum) => {
      want.year = old.year();
      want.month = old.month();
      old = old.date();
      for (want.date = old - Math.abs(sum); 1 > want.date;) {
        --want.month, 0 > want.month && (want.month = 11, --want.year), sum = getMonthLength(want.month, want.year), want.date += sum;
      }
      return want;
    }, order = "millisecond second minute hour date month".split(" ");
    let keep = {second:order.slice(0, 1), minute:order.slice(0, 2), quarterhour:order.slice(0, 2), hour:order.slice(0, 3), date:order.slice(0, 4), month:order.slice(0, 4), quarter:order.slice(0, 4), season:order.slice(0, 4), year:order, decade:order, century:order};
    keep.week = keep.hour;
    keep.season = keep.date;
    keep.quarter = keep.date;
    const dstAwareUnits = {year:!0, quarter:!0, season:!0, month:!0, week:!0, date:!0}, keepDate = {month:!0, quarter:!0, season:!0, year:!0}, print = {millisecond:s => s.epoch, second:s => [s.year(), s.month(), s.date(), s.hour(), s.minute(), s.second()].join("-"), minute:s => [s.year(), s.month(), s.date(), s.hour(), s.minute()].join("-"), hour:s => [s.year(), s.month(), s.date(), s.hour()].join("-"), day:s => [s.year(), s.month(), s.date()].join("-"), week:s => [s.year(), s.week()].join("-"), 
    month:s => [s.year(), s.month()].join("-"), quarter:s => [s.year(), s.quarter()].join("-"), year:s => s.year()};
    print.date = print.day;
    let timezones = all;
    const SpaceTime = function(input, tz, options = {}) {
      this.epoch = null;
      this.tz = findTz(tz, timezones);
      this.silent = "undefined" !== typeof options.silent ? options.silent : !0;
      this.british = options.dmy || options.british;
      this._weekStart = 1;
      void 0 !== options.weekStart && (this._weekStart = options.weekStart);
      this._today = {};
      void 0 !== options.today && (this._today = options.today);
      Object.defineProperty(this, "d", {get:function() {
        var obj = this.timezones[this.tz];
        if (void 0 === obj) {
          console.warn("Warning: couldn't find timezone " + this.tz);
          var JSCompiler_inline_result = 0;
        } else {
          if (void 0 === obj.dst) {
            JSCompiler_inline_result = obj.offset;
          } else {
            JSCompiler_inline_result = obj.offset;
            var dec = obj.offset + 1;
            "n" === obj.hem && (dec = JSCompiler_inline_result - 1);
            obj = obj.dst.split("-\x3e");
            JSCompiler_inline_result = !0 === inSummerTime$1(this.epoch, obj[0], obj[1], JSCompiler_inline_result, dec) ? JSCompiler_inline_result : dec;
          }
        }
        JSCompiler_inline_result = 6E4 * (((new Date(this.epoch)).getTimezoneOffset() || 0) + 60 * JSCompiler_inline_result);
        return new Date(this.epoch + JSCompiler_inline_result);
      }});
      Object.defineProperty(this, "timezones", {get:() => timezones, set:obj => timezones = obj});
      input = handleInput(this, input);
      this.epoch = input.epoch;
      input.tz && (this.tz = input.tz);
    };
    Object.keys(methods$4).forEach(k => {
      SpaceTime.prototype[k] = methods$4[k];
    });
    SpaceTime.prototype.clone = function() {
      return new SpaceTime(this.epoch, this.tz, {silent:this.silent, weekStart:this._weekStart, today:this._today, parsers:this.parsers});
    };
    SpaceTime.prototype.toLocalDate = function() {
      return this.toNativeDate();
    };
    SpaceTime.prototype.toNativeDate = function() {
      return new Date(this.epoch);
    };
    (Space => {
      Object.keys(methods).forEach(k => {
        Space.prototype[k] = methods[k];
      });
    })(SpaceTime);
    (SpaceTime => {
      SpaceTime.prototype.add = function(num, unit) {
        let s = this.clone();
        if (!unit || 0 === num) {
          return s;
        }
        let old = this.clone();
        unit = normalize$2(unit);
        if ("millisecond" === unit) {
          return s.epoch += num, s;
        }
        "fortnight" === unit && (num *= 2, unit = "week");
        o[unit] ? s.epoch += o[unit] * num : "week" === unit || "weekend" === unit ? s.epoch += 7 * o.day * num : "quarter" === unit || "season" === unit ? s.epoch += 3 * o.month * num : "quarterhour" === unit && (s.epoch += 15 * o.minute * num);
        let want = {};
        keep[unit] && keep[unit].forEach(u => {
          want[u] = old[u]();
        });
        if (dstAwareUnits[unit]) {
          var diff = old.timezone().current.offset - s.timezone().current.offset;
          s.epoch += 36E5 * diff;
        }
        "month" === unit && (want.month = old.month() + num, want = months(want, old));
        "week" === unit && (diff = old.date() + 7 * num, 28 >= diff && 1 < diff && (want.date = diff));
        if ("weekend" === unit && "saturday" !== s.dayName()) {
          s = s.day("saturday", !0);
        } else if ("date" === unit) {
          0 > num ? want = daysBack(want, old, num) : (diff = old.date() + num, want = days(want, old, diff)), 0 !== num && old.isSame(s, "day") && (want.date = old.date() + num);
        } else if ("quarter" === unit) {
          want.month = old.month() + 3 * num, want.year = old.year(), 0 > want.month ? (num = Math.floor(want.month / 12), want.month += 12 * Math.abs(num), want.year += num) : 12 <= want.month && (num = Math.floor(want.month / 12), want.month %= 12, want.year += num), want.date = old.date();
        } else if ("year" === unit) {
          diff = old.year() + num;
          let haveYear = s.year();
          haveYear < diff ? s.epoch += Math.abs(o.day * (Math.floor(num / 4) || 1)) : haveYear > diff && (s.epoch += o.day * (Math.floor(num / 4) || 1));
        } else {
          "decade" === unit ? want.year = s.year() + 10 : "century" === unit && (want.year = s.year() + 100);
        }
        keepDate[unit] && (unit = monthLength[want.month], want.date = old.date(), want.date > unit && (want.date = unit));
        1 < Object.keys(want).length && walkTo$1(s, want);
        return s;
      };
      SpaceTime.prototype.subtract = function(num, unit) {
        return this.clone().add(-1 * num, unit);
      };
      SpaceTime.prototype.minus = SpaceTime.prototype.subtract;
      SpaceTime.prototype.plus = SpaceTime.prototype.add;
    })(SpaceTime);
    (SpaceTime => {
      SpaceTime.prototype.isSame = function(b, unit, tzAware = !0) {
        if (!unit) {
          return null;
        }
        if ("string" === typeof b && "object" === typeof unit) {
          let tmp = b;
          b = unit;
          unit = tmp;
        }
        if ("string" === typeof b || "number" === typeof b) {
          b = new SpaceTime(b, this.timezone.name);
        }
        unit = unit.replace(/s$/, "");
        !0 === tzAware && this.tz !== b.tz && (b = b.clone(), b.tz = this.tz);
        return print[unit] ? print[unit](this) === print[unit](b) : null;
      };
    })(SpaceTime);
    (SpaceTime => {
      const methods = {isAfter:function(d) {
        d = beADate(d, this);
        d = getEpoch(d);
        return null === d ? null : this.epoch > d;
      }, isBefore:function(d) {
        d = beADate(d, this);
        d = getEpoch(d);
        return null === d ? null : this.epoch < d;
      }, isEqual:function(d) {
        d = beADate(d, this);
        d = getEpoch(d);
        return null === d ? null : this.epoch === d;
      }, isBetween:function(start, end, isInclusive = !1) {
        start = beADate(start, this);
        end = beADate(end, this);
        let startEpoch = getEpoch(start);
        if (null === startEpoch) {
          return null;
        }
        let endEpoch = getEpoch(end);
        return null === endEpoch ? null : isInclusive ? this.isBetween(start, end) || this.isEqual(start) || this.isEqual(end) : startEpoch < this.epoch && this.epoch < endEpoch;
      }};
      Object.keys(methods).forEach(k => {
        SpaceTime.prototype[k] = methods[k];
      });
    })(SpaceTime);
    (SpaceTime => {
      const methods = {i18n:function(data) {
        if (isObject(data.days)) {
          var i18n = data.days;
          shortDays = i18n.short || shortDays;
          longDays = i18n.long || longDays;
        }
        isObject(data.months) && (i18n = data.months, shortMonths = i18n.short || shortMonths, longMonths = i18n.long || longMonths);
        "[object Boolean]" === Object.prototype.toString.call(data.useTitleCase) && (titleCaseEnabled = data.useTitleCase);
        isObject(data.ampm) && (i18n = data.ampm, morning = i18n.am || morning, evening = i18n.pm || evening);
        isObject(data.distance) && (i18n = data.distance, pastDistance = i18n.pastDistance || pastDistance, futureDistance = i18n.futureDistance || futureDistance, past = i18n.past || past, future = i18n.future || future, present = i18n.present || present, now = i18n.now || now, almost = i18n.almost || almost, over = i18n.over || over);
        isObject(data.units) && set$2(data.units);
        return this;
      }};
      Object.keys(methods).forEach(k => {
        SpaceTime.prototype[k] = methods[k];
      });
    })(SpaceTime);
    const main = (input, tz, options) => new SpaceTime(input, tz, options), setToday = function(s) {
      let today = s._today || {};
      Object.keys(today).forEach(k => {
        s = s[k](today[k]);
      });
      return s;
    };
    main.now = (tz, options) => {
      tz = new SpaceTime((new Date()).getTime(), tz, options);
      return tz = setToday(tz);
    };
    main.today = (tz, options) => {
      tz = new SpaceTime((new Date()).getTime(), tz, options);
      tz = setToday(tz);
      return tz.startOf("day");
    };
    main.tomorrow = (tz, options) => {
      tz = new SpaceTime((new Date()).getTime(), tz, options);
      tz = setToday(tz);
      return tz.add(1, "day").startOf("day");
    };
    main.yesterday = (tz, options) => {
      tz = new SpaceTime((new Date()).getTime(), tz, options);
      tz = setToday(tz);
      return tz.subtract(1, "day").startOf("day");
    };
    main.extend = function(obj = {}) {
      Object.keys(obj).forEach(k => {
        SpaceTime.prototype[k] = obj[k];
      });
      return this;
    };
    main.timezones = function() {
      return (new SpaceTime()).timezones;
    };
    main.max = function(tz, options) {
      tz = new SpaceTime(null, tz, options);
      tz.epoch = 8640000000000000;
      return tz;
    };
    main.min = function(tz, options) {
      tz = new SpaceTime(null, tz, options);
      tz.epoch = -8640000000000000;
      return tz;
    };
    main.whereIts = (a, b) => {
      let start = new SpaceTime(null), end = new SpaceTime(null);
      start = start.time(a);
      end = b ? end.time(b) : start.add(59, "minutes");
      let startHour = start.hour(), endHour = end.hour();
      return Object.keys(start.timezones).filter(tz => {
        if (-1 === tz.indexOf("/")) {
          return !1;
        }
        tz = new SpaceTime(null, tz);
        let hour = tz.hour();
        return hour >= startHour && hour <= endHour ? hour === startHour && tz.minute() < start.minute() || hour === endHour && tz.minute() > end.minute() ? !1 : !0 : !1;
      });
    };
    main.version = "7.6.0";
    main.plugin = main.extend;
    return main;
  });
};

//# sourceMappingURL=module$node_modules$spacetime$builds$spacetime_cjs.js.map
