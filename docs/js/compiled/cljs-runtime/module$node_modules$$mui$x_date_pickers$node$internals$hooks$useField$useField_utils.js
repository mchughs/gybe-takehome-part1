shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.validateSections = exports.removeLocalizedDigits = exports.parseSelectedSections = exports.mergeDateIntoReferenceDate = exports.isStringNumber = exports.isAndroid = exports.getSectionsBoundaries = exports.getSectionVisibleValue = exports.getSectionValueText = exports.getSectionValueNow = exports.getSectionOrder = exports.getLocalizedDigits = exports.getLetterEditingOptions = exports.getDaysInWeekStr = exports.getDateSectionConfigFromFormatToken = exports.getDateFromDateSections = exports.doesSectionFormatHaveLeadingZeros = 
  exports.createDateStrForV7HiddenInputFromSections = exports.createDateStrForV6InputFromSections = exports.cleanLeadingZeros = exports.cleanDigitSectionValue = exports.changeSectionValueFormat = exports.applyLocalizedDigits = exports.adjustSectionValue = exports.FORMAT_SECONDS_NO_LEADING_ZEROS = void 0;
  var _dateUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$date_utils");
  const getDateSectionConfigFromFormatToken = (utils, formatToken) => {
    utils = utils.formatTokenMap[formatToken];
    if (null == utils) {
      throw Error([`MUI X: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
    }
    return "string" === typeof utils ? {type:utils, contentType:"meridiem" === utils ? "letter" : "digit", maxLength:void 0} : {type:utils.sectionType, contentType:utils.contentType, maxLength:utils.maxLength};
  };
  exports.getDateSectionConfigFromFormatToken = getDateSectionConfigFromFormatToken;
  const getDeltaFromKeyCode = keyCode => {
    switch(keyCode) {
      case "ArrowUp":
        return 1;
      case "ArrowDown":
        return -1;
      case "PageUp":
        return 5;
      case "PageDown":
        return -5;
      default:
        return 0;
    }
  }, getDaysInWeekStr = (utils, timezone, format) => {
    const elements = [];
    var now = utils.date(void 0, timezone);
    timezone = utils.startOfWeek(now);
    for (now = utils.endOfWeek(now); utils.isBefore(timezone, now);) {
      elements.push(timezone), timezone = utils.addDays(timezone, 1);
    }
    return elements.map(weekDay => utils.formatByString(weekDay, format));
  };
  exports.getDaysInWeekStr = getDaysInWeekStr;
  const getLetterEditingOptions = (utils, timezone, sectionType, format) => {
    switch(sectionType) {
      case "month":
        return (0,_dateUtils.getMonthsInYear)(utils, utils.date(void 0, timezone)).map(month => utils.formatByString(month, format));
      case "weekDay":
        return getDaysInWeekStr(utils, timezone, format);
      case "meridiem":
        return timezone = utils.date(void 0, timezone), [utils.startOfDay(timezone), utils.endOfDay(timezone)].map(date => utils.formatByString(date, format));
      default:
        return [];
    }
  };
  exports.getLetterEditingOptions = getLetterEditingOptions;
  const FORMAT_SECONDS_NO_LEADING_ZEROS = exports.FORMAT_SECONDS_NO_LEADING_ZEROS = "s", NON_LOCALIZED_DIGITS = "0123456789".split("");
  exports.getLocalizedDigits = utils => {
    const today = utils.date(void 0);
    return "0" === utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS) ? NON_LOCALIZED_DIGITS : Array.from({length:10}).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));
  };
  const removeLocalizedDigits = (valueStr, localizedDigits) => {
    if ("0" === localizedDigits[0]) {
      return valueStr;
    }
    const digits = [];
    let currentFormattedDigit = "";
    for (let i = 0; i < valueStr.length; i += 1) {
      currentFormattedDigit += valueStr[i];
      const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);
      -1 < matchingDigitIndex && (digits.push(matchingDigitIndex.toString()), currentFormattedDigit = "");
    }
    return digits.join("");
  };
  exports.removeLocalizedDigits = removeLocalizedDigits;
  const applyLocalizedDigits = (valueStr, localizedDigits) => "0" === localizedDigits[0] ? valueStr : valueStr.split("").map(char => localizedDigits[Number(char)]).join("");
  exports.applyLocalizedDigits = applyLocalizedDigits;
  exports.isStringNumber = (valueStr, localizedDigits) => {
    valueStr = removeLocalizedDigits(valueStr, localizedDigits);
    return !Number.isNaN(Number(valueStr));
  };
  const cleanLeadingZeros = (valueStr, size) => {
    for (valueStr = Number(valueStr).toString(); valueStr.length < size;) {
      valueStr = `0${valueStr}`;
    }
    return valueStr;
  };
  exports.cleanLeadingZeros = cleanLeadingZeros;
  const cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {
    if ("day" !== section.type && "digit-with-letter" === section.contentType) {
      throw Error([`MUI X: The token "${section.format}" is a digit format with letter in it.'
             This type of format is only supported for 'day' sections`].join("\n"));
    }
    if ("day" === section.type && "digit-with-letter" === section.contentType) {
      return localizedDigits = utils.setDate(sectionBoundaries.longestMonth, value), utils.formatByString(localizedDigits, section.format);
    }
    utils = value.toString();
    section.hasLeadingZerosInInput && (utils = cleanLeadingZeros(utils, section.maxLength));
    return applyLocalizedDigits(utils, localizedDigits);
  };
  exports.cleanDigitSectionValue = cleanDigitSectionValue;
  exports.adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {
    const delta = getDeltaFromKeyCode(keyCode), isStart = "Home" === keyCode, isEnd = "End" === keyCode, shouldSetAbsolute = "" === section.value || isStart || isEnd;
    keyCode = () => {
      const sectionBoundaries = sectionsValueBoundaries[section.type]({currentDate:activeDate, format:section.format, contentType:section.contentType}), step = "minutes" === section.type && stepsAttributes?.minutesStep ? stepsAttributes.minutesStep : 1;
      let newSectionValueNumber = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10) + delta * step;
      if (shouldSetAbsolute) {
        if ("year" === section.type && !isEnd && !isStart) {
          return utils.formatByString(utils.date(void 0, timezone), section.format);
        }
        newSectionValueNumber = 0 < delta || isStart ? sectionBoundaries.minimum : sectionBoundaries.maximum;
      }
      if (0 !== newSectionValueNumber % step) {
        if (0 > delta || isStart) {
          newSectionValueNumber += step - (step + newSectionValueNumber) % step;
        }
        if (0 < delta || isEnd) {
          newSectionValueNumber -= newSectionValueNumber % step;
        }
      }
      return newSectionValueNumber > sectionBoundaries.maximum ? cleanDigitSectionValue(utils, sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1), sectionBoundaries, localizedDigits, section) : newSectionValueNumber < sectionBoundaries.minimum ? cleanDigitSectionValue(utils, sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 
      1), sectionBoundaries, localizedDigits, section) : cleanDigitSectionValue(utils, newSectionValueNumber, sectionBoundaries, localizedDigits, section);
    };
    return "digit" === section.contentType || "digit-with-letter" === section.contentType ? keyCode() : (() => {
      const options = getLetterEditingOptions(utils, timezone, section.type, section.format);
      if (0 === options.length) {
        return section.value;
      }
      if (shouldSetAbsolute) {
        return 0 < delta || isStart ? options[0] : options[options.length - 1];
      }
      const newOptionIndex = (options.indexOf(section.value) + options.length + delta) % options.length;
      return options[newOptionIndex];
    })();
  };
  const getSectionVisibleValue = (section, target, localizedDigits) => {
    let value = section.value || section.placeholder;
    const hasLeadingZeros = "non-input" === target ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
    "non-input" === target && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat && (value = Number(removeLocalizedDigits(value, localizedDigits)).toString());
    ["input-rtl", "input-ltr"].includes(target) && "digit" === section.contentType && !hasLeadingZeros && 1 === value.length && (value = `${value}\u200e`);
    "input-rtl" === target && (value = `\u2068${value}\u2069`);
    return value;
  };
  exports.getSectionVisibleValue = getSectionVisibleValue;
  exports.changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {
    if ("weekDay" === getDateSectionConfigFromFormatToken(utils, currentFormat).type) {
      throw Error("changeSectionValueFormat doesn't support week day formats");
    }
    return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);
  };
  exports.doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {
    if ("digit" !== contentType) {
      return !1;
    }
    contentType = utils.date(void 0, timezone);
    switch(sectionType) {
      case "year":
        return 4 === utils.formatByString(utils.date(void 0, timezone), format).length ? "0001" === utils.formatByString(utils.setYear(contentType, 1), format) : "01" === utils.formatByString(utils.setYear(contentType, 2001), format);
      case "month":
        return 1 < utils.formatByString(utils.startOfYear(contentType), format).length;
      case "day":
        return 1 < utils.formatByString(utils.startOfMonth(contentType), format).length;
      case "weekDay":
        return 1 < utils.formatByString(utils.startOfWeek(contentType), format).length;
      case "hours":
        return 1 < utils.formatByString(utils.setHours(contentType, 1), format).length;
      case "minutes":
        return 1 < utils.formatByString(utils.setMinutes(contentType, 1), format).length;
      case "seconds":
        return 1 < utils.formatByString(utils.setSeconds(contentType, 1), format).length;
      default:
        throw Error("Invalid section type");
    }
  };
  exports.getDateFromDateSections = (utils, sections, localizedDigits) => {
    const shouldSkipWeekDays = sections.some(section => "day" === section.type), sectionFormats = [];
    var sectionValues = [];
    for (let i = 0; i < sections.length; i += 1) {
      const section = sections[i];
      shouldSkipWeekDays && "weekDay" === section.type || (sectionFormats.push(section.format), sectionValues.push(getSectionVisibleValue(section, "non-input", localizedDigits)));
    }
    sections = sectionFormats.join(" ");
    sectionValues = sectionValues.join(" ");
    return utils.parse(sectionValues, sections);
  };
  exports.createDateStrForV7HiddenInputFromSections = sections => sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join("");
  exports.createDateStrForV6InputFromSections = (sections, localizedDigits, isRTL) => {
    sections = sections.map(section => {
      const dateValue = getSectionVisibleValue(section, isRTL ? "input-rtl" : "input-ltr", localizedDigits);
      return `${section.startSeparator}${dateValue}${section.endSeparator}`;
    }).join("");
    return isRTL ? `\u2066${sections}\u2069` : sections;
  };
  exports.getSectionsBoundaries = (utils, localizedDigits, timezone) => {
    const today = utils.date(void 0, timezone), endOfYear = utils.endOfYear(today), endOfDay = utils.endOfDay(today), {maxDaysInMonth, longestMonth} = (0,_dateUtils.getMonthsInYear)(utils, today).reduce((acc, month) => {
      const daysInMonth = utils.getDaysInMonth(month);
      return daysInMonth > acc.maxDaysInMonth ? {maxDaysInMonth:daysInMonth, longestMonth:month} : acc;
    }, {maxDaysInMonth:0, longestMonth:null});
    return {year:({format}) => ({minimum:0, maximum:4 === utils.formatByString(utils.date(void 0, timezone), format).length ? 9999 : 99}), month:() => ({minimum:1, maximum:utils.getMonth(endOfYear) + 1}), day:({currentDate}) => ({minimum:1, maximum:null != currentDate && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth, longestMonth}), weekDay:({format, contentType}) => "digit" === contentType ? (format = getDaysInWeekStr(utils, timezone, format).map(Number), {minimum:Math.min(...format), 
    maximum:Math.max(...format)}) : {minimum:1, maximum:7}, hours:({format}) => {
      const lastHourInDay = utils.getHours(endOfDay);
      return removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString() ? {minimum:1, maximum:Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))} : {minimum:0, maximum:lastHourInDay};
    }, minutes:() => ({minimum:0, maximum:utils.getMinutes(endOfDay)}), seconds:() => ({minimum:0, maximum:utils.getSeconds(endOfDay)}), meridiem:() => ({minimum:0, maximum:1}), empty:() => ({minimum:0, maximum:0})};
  };
  let warnedOnceInvalidSection = !1;
  exports.validateSections = (sections, valueType) => {
    if (!warnedOnceInvalidSection) {
      const supportedSections = ["empty"];
      ["date", "date-time"].includes(valueType) && supportedSections.push("weekDay", "day", "month", "year");
      ["time", "date-time"].includes(valueType) && supportedSections.push("hours", "minutes", "seconds", "meridiem");
      if (sections = sections.find(section => !supportedSections.includes(section.type))) {
        console.warn(`MUI X: The field component you are using is not compatible with the "${sections.type}" date section.`, `The supported date sections are ["${supportedSections.join('", "')}"]\`.`), warnedOnceInvalidSection = !0;
      }
    }
  };
  const transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {
    switch(section.type) {
      case "year":
        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));
      case "month":
        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));
      case "weekDay":
        return dateToTransferTo = getDaysInWeekStr(utils, timezone, section.format), timezone = utils.formatByString(dateToTransferFrom, section.format), timezone = dateToTransferTo.indexOf(timezone), section = dateToTransferTo.indexOf(section.value), utils.addDays(dateToTransferFrom, section - timezone);
      case "day":
        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));
      case "meridiem":
        return dateToTransferFrom = 12 > utils.getHours(dateToTransferFrom), section = utils.getHours(dateToTransferTo), dateToTransferFrom && 12 <= section ? utils.addHours(dateToTransferTo, -12) : !dateToTransferFrom && 12 > section ? utils.addHours(dateToTransferTo, 12) : dateToTransferTo;
      case "hours":
        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));
      case "minutes":
        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));
      case "seconds":
        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));
      default:
        return dateToTransferTo;
    }
  }, reliableSectionModificationOrder = {year:1, month:2, day:3, weekDay:4, hours:5, minutes:6, seconds:7, meridiem:8, empty:9};
  exports.mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => [...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => !shouldLimitToEditedSections || section.modified ? transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate) : mergedDate, referenceDate);
  exports.isAndroid = () => -1 < navigator.userAgent.toLowerCase().indexOf("android");
  exports.getSectionOrder = (sections, shouldApplyRTL) => {
    const neighbors = {};
    if (!shouldApplyRTL) {
      return sections.forEach((_, index) => {
        neighbors[index] = {leftIndex:0 === index ? null : index - 1, rightIndex:index === sections.length - 1 ? null : index + 1};
      }), {neighbors, startIndex:0, endIndex:sections.length - 1};
    }
    const rtl2ltr = {}, ltr2rtl = {};
    let groupedSectionsStart = 0;
    shouldApplyRTL = 0;
    let RTLIndex = sections.length - 1;
    for (; 0 <= RTLIndex;) {
      shouldApplyRTL = sections.findIndex((section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(" ") && " / " !== section.endSeparator);
      -1 === shouldApplyRTL && (shouldApplyRTL = sections.length - 1);
      for (let i = shouldApplyRTL; i >= groupedSectionsStart; --i) {
        ltr2rtl[i] = RTLIndex, rtl2ltr[RTLIndex] = i, --RTLIndex;
      }
      groupedSectionsStart = shouldApplyRTL + 1;
    }
    sections.forEach((_, index) => {
      _ = ltr2rtl[index];
      neighbors[index] = {leftIndex:0 === _ ? null : rtl2ltr[_ - 1], rightIndex:_ === sections.length - 1 ? null : rtl2ltr[_ + 1]};
    });
    return {neighbors, startIndex:rtl2ltr[0], endIndex:rtl2ltr[sections.length - 1]};
  };
  exports.parseSelectedSections = (selectedSections, sections) => null == selectedSections ? null : "all" === selectedSections ? "all" : "string" === typeof selectedSections ? sections.findIndex(section => section.type === selectedSections) : selectedSections;
  exports.getSectionValueText = (section, utils) => {
    if (section.value) {
      switch(section.type) {
        case "month":
          return "digit" === section.contentType ? utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), "month") : (section = utils.parse(section.value, section.format)) ? utils.format(section, "month") : void 0;
        case "day":
          return "digit" === section.contentType ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), "dayOfMonthFull") : section.value;
      }
    }
  };
  exports.getSectionValueNow = (section, utils) => {
    if (section.value) {
      switch(section.type) {
        case "weekDay":
          return "letter" === section.contentType ? void 0 : Number(section.value);
        case "meridiem":
          if (section = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`)) {
            return 12 <= utils.getHours(section) ? 1 : 0;
          }
          break;
        case "day":
          return "digit-with-letter" === section.contentType ? parseInt(section.value, 10) : Number(section.value);
        case "month":
          return "digit" === section.contentType ? Number(section.value) : (section = utils.parse(section.value, section.format)) ? utils.getMonth(section) + 1 : void 0;
        default:
          return "letter" !== section.contentType ? Number(section.value) : void 0;
      }
    }
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils.js.map
