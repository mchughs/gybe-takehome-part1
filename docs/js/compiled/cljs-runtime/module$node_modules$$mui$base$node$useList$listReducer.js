shadow$provide.module$node_modules$$mui$base$node$useList$listReducer = function(global, require, module, exports) {
  function findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {
    if (0 === items.length || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {
      return -1;
    }
    for (;;) {
      if (!wrapAround && "next" === lookupDirection && currentIndex === items.length || !wrapAround && "previous" === lookupDirection && -1 === currentIndex) {
        return -1;
      }
      if (includeDisabledItems ? 0 : isItemDisabled(items[currentIndex], currentIndex)) {
        currentIndex += "next" === lookupDirection ? 1 : -1, wrapAround && (currentIndex = (currentIndex + items.length) % items.length);
      } else {
        return currentIndex;
      }
    }
  }
  function moveHighlight(previouslyHighlightedValue, offset, context) {
    var _items$nextIndex;
    const {items, isItemDisabled, disableListWrap, disabledItemsFocusable, itemComparer, focusManagement} = context;
    var defaultHighlightedIndex = "DOM" === focusManagement ? 0 : -1, maxIndex = items.length - 1;
    context = null == previouslyHighlightedValue ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));
    let wrapAround = !disableListWrap;
    switch(offset) {
      case "reset":
        if (-1 === defaultHighlightedIndex) {
          return null;
        }
        maxIndex = 0;
        offset = "next";
        wrapAround = !1;
        break;
      case "start":
        maxIndex = 0;
        offset = "next";
        wrapAround = !1;
        break;
      case "end":
        offset = "previous";
        wrapAround = !1;
        break;
      default:
        defaultHighlightedIndex = context + offset, 0 > defaultHighlightedIndex ? !wrapAround && -1 !== context || 1 < Math.abs(offset) ? (maxIndex = 0, offset = "next") : offset = "previous" : defaultHighlightedIndex > maxIndex ? !wrapAround || 1 < Math.abs(offset) ? offset = "previous" : (maxIndex = 0, offset = "next") : (maxIndex = defaultHighlightedIndex, offset = 0 <= offset ? "next" : "previous");
    }
    offset = findValidItemToHighlight(maxIndex, offset, items, disabledItemsFocusable, isItemDisabled, wrapAround);
    return -1 !== offset || null === previouslyHighlightedValue || isItemDisabled(previouslyHighlightedValue, context) ? null != (_items$nextIndex = items[offset]) ? _items$nextIndex : null : previouslyHighlightedValue;
  }
  function toggleSelection(item, selectedValues, selectionMode, itemComparer) {
    return "none" === selectionMode ? [] : "single" === selectionMode ? itemComparer(selectedValues[0], item) ? selectedValues : [item] : selectedValues.some(sv => itemComparer(sv, item)) ? selectedValues.filter(sv => !itemComparer(sv, item)) : [...selectedValues, item];
  }
  function handleItemSelection(item, state, context) {
    const {itemComparer, isItemDisabled, selectionMode, items} = context;
    ({selectedValues:context} = state);
    const itemIndex = items.findIndex(i => itemComparer(item, i));
    if (isItemDisabled(item, itemIndex)) {
      return state;
    }
    context = toggleSelection(item, context, selectionMode, itemComparer);
    return (0,_extends2.default)({}, state, {selectedValues:context, highlightedValue:item});
  }
  function handleKeyDown(key, state, context) {
    const previouslySelectedValue = state.highlightedValue, {orientation, pageSize} = context;
    switch(key) {
      case "Home":
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, "start", context)});
      case "End":
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, "end", context)});
      case "PageUp":
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, -pageSize, context)});
      case "PageDown":
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, pageSize, context)});
      case "ArrowUp":
        if ("vertical" !== orientation) {
          break;
        }
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, -1, context)});
      case "ArrowDown":
        if ("vertical" !== orientation) {
          break;
        }
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, 1, context)});
      case "ArrowLeft":
        if ("vertical" === orientation) {
          break;
        }
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, "horizontal-ltr" === orientation ? -1 : 1, context)});
      case "ArrowRight":
        if ("vertical" === orientation) {
          break;
        }
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(previouslySelectedValue, "horizontal-ltr" === orientation ? 1 : -1, context)});
      case "Enter":
      case " ":
        if (null !== state.highlightedValue) {
          return handleItemSelection(state.highlightedValue, state, context);
        }
    }
    return state;
  }
  function handleItemsChange(items, previousItems, state, context) {
    var _state$selectedValues;
    const {itemComparer, focusManagement} = context;
    let newHighlightedValue = null;
    if (null != state.highlightedValue) {
      var _items$find;
      newHighlightedValue = null != (_items$find = items.find(item => itemComparer(item, state.highlightedValue))) ? _items$find : null;
    } else {
      "DOM" === focusManagement && 0 === previousItems.length && (newHighlightedValue = moveHighlight(null, "reset", context));
    }
    previousItems = (null != (_state$selectedValues = state.selectedValues) ? _state$selectedValues : []).filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));
    return (0,_extends2.default)({}, state, {highlightedValue:newHighlightedValue, selectedValues:previousItems});
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.handleItemSelection = handleItemSelection;
  exports.listReducer = function(state, action) {
    const {type, context} = action;
    switch(type) {
      case _listActions.ListActionTypes.keyDown:
        return handleKeyDown(action.key, state, context);
      case _listActions.ListActionTypes.itemClick:
        return handleItemSelection(action.item, state, context);
      case _listActions.ListActionTypes.blur:
        return state = "DOM" === context.focusManagement ? state : (0,_extends2.default)({}, state, {highlightedValue:null}), state;
      case _listActions.ListActionTypes.textNavigation:
        a: {
          action = action.searchString;
          const {items, isItemDisabled, disabledItemsFocusable, getItemAsString} = context, startWithCurrentItem = 1 < action.length;
          let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);
          for (let index = 0; index < items.length; index += 1) {
            if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {
              break a;
            }
            var _stringifyItem = void 0, searchString = action;
            const text = null == (_stringifyItem = getItemAsString(nextItem)) ? void 0 : _stringifyItem.trim().toLowerCase();
            if (text && 0 !== text.length && 0 === text.indexOf(searchString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {
              state = (0,_extends2.default)({}, state, {highlightedValue:nextItem});
              break a;
            }
            nextItem = moveHighlight(nextItem, 1, context);
          }
        }
        return state;
      case _listActions.ListActionTypes.itemsChange:
        return handleItemsChange(action.items, action.previousItems, state, context);
      case _listActions.ListActionTypes.resetHighlight:
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(null, "reset", context)});
      case _listActions.ListActionTypes.highlightLast:
        return (0,_extends2.default)({}, state, {highlightedValue:moveHighlight(null, "end", context)});
      case _listActions.ListActionTypes.clearSelection:
        return (0,_extends2.default)({}, state, {selectedValues:[], highlightedValue:moveHighlight(null, "reset", context)});
      default:
        return state;
    }
  };
  exports.moveHighlight = moveHighlight;
  exports.toggleSelection = toggleSelection;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), _listActions = require("module$node_modules$$mui$base$node$useList$listActions_types");
};

//# sourceMappingURL=module$node_modules$$mui$base$node$useList$listReducer.js.map
