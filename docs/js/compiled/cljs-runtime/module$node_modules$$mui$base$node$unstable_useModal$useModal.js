shadow$provide.module$node_modules$$mui$base$node$unstable_useModal$useModal = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.useModal = function(parameters) {
    const {container, disableEscapeKeyDown = !1, disableScrollLock = !1, manager = defaultManager, closeAfterTransition = !1, onTransitionEnter, onTransitionExited, children, onClose, open, rootRef} = parameters, modal = React.useRef({}), mountNodeRef = React.useRef(null), modalRef = React.useRef(null), handleRef = (0,_utils.unstable_useForkRef)(modalRef, rootRef), [exited, setExited] = React.useState(!open), hasTransition = children ? children.props.hasOwnProperty("in") : !1;
    let ariaHiddenProp = !0;
    if ("false" === parameters["aria-hidden"] || !1 === parameters["aria-hidden"]) {
      ariaHiddenProp = !1;
    }
    const getModal = () => {
      modal.current.modalRef = modalRef.current;
      modal.current.mount = mountNodeRef.current;
      return modal.current;
    }, handleMounted = () => {
      manager.mount(getModal(), {disableScrollLock});
      modalRef.current && (modalRef.current.scrollTop = 0);
    }, handleOpen = (0,_utils.unstable_useEventCallback)(() => {
      const resolvedContainer = ("function" === typeof container ? container() : container) || (0,_utils.unstable_ownerDocument)(mountNodeRef.current).body;
      manager.add(getModal(), resolvedContainer);
      modalRef.current && handleMounted();
    }), isTopModal = React.useCallback(() => manager.isTopModal(getModal()), [manager]), handlePortalRef = (0,_utils.unstable_useEventCallback)(node => {
      (mountNodeRef.current = node) && (open && isTopModal() ? handleMounted() : modalRef.current && (0,_ModalManager.ariaHidden)(modalRef.current, ariaHiddenProp));
    }), handleClose = React.useCallback(() => {
      manager.remove(getModal(), ariaHiddenProp);
    }, [ariaHiddenProp, manager]);
    React.useEffect(() => () => {
      handleClose();
    }, [handleClose]);
    React.useEffect(() => {
      open ? handleOpen() : hasTransition && closeAfterTransition || handleClose();
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
    const createHandleKeyDown = otherHandlers => event => {
      var _otherHandlers$onKeyD;
      null == (_otherHandlers$onKeyD = otherHandlers.onKeyDown) || _otherHandlers$onKeyD.call(otherHandlers, event);
      "Escape" === event.key && 229 !== event.which && isTopModal() && !disableEscapeKeyDown && (event.stopPropagation(), onClose && onClose(event, "escapeKeyDown"));
    }, createHandleBackdropClick = otherHandlers => event => {
      var _otherHandlers$onClic;
      null == (_otherHandlers$onClic = otherHandlers.onClick) || _otherHandlers$onClic.call(otherHandlers, event);
      event.target === event.currentTarget && onClose && onClose(event, "backdropClick");
    };
    return {getRootProps:(otherHandlers = {}) => {
      const propsEventHandlers = (0,_utils2.extractEventHandlers)(parameters);
      delete propsEventHandlers.onTransitionEnter;
      delete propsEventHandlers.onTransitionExited;
      otherHandlers = (0,_extends2.default)({}, propsEventHandlers, otherHandlers);
      return (0,_extends2.default)({role:"presentation"}, otherHandlers, {onKeyDown:createHandleKeyDown(otherHandlers), ref:handleRef});
    }, getBackdropProps:(otherHandlers = {}) => (0,_extends2.default)({"aria-hidden":!0}, otherHandlers, {onClick:createHandleBackdropClick(otherHandlers), open}), getTransitionProps:() => ({onEnter:(0,_utils.unstable_createChainedFunction)(() => {
      setExited(!1);
      onTransitionEnter && onTransitionEnter();
    }, null == children ? void 0 : children.props.onEnter), onExited:(0,_utils.unstable_createChainedFunction)(() => {
      setExited(!0);
      onTransitionExited && onTransitionExited();
      closeAfterTransition && handleClose();
    }, null == children ? void 0 : children.props.onExited)}), rootRef:handleRef, portalRef:handlePortalRef, isTopModal, exited, hasTransition};
  };
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _utils = require("module$node_modules$$mui$utils$node$index"), _utils2 = require("module$node_modules$$mui$base$node$utils$index"), _ModalManager = require("module$node_modules$$mui$base$node$unstable_useModal$ModalManager");
  const defaultManager = new _ModalManager.ModalManager();
};

//# sourceMappingURL=module$node_modules$$mui$base$node$unstable_useModal$useModal.js.map
