shadow$provide.module$node_modules$$floating_ui$core$dist$floating_ui_core_umd = function(global, require, module, exports) {
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? factory(exports) : "function" === typeof define && define.amd ? define(["exports"], factory) : (global = "undefined" !== typeof globalThis ? globalThis : global || self, factory(global.FloatingUICore = {}));
  })(this, function(exports) {
    function evaluate(value, param) {
      return "function" === typeof value ? value(param) : value;
    }
    function getSide(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getOppositeAxis(axis) {
      return "x" === axis ? "y" : "x";
    }
    function getAxisLength(axis) {
      return "y" === axis ? "height" : "width";
    }
    function getSideAxis(placement) {
      return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
    }
    function getAlignmentSides(placement, rects, rtl) {
      void 0 === rtl && (rtl = !1);
      const alignment = getAlignment(placement), alignmentAxis = getOppositeAxis(getSideAxis(placement));
      placement = getAxisLength(alignmentAxis);
      rtl = "x" === alignmentAxis ? alignment === (rtl ? "end" : "start") ? "right" : "left" : "start" === alignment ? "bottom" : "top";
      rects.reference[placement] > rects.floating[placement] && (rtl = getOppositePlacement(rtl));
      return [rtl, getOppositePlacement(rtl)];
    }
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement(placement);
      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
    }
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
    }
    function getSideList(side, isStart, rtl) {
      const lr = ["left", "right"], rl = ["right", "left"], tb = ["top", "bottom"], bt = ["bottom", "top"];
      switch(side) {
        case "top":
        case "bottom":
          return rtl ? isStart ? rl : lr : isStart ? lr : rl;
        case "left":
        case "right":
          return isStart ? tb : bt;
        default:
          return [];
      }
    }
    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
      const alignment = getAlignment(placement);
      placement = getSideList(getSide(placement), "start" === direction, rtl);
      alignment && (placement = placement.map(side => side + "-" + alignment), flipAlignment && (placement = placement.concat(placement.map(getOppositeAlignmentPlacement))));
      return placement;
    }
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
    }
    function getPaddingObject(padding) {
      return "number" !== typeof padding ? {top:0, right:0, bottom:0, left:0, ...padding} : {top:padding, right:padding, bottom:padding, left:padding};
    }
    function rectToClientRect(rect) {
      return {...rect, top:rect.y, left:rect.x, right:rect.x + rect.width, bottom:rect.y + rect.height};
    }
    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let {reference, floating} = _ref;
      var sideAxis = getSideAxis(placement);
      _ref = getOppositeAxis(getSideAxis(placement));
      var alignLength = getAxisLength(_ref), side = getSide(placement);
      sideAxis = "y" === sideAxis;
      const commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2;
      alignLength = reference[alignLength] / 2 - floating[alignLength] / 2;
      switch(side) {
        case "top":
          side = {x:commonX, y:reference.y - floating.height};
          break;
        case "bottom":
          side = {x:commonX, y:reference.y + reference.height};
          break;
        case "right":
          side = {x:reference.x + reference.width, y:commonY};
          break;
        case "left":
          side = {x:reference.x - floating.width, y:commonY};
          break;
        default:
          side = {x:reference.x, y:reference.y};
      }
      switch(getAlignment(placement)) {
        case "start":
          side[_ref] -= alignLength * (rtl && sideAxis ? -1 : 1);
          break;
        case "end":
          side[_ref] += alignLength * (rtl && sideAxis ? -1 : 1);
      }
      return side;
    }
    async function detectOverflow(state, options) {
      var _await$platform$isEle;
      void 0 === options && (options = {});
      const {x, y, platform, rects, elements, strategy} = state, {boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = !1, padding = 0} = evaluate(options, state);
      state = getPaddingObject(padding);
      var element = elements[altBoundary ? "floating" === elementContext ? "reference" : "floating" : elementContext];
      options = rectToClientRect(await platform.getClippingRect({element:(null != (_await$platform$isEle = await (null == platform.isElement ? void 0 : platform.isElement(element))) ? _await$platform$isEle : 1) ? element : element.contextElement || await (null == platform.getDocumentElement ? void 0 : platform.getDocumentElement(elements.floating)), boundary, rootBoundary, strategy}));
      element = "floating" === elementContext ? {...rects.floating, x, y} : rects.reference;
      const offsetParent = await (null == platform.getOffsetParent ? void 0 : platform.getOffsetParent(elements.floating));
      _await$platform$isEle = await (null == platform.isElement ? void 0 : platform.isElement(offsetParent)) ? await (null == platform.getScale ? void 0 : platform.getScale(offsetParent)) || {x:1, y:1} : {x:1, y:1};
      element = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({elements, rect:element, offsetParent, strategy}) : element);
      return {top:(options.top - element.top + state.top) / _await$platform$isEle.y, bottom:(element.bottom - options.bottom + state.bottom) / _await$platform$isEle.y, left:(options.left - element.left + state.left) / _await$platform$isEle.x, right:(element.right - options.right + state.right) / _await$platform$isEle.x};
    }
    function getPlacementList(alignment, autoAlignment, allowedPlacements) {
      return (alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement)).filter(placement => alignment ? getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : !1) : !0);
    }
    function getSideOffsets(overflow, rect) {
      return {top:overflow.top - rect.height, right:overflow.right - rect.width, bottom:overflow.bottom - rect.height, left:overflow.left - rect.width};
    }
    function isAnySideFullyClipped(overflow) {
      return sides.some(side => 0 <= overflow[side]);
    }
    function getBoundingRect(rects) {
      const minX = min(...rects.map(rect => rect.left)), minY = min(...rects.map(rect => rect.top)), maxX = max(...rects.map(rect => rect.right));
      rects = max(...rects.map(rect => rect.bottom));
      return {x:minX, y:minY, width:maxX - minX, height:rects - minY};
    }
    function getRectsByLine(rects) {
      rects = rects.slice().sort((a, b) => a.y - b.y);
      const groups = [];
      let prevRect = null;
      for (let i = 0; i < rects.length; i++) {
        const rect = rects[i];
        !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect);
        prevRect = rect;
      }
      return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
    }
    async function convertValueToCoords(state, options) {
      const {placement, platform, elements} = state;
      var rtl = await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating)), side = getSide(placement);
      const alignment = getAlignment(placement), isVertical = "y" === getSideAxis(placement);
      side = ["left", "top"].includes(side) ? -1 : 1;
      rtl = rtl && isVertical ? -1 : 1;
      state = evaluate(options, state);
      let {mainAxis, crossAxis, alignmentAxis} = "number" === typeof state ? {mainAxis:state, crossAxis:0, alignmentAxis:null} : {mainAxis:0, crossAxis:0, alignmentAxis:null, ...state};
      alignment && "number" === typeof alignmentAxis && (crossAxis = "end" === alignment ? -1 * alignmentAxis : alignmentAxis);
      return isVertical ? {x:crossAxis * rtl, y:mainAxis * side} : {x:mainAxis * side, y:crossAxis * rtl};
    }
    const sides = ["top", "right", "bottom", "left"], alignments = ["start", "end"], placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []), min = Math.min, max = Math.max, oppositeSideMap = {left:"right", right:"left", bottom:"top", top:"bottom"}, oppositeAlignmentMap = {start:"end", end:"start"};
    exports.arrow = options => ({name:"arrow", options, async fn(state) {
      const {x, y, placement, rects, platform, elements, middlewareData} = state, {element, padding = 0} = evaluate(options, state) || {};
      if (null == element) {
        return {};
      }
      var paddingObject = getPaddingObject(padding);
      state = {x, y};
      const axis = getOppositeAxis(getSideAxis(placement));
      var length = getAxisLength(axis), arrowDimensions = await platform.getDimensions(element), isYAxis = "y" === axis, minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - state[axis] - rects.floating[length];
      const startDiff = state[axis] - rects.reference[axis], arrowOffsetParent = await (null == platform.getOffsetParent ? void 0 : platform.getOffsetParent(element));
      (isYAxis = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0) && await (null == platform.isElement ? void 0 : platform.isElement(arrowOffsetParent)) || (isYAxis = elements.floating[clientProp] || rects.floating[length]);
      clientProp = endDiff / 2 - startDiff / 2;
      endDiff = isYAxis / 2 - arrowDimensions[length] / 2 - 1;
      minProp = min(paddingObject[minProp], endDiff);
      maxProp = min(paddingObject[maxProp], endDiff);
      paddingObject = isYAxis - arrowDimensions[length] - maxProp;
      isYAxis = isYAxis / 2 - arrowDimensions[length] / 2 + clientProp;
      clientProp = max(minProp, min(isYAxis, paddingObject));
      arrowDimensions = (length = !middlewareData.arrow && null != getAlignment(placement) && isYAxis !== clientProp && 0 > rects.reference[length] / 2 - (isYAxis < minProp ? minProp : maxProp) - arrowDimensions[length] / 2) ? isYAxis < minProp ? isYAxis - minProp : isYAxis - paddingObject : 0;
      return {[axis]:state[axis] + arrowDimensions, data:{[axis]:clientProp, centerOffset:isYAxis - clientProp - arrowDimensions, ...(length && {alignmentOffset:arrowDimensions})}, reset:length};
    }});
    exports.autoPlacement = function(options) {
      void 0 === options && (options = {});
      return {name:"autoPlacement", options, async fn(state) {
        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
        const {rects, middlewareData, placement, platform, elements} = state, {crossAxis = !1, alignment, allowedPlacements = placements, autoAlignment = !0, ...detectOverflowOptions} = evaluate(options, state);
        var placements$1 = void 0 !== alignment || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements, overflow = await detectOverflow(state, detectOverflowOptions);
        state = (null == (_middlewareData$autoP = middlewareData.autoPlacement) ? void 0 : _middlewareData$autoP.index) || 0;
        _middlewareData$autoP = placements$1[state];
        if (null == _middlewareData$autoP) {
          return {};
        }
        var alignmentSides = getAlignmentSides(_middlewareData$autoP, rects, await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating)));
        if (placement !== _middlewareData$autoP) {
          return {reset:{placement:placements$1[0]}};
        }
        alignmentSides = [overflow[getSide(_middlewareData$autoP)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
        overflow = [...((null == (_middlewareData$autoP2 = middlewareData.autoPlacement) ? void 0 : _middlewareData$autoP2.overflows) || []), {placement:_middlewareData$autoP, overflows:alignmentSides}];
        if (_middlewareData$autoP2 = placements$1[state + 1]) {
          return {data:{index:state + 1, overflows:overflow}, reset:{placement:_middlewareData$autoP2}};
        }
        _middlewareData$autoP2 = overflow.map(d => {
          const alignment = getAlignment(d.placement);
          return [d.placement, alignment && crossAxis ? d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) : d.overflows[0], d.overflows];
        }).sort((a, b) => a[1] - b[1]);
        placements$1 = (null == (_placementsThatFitOnE = _middlewareData$autoP2.filter(d => d[2].slice(0, getAlignment(d[0]) ? 2 : 3).every(v => 0 >= v))[0]) ? void 0 : _placementsThatFitOnE[0]) || _middlewareData$autoP2[0][0];
        return placements$1 !== placement ? {data:{index:state + 1, overflows:overflow}, reset:{placement:placements$1}} : {};
      }};
    };
    exports.computePosition = async(reference, floating, config) => {
      const {placement = "bottom", strategy = "absolute", middleware = [], platform} = config;
      config = middleware.filter(Boolean);
      const rtl = await (null == platform.isRTL ? void 0 : platform.isRTL(floating));
      let rects = await platform.getElementRects({reference, floating, strategy}), {x, y} = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
      for (let i = 0; i < config.length; i++) {
        const {name, fn} = config[i], {x:nextX, y:nextY, data, reset} = await fn({x, y, initialPlacement:placement, placement:statefulPlacement, strategy, middlewareData, rects, platform, elements:{reference, floating}});
        x = null != nextX ? nextX : x;
        y = null != nextY ? nextY : y;
        middlewareData = {...middlewareData, [name]:{...middlewareData[name], ...data}};
        reset && 50 >= resetCount && (resetCount++, "object" === typeof reset && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = !0 === reset.rects ? await platform.getElementRects({reference, floating, strategy}) : reset.rects), {x, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i = -1);
      }
      return {x, y, placement:statefulPlacement, strategy, middlewareData};
    };
    exports.detectOverflow = detectOverflow;
    exports.flip = function(options) {
      void 0 === options && (options = {});
      return {name:"flip", options, async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {placement, middlewareData, rects, initialPlacement, platform, elements} = state, {mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !0, fallbackPlacements:specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = !0, ...detectOverflowOptions} = evaluate(options, state);
        if (null != (_middlewareData$arrow = middlewareData.arrow) && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        _middlewareData$arrow = getSide(placement);
        var isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating));
        isBasePlacement = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        specifiedFallbackPlacements || "none" === fallbackAxisSideDirection || isBasePlacement.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        isBasePlacement = [initialPlacement, ...isBasePlacement];
        const overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
        state = (null == (_middlewareData$flip = middlewareData.flip) ? void 0 : _middlewareData$flip.overflows) || [];
        checkMainAxis && overflows.push(overflow[_middlewareData$arrow]);
        checkCrossAxis && (_middlewareData$flip = getAlignmentSides(placement, rects, rtl), overflows.push(overflow[_middlewareData$flip[0]], overflow[_middlewareData$flip[1]]));
        state = [...state, {placement, overflows}];
        if (!overflows.every(side => 0 >= side)) {
          var _middlewareData$flip2, _overflowsData$filter;
          _middlewareData$flip = ((null == (_middlewareData$flip2 = middlewareData.flip) ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          if (_middlewareData$flip2 = isBasePlacement[_middlewareData$flip]) {
            return {data:{index:_middlewareData$flip, overflows:state}, reset:{placement:_middlewareData$flip2}};
          }
          _middlewareData$flip2 = null == (_overflowsData$filter = state.filter(d => 0 >= d.overflows[0]).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) ? void 0 : _overflowsData$filter.placement;
          if (!_middlewareData$flip2) {
            switch(fallbackStrategy) {
              case "bestFit":
                var _overflowsData$map$so;
                (_overflowsData$filter = null == (_overflowsData$map$so = state.map(d => [d.placement, d.overflows.filter(overflow => 0 < overflow).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) ? void 0 : _overflowsData$map$so[0]) && (_middlewareData$flip2 = _overflowsData$filter);
                break;
              case "initialPlacement":
                _middlewareData$flip2 = initialPlacement;
            }
          }
          if (placement !== _middlewareData$flip2) {
            return {reset:{placement:_middlewareData$flip2}};
          }
        }
        return {};
      }};
    };
    exports.hide = function(options) {
      void 0 === options && (options = {});
      return {name:"hide", options, async fn(state) {
        var {rects} = state;
        const {strategy = "referenceHidden", ...detectOverflowOptions} = evaluate(options, state);
        switch(strategy) {
          case "referenceHidden":
            return state = await detectOverflow(state, {...detectOverflowOptions, elementContext:"reference"}), rects = getSideOffsets(state, rects.reference), {data:{referenceHiddenOffsets:rects, referenceHidden:isAnySideFullyClipped(rects)}};
          case "escaped":
            return state = await detectOverflow(state, {...detectOverflowOptions, altBoundary:!0}), rects = getSideOffsets(state, rects.floating), {data:{escapedOffsets:rects, escaped:isAnySideFullyClipped(rects)}};
          default:
            return {};
        }
      }};
    };
    exports.inline = function(options) {
      void 0 === options && (options = {});
      return {name:"inline", options, async fn(state) {
        const {placement, elements, rects, platform, strategy} = state, {padding = 2, x, y} = evaluate(options, state);
        state = Array.from(await (null == platform.getClientRects ? void 0 : platform.getClientRects(elements.reference)) || []);
        const clientRects = getRectsByLine(state), fallback = rectToClientRect(getBoundingRect(state)), paddingObject = getPaddingObject(padding);
        state = await platform.getElementRects({reference:{getBoundingClientRect:function() {
          if (2 === clientRects.length && clientRects[0].left > clientRects[1].right && null != x && null != y) {
            return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
          }
          if (2 <= clientRects.length) {
            if ("y" === getSideAxis(placement)) {
              var firstRect = clientRects[0];
              const lastRect = clientRects[clientRects.length - 1], isTop = "top" === getSide(placement);
              var top = firstRect.top, bottom = lastRect.bottom;
              const left = isTop ? firstRect.left : lastRect.left;
              firstRect = isTop ? firstRect.right : lastRect.right;
              return {top, bottom, left, right:firstRect, width:firstRect - left, height:bottom - top, x:left, y:top};
            }
            const isLeftSide = "left" === getSide(placement), maxRight = max(...clientRects.map(rect => rect.right)), minLeft = min(...clientRects.map(rect => rect.left));
            bottom = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
            top = bottom[0].top;
            bottom = bottom[bottom.length - 1].bottom;
            return {top, bottom, left:minLeft, right:maxRight, width:maxRight - minLeft, height:bottom - top, x:minLeft, y:top};
          }
          return fallback;
        }}, floating:elements.floating, strategy});
        return rects.reference.x !== state.reference.x || rects.reference.y !== state.reference.y || rects.reference.width !== state.reference.width || rects.reference.height !== state.reference.height ? {reset:{rects:state}} : {};
      }};
    };
    exports.limitShift = function(options) {
      void 0 === options && (options = {});
      return {options, fn(state) {
        const {x, y, placement, rects, middlewareData} = state, {offset = 0, mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !0} = evaluate(options, state);
        var coords = {x, y};
        const crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        coords = coords[crossAxis];
        state = evaluate(offset, state);
        state = "number" === typeof state ? {mainAxis:state, crossAxis:0} : {mainAxis:0, crossAxis:0, ...state};
        if (checkMainAxis) {
          var len$jscomp$0 = "y" === mainAxis ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len$jscomp$0] + state.mainAxis;
          len$jscomp$0 = rects.reference[mainAxis] + rects.reference[len$jscomp$0] - state.mainAxis;
          mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > len$jscomp$0 && (mainAxisCoord = len$jscomp$0);
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = "y" === mainAxis ? "width" : "height";
          limitMin = ["top", "left"].includes(getSide(placement));
          len$jscomp$0 = rects.reference[crossAxis] - rects.floating[len] + (limitMin ? (null == (_middlewareData$offse = middlewareData.offset) ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (limitMin ? 0 : state.crossAxis);
          _middlewareData$offse = rects.reference[crossAxis] + rects.reference[len] + (limitMin ? 0 : (null == (_middlewareData$offse2 = middlewareData.offset) ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (limitMin ? state.crossAxis : 0);
          coords < len$jscomp$0 ? coords = len$jscomp$0 : coords > _middlewareData$offse && (coords = _middlewareData$offse);
        }
        return {[mainAxis]:mainAxisCoord, [crossAxis]:coords};
      }};
    };
    exports.offset = function(options) {
      void 0 === options && (options = 0);
      return {name:"offset", options, async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {x, y, placement, middlewareData} = state;
        state = await convertValueToCoords(state, options);
        return placement === (null == (_middlewareData$offse = middlewareData.offset) ? void 0 : _middlewareData$offse.placement) && null != (_middlewareData$arrow = middlewareData.arrow) && _middlewareData$arrow.alignmentOffset ? {} : {x:x + state.x, y:y + state.y, data:{...state, placement}};
      }};
    };
    exports.rectToClientRect = rectToClientRect;
    exports.shift = function(options) {
      void 0 === options && (options = {});
      return {name:"shift", options, async fn(state) {
        const {x, y, placement} = state, {mainAxis:checkMainAxis = !0, crossAxis:checkCrossAxis = !1, limiter = {fn:_ref => {
          let {x, y} = _ref;
          return {x, y};
        }}, ...detectOverflowOptions} = evaluate(options, state);
        var coords = {x, y};
        const overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        coords = coords[crossAxis];
        checkMainAxis && (mainAxisCoord = max(mainAxisCoord + overflow["y" === mainAxis ? "top" : "left"], min(mainAxisCoord, mainAxisCoord - overflow["y" === mainAxis ? "bottom" : "right"])));
        checkCrossAxis && (coords = max(coords + overflow["y" === crossAxis ? "top" : "left"], min(coords, coords - overflow["y" === crossAxis ? "bottom" : "right"])));
        state = limiter.fn({...state, [mainAxis]:mainAxisCoord, [crossAxis]:coords});
        return {...state, data:{x:state.x - x, y:state.y - y}};
      }};
    };
    exports.size = function(options) {
      void 0 === options && (options = {});
      return {name:"size", options, async fn(state) {
        const {placement, rects, platform, elements} = state, {apply = () => {
        }, ...detectOverflowOptions} = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions);
        var side = getSide(placement), alignment = getAlignment(placement);
        const isYAxis = "y" === getSideAxis(placement), {width, height} = rects.floating;
        if ("top" === side || "bottom" === side) {
          var heightSide = side;
          side = alignment === (await (null == platform.isRTL ? void 0 : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          heightSide = "end" === alignment ? "top" : "bottom";
        }
        var overflowAvailableHeight = height - overflow[heightSide], overflowAvailableWidth = width - overflow[side], noShift = !state.middlewareData.shift;
        side = overflowAvailableHeight;
        heightSide = overflowAvailableWidth;
        isYAxis ? (heightSide = width - overflow.left - overflow.right, heightSide = alignment || noShift ? min(overflowAvailableWidth, heightSide) : heightSide) : (side = height - overflow.top - overflow.bottom, side = alignment || noShift ? min(overflowAvailableHeight, side) : side);
        noShift && !alignment && (alignment = max(overflow.left, 0), overflowAvailableHeight = max(overflow.right, 0), noShift = max(overflow.top, 0), overflowAvailableWidth = max(overflow.bottom, 0), isYAxis ? heightSide = width - 2 * (0 !== alignment || 0 !== overflowAvailableHeight ? alignment + overflowAvailableHeight : max(overflow.left, overflow.right)) : side = height - 2 * (0 !== noShift || 0 !== overflowAvailableWidth ? noShift + overflowAvailableWidth : max(overflow.top, overflow.bottom)));
        await apply({...state, availableWidth:heightSide, availableHeight:side});
        state = await platform.getDimensions(elements.floating);
        return width !== state.width || height !== state.height ? {reset:{rects:!0}} : {};
      }};
    };
  });
};

//# sourceMappingURL=module$node_modules$$floating_ui$core$dist$floating_ui_core_umd.js.map
