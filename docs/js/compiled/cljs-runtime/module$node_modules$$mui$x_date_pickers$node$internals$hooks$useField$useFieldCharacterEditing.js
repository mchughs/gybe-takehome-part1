shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldCharacterEditing = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.useFieldCharacterEditing = void 0;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _useEventCallback = global(require("module$node_modules$$mui$utils$node$useEventCallback$index")), _useUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useUtils"), _useField = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils");
  exports.useFieldCharacterEditing = ({sections, updateSectionValue, sectionsValueBoundaries, localizedDigits, setTempAndroidValueStr, timezone}) => {
    const utils = (0,_useUtils.useUtils)(), [query, setQuery] = React.useState(null), resetQuery = (0,_useEventCallback.default)(() => setQuery(null));
    React.useEffect(() => {
      null != query && sections[query.sectionIndex]?.type !== query.sectionType && resetQuery();
    }, [sections, query, resetQuery]);
    React.useEffect(() => {
      if (null != query) {
        const timeout = setTimeout(() => resetQuery(), 5000);
        return () => {
          clearTimeout(timeout);
        };
      }
      return () => {
      };
    }, [query, resetQuery]);
    const applyQuery = ({keyPressed, sectionIndex}, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
      keyPressed = keyPressed.toLowerCase();
      const activeSection = sections[sectionIndex];
      if (null != query && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
        isValidQueryValue = `${query.value}${keyPressed}`;
        const queryResponse = getFirstSectionValueMatchingWithQuery(isValidQueryValue, activeSection);
        if (null == queryResponse.saveQuery) {
          return setQuery({sectionIndex, value:isValidQueryValue, sectionType:activeSection.type}), queryResponse;
        }
      }
      getFirstSectionValueMatchingWithQuery = getFirstSectionValueMatchingWithQuery(keyPressed, activeSection);
      if (null != getFirstSectionValueMatchingWithQuery.saveQuery && !getFirstSectionValueMatchingWithQuery.saveQuery) {
        return resetQuery(), null;
      }
      setQuery({sectionIndex, value:keyPressed, sectionType:activeSection.type});
      return null != getFirstSectionValueMatchingWithQuery.saveQuery ? null : getFirstSectionValueMatchingWithQuery;
    }, applyLetterEditing = params => {
      const findMatchingOptions = (format, options, queryValue) => {
        format = options.filter(option => option.toLowerCase().startsWith(queryValue));
        return 0 === format.length ? {saveQuery:!1} : {sectionValue:format[0], shouldGoToNextSection:1 === format.length};
      }, testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => "letter" === activeSection.contentType ? findMatchingOptions(activeSection.format, (0,_useField.getLetterEditingOptions)(utils, timezone, activeSection.type, activeSection.format), queryValue) : fallbackFormat && null != formatFallbackValue && "letter" === (0,_useField.getDateSectionConfigFromFormatToken)(utils, fallbackFormat).contentType ? (activeSection = (0,_useField.getLetterEditingOptions)(utils, 
      timezone, activeSection.type, fallbackFormat), queryValue = findMatchingOptions(fallbackFormat, activeSection, queryValue), null != queryValue.saveQuery ? {saveQuery:!1} : (0,_extends2.default)({}, queryValue, {sectionValue:formatFallbackValue(queryValue.sectionValue, activeSection)})) : {saveQuery:!1};
      return applyQuery(params, (queryValue, activeSection) => {
        switch(activeSection.type) {
          case "month":
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.month, fallbackValue => (0,_useField.changeSectionValueFormat)(utils, fallbackValue, utils.formats.month, activeSection.format));
          case "weekDay":
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.weekday, (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString());
          case "meridiem":
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
          default:
            return {saveQuery:!1};
        }
      });
    }, applyNumericEditing = params => {
      const getNewSectionValue = (queryValue, section) => {
        var cleanQueryValue = (0,_useField.removeLocalizedDigits)(queryValue, localizedDigits);
        queryValue = Number(cleanQueryValue);
        const sectionBoundaries = sectionsValueBoundaries[section.type]({currentDate:null, format:section.format, contentType:section.contentType});
        if (queryValue > sectionBoundaries.maximum) {
          return {saveQuery:!1};
        }
        if (queryValue < sectionBoundaries.minimum) {
          return {saveQuery:!0};
        }
        cleanQueryValue = 10 * queryValue > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;
        return {sectionValue:(0,_useField.cleanDigitSectionValue)(utils, queryValue, sectionBoundaries, localizedDigits, section), shouldGoToNextSection:cleanQueryValue};
      };
      return applyQuery(params, (queryValue, activeSection) => {
        if ("digit" === activeSection.contentType || "digit-with-letter" === activeSection.contentType) {
          return getNewSectionValue(queryValue, activeSection);
        }
        if ("month" === activeSection.type) {
          const hasLeadingZerosInFormat = (0,_useField.doesSectionFormatHaveLeadingZeros)(utils, timezone, "digit", "month", "MM");
          queryValue = getNewSectionValue(queryValue, {type:activeSection.type, format:"MM", hasLeadingZerosInFormat, hasLeadingZerosInInput:!0, contentType:"digit", maxLength:2});
          if (null != queryValue.saveQuery) {
            return queryValue;
          }
          activeSection = (0,_useField.changeSectionValueFormat)(utils, queryValue.sectionValue, "MM", activeSection.format);
          return (0,_extends2.default)({}, queryValue, {sectionValue:activeSection});
        }
        if ("weekDay" === activeSection.type) {
          queryValue = getNewSectionValue(queryValue, activeSection);
          if (null != queryValue.saveQuery) {
            return queryValue;
          }
          activeSection = (0,_useField.getDaysInWeekStr)(utils, timezone, activeSection.format)[Number(queryValue.sectionValue) - 1];
          return (0,_extends2.default)({}, queryValue, {sectionValue:activeSection});
        }
        return {saveQuery:!1};
      }, queryValue => (0,_useField.isStringNumber)(queryValue, localizedDigits));
    };
    return {applyCharacterEditing:(0,_useEventCallback.default)(params => {
      const activeSection = sections[params.sectionIndex];
      params = (0,_useField.isStringNumber)(params.keyPressed, localizedDigits) ? applyNumericEditing((0,_extends2.default)({}, params, {keyPressed:(0,_useField.applyLocalizedDigits)(params.keyPressed, localizedDigits)})) : applyLetterEditing(params);
      null == params ? setTempAndroidValueStr(null) : updateSectionValue({activeSection, newSectionValue:params.sectionValue, shouldGoToNextSection:params.shouldGoToNextSection});
    }), resetCharacterQuery:resetQuery};
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldCharacterEditing.js.map
