shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldV7TextField = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.useFieldV7TextField = void 0;
  var React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _useForkRef = global(require("module$node_modules$$mui$utils$node$useForkRef$index")), _useEventCallback = global(require("module$node_modules$$mui$utils$node$useEventCallback$index")), _useEnhancedEffect = global(require("module$node_modules$$mui$utils$node$useEnhancedEffect$index")), _useId = global(require("module$node_modules$$mui$utils$node$useId$index")), _useField = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils"), 
  _utils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$utils"), _useUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useUtils");
  exports.useFieldV7TextField = params => {
    const {internalProps:{disabled, readOnly = !1}, forwardedProps:{sectionListRef:inSectionListRef, onBlur, onClick, onFocus, onInput, onPaste, focused:focusedProp, autoFocus = !1}, fieldValueManager, applyCharacterEditing, resetCharacterQuery, setSelectedSections, parsedSelectedSections, state, clearActiveSection, clearValue, updateSectionValue, updateValueFromValueStr, sectionOrder, areAllSectionsEmpty, sectionsValueBoundaries} = params, sectionListRef = React.useRef(null);
    params = (0,_useForkRef.default)(inSectionListRef, sectionListRef);
    const localeText = (0,_useUtils.useLocaleText)(), utils = (0,_useUtils.useUtils)(), id = (0,_useId.default)(), [focused, setFocused] = React.useState(!1), interactions = React.useMemo(() => ({syncSelectionToDOM:() => {
      if (sectionListRef.current) {
        var selection = document.getSelection();
        if (selection) {
          if (null == parsedSelectedSections) {
            0 < selection.rangeCount && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer) && selection.removeAllRanges(), focused && sectionListRef.current.getRoot().blur();
          } else {
            if (sectionListRef.current.getRoot().contains((0,_utils.getActiveElement)(document))) {
              var range = new window.Range();
              var target = "all" === parsedSelectedSections ? sectionListRef.current.getRoot() : "empty" === state.sections[parsedSelectedSections].type ? sectionListRef.current.getSectionContainer(parsedSelectedSections) : sectionListRef.current.getSectionContent(parsedSelectedSections);
              range.selectNodeContents(target);
              target.focus();
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
        }
      }
    }, getActiveSectionIndexFromDOM:() => {
      const activeElement = (0,_utils.getActiveElement)(document);
      return activeElement && sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement) ? sectionListRef.current.getSectionIndexFromDOMElement(activeElement) : null;
    }, focusField:(newSelectedSections = 0) => {
      sectionListRef.current && (newSelectedSections = (0,_useField.parseSelectedSections)(newSelectedSections, state.sections), setFocused(!0), sectionListRef.current.getSectionContent(newSelectedSections).focus());
    }, setSelectedSections:newSelectedSections => {
      if (sectionListRef.current) {
        var newParsedSelectedSections = (0,_useField.parseSelectedSections)(newSelectedSections, state.sections);
        setFocused(null !== ("all" === newParsedSelectedSections ? 0 : newParsedSelectedSections));
        setSelectedSections(newSelectedSections);
      }
    }, isFieldFocused:() => {
      const activeElement = (0,_utils.getActiveElement)(document);
      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);
    }}), [parsedSelectedSections, setSelectedSections, state.sections, focused]), revertDOMSectionChange = (0,_useEventCallback.default)(sectionIndex => {
      if (sectionListRef.current) {
        var section = state.sections[sectionIndex];
        sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;
        interactions.syncSelectionToDOM();
      }
    }), handleContainerClick = (0,_useEventCallback.default)((event, ...args) => {
      !event.isDefaultPrevented() && sectionListRef.current && (setFocused(!0), onClick?.(event, ...args), "all" === parsedSelectedSections ? setTimeout(() => {
        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;
        if (0 === cursorPosition) {
          setSelectedSections(sectionOrder.startIndex);
        } else {
          for (var sectionIndex = 0, cursorOnStartOfSection = 0; cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length;) {
            const section = state.sections[sectionIndex];
            sectionIndex += 1;
            cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;
          }
          setSelectedSections(sectionIndex - 1);
        }
      }) : focused ? sectionListRef.current.getRoot().contains(event.target) || setSelectedSections(sectionOrder.startIndex) : (setFocused(!0), setSelectedSections(sectionOrder.startIndex)));
    }), handleContainerInput = (0,_useEventCallback.default)(event => {
      onInput?.(event);
      sectionListRef.current && "all" === parsedSelectedSections && (event = event.target.textContent ?? "", sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join(""), interactions.syncSelectionToDOM(), 0 === event.length || 10 === event.charCodeAt(0) ? (resetCharacterQuery(), clearValue(), setSelectedSections("all")) : 1 < event.length ? updateValueFromValueStr(event) : applyCharacterEditing({keyPressed:event, 
      sectionIndex:0}));
    }), handleContainerPaste = (0,_useEventCallback.default)(event => {
      onPaste?.(event);
      if (readOnly || "all" !== parsedSelectedSections) {
        event.preventDefault();
      } else {
        var pastedValue = event.clipboardData.getData("text");
        event.preventDefault();
        resetCharacterQuery();
        updateValueFromValueStr(pastedValue);
      }
    }), handleContainerFocus = (0,_useEventCallback.default)((...args) => {
      onFocus?.(...args);
      !focused && sectionListRef.current && (setFocused(!0), null == sectionListRef.current.getSectionIndexFromDOMElement((0,_utils.getActiveElement)(document)) && setSelectedSections(sectionOrder.startIndex));
    }), handleContainerBlur = (0,_useEventCallback.default)((...args) => {
      onBlur?.(...args);
      setTimeout(() => {
        if (sectionListRef.current) {
          var activeElement = (0,_utils.getActiveElement)(document);
          sectionListRef.current.getRoot().contains(activeElement) || (setFocused(!1), setSelectedSections(null));
        }
      });
    }), getInputContainerClickHandler = (0,_useEventCallback.default)(sectionIndex => event => {
      event.isDefaultPrevented() || readOnly || setSelectedSections(sectionIndex);
    }), handleInputContentMouseUp = (0,_useEventCallback.default)(event => {
      event.preventDefault();
    }), getInputContentFocusHandler = (0,_useEventCallback.default)(sectionIndex => () => {
      readOnly || setSelectedSections(sectionIndex);
    }), handleInputContentPaste = (0,_useEventCallback.default)(event => {
      event.preventDefault();
      if (!readOnly && "number" === typeof parsedSelectedSections) {
        var activeSection = state.sections[parsedSelectedSections];
        event = event.clipboardData.getData("text");
        var lettersOnly = /^[a-zA-Z]+$/.test(event), digitsOnly = /^[0-9]+$/.test(event), digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(event);
        "letter" === activeSection.contentType && lettersOnly || "digit" === activeSection.contentType && digitsOnly || "digit-with-letter" === activeSection.contentType && digitsAndLetterOnly ? (resetCharacterQuery(), updateSectionValue({activeSection, newSectionValue:event, shouldGoToNextSection:!0})) : lettersOnly || digitsOnly || (resetCharacterQuery(), updateValueFromValueStr(event));
      }
    }), handleInputContentDragOver = (0,_useEventCallback.default)(event => {
      event.preventDefault();
      event.dataTransfer.dropEffect = "none";
    }), handleInputContentInput = (0,_useEventCallback.default)(event => {
      if (sectionListRef.current) {
        var target = event.target;
        event = target.textContent ?? "";
        target = sectionListRef.current.getSectionIndexFromDOMElement(target);
        var section = state.sections[target];
        readOnly || !sectionListRef.current ? revertDOMSectionChange(target) : 0 === event.length ? "" === section.value ? revertDOMSectionChange(target) : (resetCharacterQuery(), clearActiveSection()) : (applyCharacterEditing({keyPressed:event, sectionIndex:target}), revertDOMSectionChange(target));
      }
    });
    (0,_useEnhancedEffect.default)(() => {
      if (focused && sectionListRef.current) {
        if ("all" === parsedSelectedSections) {
          sectionListRef.current.getRoot().focus();
        } else if ("number" === typeof parsedSelectedSections) {
          const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);
          domElement && domElement.focus();
        }
      }
    }, [parsedSelectedSections, focused]);
    const sectionBoundaries = React.useMemo(() => state.sections.reduce((acc, next) => {
      acc[next.type] = sectionsValueBoundaries[next.type]({currentDate:null, contentType:next.contentType, format:next.format});
      return acc;
    }, {}), [sectionsValueBoundaries, state.sections]), isContainerEditable = "all" === parsedSelectedSections, elements = React.useMemo(() => state.sections.map((section, index) => {
      const isEditable = !isContainerEditable && !disabled && !readOnly;
      return {container:{"data-sectionindex":index, onClick:getInputContainerClickHandler(index)}, content:{tabIndex:isContainerEditable || 0 < index ? -1 : 0, contentEditable:!isContainerEditable && !disabled && !readOnly, role:"spinbutton", id:`${id}-${section.type}`, "aria-labelledby":`${id}-${section.type}`, "aria-readonly":readOnly, "aria-valuenow":(0,_useField.getSectionValueNow)(section, utils), "aria-valuemin":sectionBoundaries[section.type].minimum, "aria-valuemax":sectionBoundaries[section.type].maximum, 
      "aria-valuetext":section.value ? (0,_useField.getSectionValueText)(section, utils) : localeText.empty, "aria-label":localeText[section.type], "aria-disabled":disabled, spellCheck:isEditable ? !1 : void 0, autoCapitalize:isEditable ? "off" : void 0, autoCorrect:isEditable ? "off" : void 0, [17 <= parseInt(React.version, 10) ? "enterKeyHint" : "enterkeyhint"]:isEditable ? "next" : void 0, children:section.value || section.placeholder, onInput:handleInputContentInput, onPaste:handleInputContentPaste, 
      onFocus:getInputContentFocusHandler(index), onDragOver:handleInputContentDragOver, onMouseUp:handleInputContentMouseUp, inputMode:"letter" === section.contentType ? "text" : "numeric"}, before:{children:section.startSeparator}, after:{children:section.endSeparator}};
    }), [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, localeText, utils, sectionBoundaries, id]), handleValueStrChange = (0,_useEventCallback.default)(event => {
      updateValueFromValueStr(event.target.value);
    }), valueStr = React.useMemo(() => areAllSectionsEmpty ? "" : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);
    React.useEffect(() => {
      if (null == sectionListRef.current) {
        throw Error("MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`\nYou probably tried to pass a component to the `textField` slot that contains an `\x3cinput /\x3e` element instead of a `PickersSectionList`.\n\nIf you want to keep using an `\x3cinput /\x3e` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:\n\n\x3cDatePicker slots\x3d{{ textField: MyCustomTextField }} /\x3e\n\nLearn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element");
      }
      autoFocus && sectionListRef.current && sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();
    }, []);
    return {interactions, returnedValue:{autoFocus, readOnly, focused:focusedProp ?? focused, sectionListRef:params, onBlur:handleContainerBlur, onClick:handleContainerClick, onFocus:handleContainerFocus, onInput:handleContainerInput, onPaste:handleContainerPaste, enableAccessibleFieldDOMStructure:!0, elements, tabIndex:0 === parsedSelectedSections ? -1 : 0, contentEditable:isContainerEditable, value:valueStr, onChange:handleValueStrChange, areAllSectionsEmpty}};
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useFieldV7TextField.js.map
