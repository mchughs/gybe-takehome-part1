shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$usePicker$usePickerValue = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.usePickerValue = void 0;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _useEventCallback = global(require("module$node_modules$$mui$utils$node$useEventCallback$index")), _useOpenState = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useOpenState"), _useUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useUtils"), _useValidation = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useValidation"), _useValueWithTimezone = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useValueWithTimezone");
  const shouldPublishValue = params => {
    const {action, hasChanged, dateState, isControlled} = params;
    params = !isControlled && !dateState.hasBeenModifiedSinceMount;
    return "setValueFromField" === action.name ? !0 : "setValueFromAction" === action.name ? params && ["accept", "today", "clear"].includes(action.pickerAction) ? !0 : hasChanged(dateState.lastPublishedValue) : "setValueFromView" === action.name && "shallow" !== action.selectionState || "setValueFromShortcut" === action.name ? params ? !0 : hasChanged(dateState.lastPublishedValue) : !1;
  }, shouldCommitValue = params => {
    const {action, hasChanged, dateState, isControlled, closeOnSelect} = params;
    params = !isControlled && !dateState.hasBeenModifiedSinceMount;
    return "setValueFromAction" === action.name ? params && ["accept", "today", "clear"].includes(action.pickerAction) ? !0 : hasChanged(dateState.lastCommittedValue) : "setValueFromView" === action.name && "finish" === action.selectionState && closeOnSelect ? params ? !0 : hasChanged(dateState.lastCommittedValue) : "setValueFromShortcut" === action.name ? "accept" === action.changeImportance && hasChanged(dateState.lastCommittedValue) : !1;
  }, shouldClosePicker = params => {
    const {action, closeOnSelect} = params;
    return "setValueFromAction" === action.name ? !0 : "setValueFromView" === action.name ? "finish" === action.selectionState && closeOnSelect : "setValueFromShortcut" === action.name ? "accept" === action.changeImportance : !1;
  };
  exports.usePickerValue = ({props, valueManager, valueType, wrapperVariant, validator}) => {
    const {onAccept, onChange, value:inValue, defaultValue:inDefaultValue, closeOnSelect = "desktop" === wrapperVariant, timezone:timezoneProp} = props, {current:defaultValue} = React.useRef(inDefaultValue), {current:isControlled} = React.useRef(void 0 !== inValue);
    React.useEffect(() => {
      isControlled !== (void 0 !== inValue) && console.error([`MUI X: A component is changing the ${isControlled ? "" : "un"}controlled value of a picker to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).\nDecide between using a controlled or uncontrolled valuefor the lifetime of the component.\nThe nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.\nMore info: https://fb.me/react-controlled-components"].join("\n"));
    }, [inValue]);
    React.useEffect(() => {
      isControlled || defaultValue === inDefaultValue || console.error("MUI X: A component is changing the defaultValue of an uncontrolled picker after being initialized. To suppress this warning opt to use a controlled value.");
    }, [JSON.stringify(defaultValue)]);
    const utils = (0,_useUtils.useUtils)(), adapter = (0,_useUtils.useLocalizationContext)(), {isOpen, setIsOpen} = (0,_useOpenState.useOpenState)(props), [dateState, setDateState] = React.useState(() => {
      let initialValue;
      initialValue = void 0 !== inValue ? inValue : void 0 !== defaultValue ? defaultValue : valueManager.emptyValue;
      return {draft:initialValue, lastPublishedValue:initialValue, lastCommittedValue:initialValue, lastControlledValue:inValue, hasBeenModifiedSinceMount:!1};
    }), {timezone, handleValueChange} = (0,_useValueWithTimezone.useValueWithTimezone)({timezone:timezoneProp, value:inValue, defaultValue, onChange, valueManager});
    (0,_useValidation.useValidation)((0,_extends2.default)({}, props, {value:dateState.draft, timezone}), validator, valueManager.isSameError, valueManager.defaultErrorState);
    const updateDate = (0,_useEventCallback.default)(action => {
      var updaterParams = {action, dateState, hasChanged:comparison => !valueManager.areValuesEqual(utils, action.value, comparison), isControlled, closeOnSelect};
      const shouldPublish = shouldPublishValue(updaterParams), shouldCommit = shouldCommitValue(updaterParams);
      updaterParams = shouldClosePicker(updaterParams);
      setDateState(prev => (0,_extends2.default)({}, prev, {draft:action.value, lastPublishedValue:shouldPublish ? action.value : prev.lastPublishedValue, lastCommittedValue:shouldCommit ? action.value : prev.lastCommittedValue, hasBeenModifiedSinceMount:!0}));
      if (shouldPublish) {
        const context = {validationError:"setValueFromField" === action.name ? action.context.validationError : validator({adapter, value:action.value, props:(0,_extends2.default)({}, props, {value:action.value, timezone})})};
        "setValueFromShortcut" === action.name && (context.shortcut = action.shortcut);
        handleValueChange(action.value, context);
      }
      shouldCommit && onAccept && onAccept(action.value);
      updaterParams && setIsOpen(!1);
    });
    if (void 0 !== inValue && (void 0 === dateState.lastControlledValue || !valueManager.areValuesEqual(utils, dateState.lastControlledValue, inValue))) {
      const isUpdateComingFromPicker = valueManager.areValuesEqual(utils, dateState.draft, inValue);
      setDateState(prev => (0,_extends2.default)({}, prev, {lastControlledValue:inValue}, isUpdateComingFromPicker ? {} : {lastCommittedValue:inValue, lastPublishedValue:inValue, draft:inValue, hasBeenModifiedSinceMount:!0}));
    }
    var handleClear = (0,_useEventCallback.default)(() => {
      updateDate({value:valueManager.emptyValue, name:"setValueFromAction", pickerAction:"clear"});
    }), handleAccept = (0,_useEventCallback.default)(() => {
      updateDate({value:dateState.lastPublishedValue, name:"setValueFromAction", pickerAction:"accept"});
    });
    const handleDismiss = (0,_useEventCallback.default)(() => {
      updateDate({value:dateState.lastPublishedValue, name:"setValueFromAction", pickerAction:"dismiss"});
    }), handleCancel = (0,_useEventCallback.default)(() => {
      updateDate({value:dateState.lastCommittedValue, name:"setValueFromAction", pickerAction:"cancel"});
    }), handleSetToday = (0,_useEventCallback.default)(() => {
      updateDate({value:valueManager.getTodayValue(utils, timezone, valueType), name:"setValueFromAction", pickerAction:"today"});
    }), handleOpen = (0,_useEventCallback.default)(() => setIsOpen(!0));
    var handleClose = (0,_useEventCallback.default)(() => setIsOpen(!1));
    wrapperVariant = (0,_useEventCallback.default)((newValue, selectionState = "partial") => updateDate({name:"setValueFromView", value:newValue, selectionState}));
    const handleSelectShortcut = (0,_useEventCallback.default)((newValue, changeImportance, shortcut) => updateDate({name:"setValueFromShortcut", value:newValue, changeImportance, shortcut}));
    var handleChangeFromField = (0,_useEventCallback.default)((newValue, context) => updateDate({name:"setValueFromField", value:newValue, context}));
    handleClear = {onClear:handleClear, onAccept:handleAccept, onDismiss:handleDismiss, onCancel:handleCancel, onSetToday:handleSetToday, onOpen:handleOpen, onClose:handleClose};
    handleChangeFromField = {value:dateState.draft, onChange:handleChangeFromField};
    handleAccept = React.useMemo(() => valueManager.cleanValue(utils, dateState.draft), [utils, valueManager, dateState.draft]);
    handleClose = {value:handleAccept, onChange:wrapperVariant, onClose:handleClose, open:isOpen};
    wrapperVariant = (0,_extends2.default)({}, handleClear, {value:handleAccept, onChange:wrapperVariant, onSelectShortcut:handleSelectShortcut, isValid:testedValue => {
      testedValue = validator({adapter, value:testedValue, props:(0,_extends2.default)({}, props, {value:testedValue, timezone})});
      return !valueManager.hasError(testedValue);
    }});
    return {open:isOpen, fieldProps:handleChangeFromField, viewProps:handleClose, layoutProps:wrapperVariant, actions:handleClear};
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$usePicker$usePickerValue.js.map
