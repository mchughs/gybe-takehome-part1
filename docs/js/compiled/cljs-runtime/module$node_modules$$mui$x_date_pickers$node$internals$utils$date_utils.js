shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$utils$date_utils = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.resolveDateFormat = exports.replaceInvalidDateByNull = exports.mergeDateAndTime = exports.isDatePickerView = exports.getWeekdays = exports.getTodayDate = exports.getMonthsInYear = exports.formatMeridiem = exports.findClosestEnabledDate = exports.areDatesEqual = exports.applyDefaultDate = void 0;
  var _views = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$views");
  const mergeDateAndTime = (utils, dateParam, timeParam) => {
    dateParam = utils.setHours(dateParam, utils.getHours(timeParam));
    dateParam = utils.setMinutes(dateParam, utils.getMinutes(timeParam));
    return dateParam = utils.setSeconds(dateParam, utils.getSeconds(timeParam));
  };
  exports.mergeDateAndTime = mergeDateAndTime;
  exports.findClosestEnabledDate = ({date, disableFuture, disablePast, maxDate, minDate, isDateDisabled, utils, timezone}) => {
    timezone = mergeDateAndTime(utils, utils.date(void 0, timezone), date);
    disablePast && utils.isBefore(minDate, timezone) && (minDate = timezone);
    disableFuture && utils.isAfter(maxDate, timezone) && (maxDate = timezone);
    disablePast = disableFuture = date;
    utils.isBefore(date, minDate) && (disableFuture = minDate, disablePast = null);
    utils.isAfter(date, maxDate) && (disablePast && (disablePast = maxDate), disableFuture = null);
    for (; disableFuture || disablePast;) {
      disableFuture && utils.isAfter(disableFuture, maxDate) && (disableFuture = null);
      disablePast && utils.isBefore(disablePast, minDate) && (disablePast = null);
      if (disableFuture) {
        if (!isDateDisabled(disableFuture)) {
          return disableFuture;
        }
        disableFuture = utils.addDays(disableFuture, 1);
      }
      if (disablePast) {
        if (!isDateDisabled(disablePast)) {
          return disablePast;
        }
        disablePast = utils.addDays(disablePast, -1);
      }
    }
    return null;
  };
  exports.replaceInvalidDateByNull = (utils, value) => null != value && utils.isValid(value) ? value : null;
  exports.applyDefaultDate = (utils, value, defaultValue) => null != value && utils.isValid(value) ? value : defaultValue;
  exports.areDatesEqual = (utils, a, b) => utils.isValid(a) || null == a || utils.isValid(b) || null == b ? utils.isEqual(a, b) : !0;
  exports.getMonthsInYear = (utils, year) => {
    for (year = [utils.startOfYear(year)]; 12 > year.length;) {
      year.push(utils.addMonths(year[year.length - 1], 1));
    }
    return year;
  };
  exports.getTodayDate = (utils, timezone, valueType) => "date" === valueType ? utils.startOfDay(utils.date(void 0, timezone)) : utils.date(void 0, timezone);
  exports.formatMeridiem = (utils, meridiem) => {
    meridiem = utils.setHours(utils.date(), "am" === meridiem ? 2 : 14);
    return utils.format(meridiem, "meridiem");
  };
  const dateViews = ["year", "month", "day"];
  exports.isDatePickerView = view => dateViews.includes(view);
  exports.resolveDateFormat = (utils, {format, views}, isInToolbar) => {
    if (null != format) {
      return format;
    }
    format = utils.formats;
    return (0,_views.areViewsEqual)(views, ["year"]) ? format.year : (0,_views.areViewsEqual)(views, ["month"]) ? format.month : (0,_views.areViewsEqual)(views, ["day"]) ? format.dayOfMonth : (0,_views.areViewsEqual)(views, ["month", "year"]) ? `${format.month} ${format.year}` : (0,_views.areViewsEqual)(views, ["day", "month"]) ? `${format.month} ${format.dayOfMonth}` : isInToolbar ? /en/.test(utils.getCurrentLocaleCode()) ? format.normalDateWithWeekday : format.normalDate : format.keyboardDate;
  };
  exports.getWeekdays = (utils, date) => {
    const start = utils.startOfWeek(date);
    return [0, 1, 2, 3, 4, 5, 6].map(diff => utils.addDays(start, diff));
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$utils$date_utils.js.map
