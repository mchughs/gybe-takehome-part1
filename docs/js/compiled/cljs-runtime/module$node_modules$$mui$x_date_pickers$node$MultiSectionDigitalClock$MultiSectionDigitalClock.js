shadow$provide.module$node_modules$$mui$x_date_pickers$node$MultiSectionDigitalClock$MultiSectionDigitalClock = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  module = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.MultiSectionDigitalClock = void 0;
  var _extends2 = module(require("module$node_modules$$babel$runtime$helpers$extends")), _objectWithoutPropertiesLoose2 = module(require("module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index")), _clsx = module(require("module$node_modules$clsx$dist$clsx"));
  global = module(require("module$node_modules$prop_types$index"));
  var _styles = require("module$node_modules$$mui$material$node$styles$index"), _useEventCallback = module(require("module$node_modules$$mui$utils$node$useEventCallback$index")), _composeClasses = module(require("module$node_modules$$mui$utils$node$composeClasses$index")), _useUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useUtils"), _timeUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$time_utils"), _useViews = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useViews"), 
  _dateHelpersHooks = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$date_helpers_hooks");
  module = require("module$node_modules$$mui$x_date_pickers$node$internals$components$PickerViewRoot$index");
  var _multiSectionDigitalClockClasses = require("module$node_modules$$mui$x_date_pickers$node$MultiSectionDigitalClock$multiSectionDigitalClockClasses"), _MultiSectionDigitalClockSection = require("module$node_modules$$mui$x_date_pickers$node$MultiSectionDigitalClock$MultiSectionDigitalClockSection"), _MultiSectionDigitalClock = require("module$node_modules$$mui$x_date_pickers$node$MultiSectionDigitalClock$MultiSectionDigitalClock_utils"), _useValueWithTimezone = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useValueWithTimezone"), 
  _valueManagers = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$valueManagers"), _useClockReferenceDate = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useClockReferenceDate"), _dateUtils = require("module$node_modules$$mui$x_date_pickers$node$internals$utils$date_utils"), _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  const _excluded = "ampm timeSteps autoFocus slots slotProps value defaultValue referenceDate disableIgnoringDatePartForTimeValidation maxTime minTime disableFuture disablePast minutesStep shouldDisableTime onChange view views openTo onViewChange focusedView onFocusedViewChange className disabled readOnly skipDisabled timezone".split(" "), useUtilityClasses = ownerState => {
    ({classes:ownerState} = ownerState);
    return (0,_composeClasses.default)({root:["root"]}, _multiSectionDigitalClockClasses.getMultiSectionDigitalClockUtilityClass, ownerState);
  }, MultiSectionDigitalClockRoot = (0,_styles.styled)(module.PickerViewRoot, {name:"MuiMultiSectionDigitalClock", slot:"Root", overridesResolver:(_, styles) => styles.root})(({theme}) => ({display:"flex", flexDirection:"row", width:"100%", borderBottom:`1px solid ${(theme.vars || theme).palette.divider}`}));
  (exports.MultiSectionDigitalClock = React.forwardRef(function(inProps, ref) {
    const utils = (0,_useUtils.useUtils)();
    inProps = (0,_styles.useThemeProps)({props:inProps, name:"MuiMultiSectionDigitalClock"});
    const {ampm = utils.is12HourCycleInCurrentLocale(), timeSteps:inTimeSteps, autoFocus, slots, slotProps, value:valueProp, defaultValue, referenceDate:referenceDateProp, disableIgnoringDatePartForTimeValidation = !1, maxTime, minTime, disableFuture, disablePast, minutesStep = 1, shouldDisableTime, onChange, view:inView, views:inViews = ["hours", "minutes"], openTo, onViewChange, focusedView:inFocusedView, onFocusedViewChange, className, disabled, readOnly, skipDisabled = !1, timezone:timezoneProp} = 
    inProps, other = (0,_objectWithoutPropertiesLoose2.default)(inProps, _excluded), {value, handleValueChange:handleRawValueChange, timezone} = (0,_useValueWithTimezone.useControlledValueWithTimezone)({name:"MultiSectionDigitalClock", timezone:timezoneProp, value:valueProp, defaultValue, onChange, valueManager:_valueManagers.singleItemValueManager}), localeText = (0,_useUtils.useLocaleText)(), now = (0,_useUtils.useNow)(timezone), timeSteps = React.useMemo(() => (0,_extends2.default)({hours:1, minutes:5, 
    seconds:5}, inTimeSteps), [inTimeSteps]), valueOrReferenceDate = (0,_useClockReferenceDate.useClockReferenceDate)({value, referenceDate:referenceDateProp, utils, props:inProps, timezone});
    var handleValueChange = (0,_useEventCallback.default)((newValue, selectionState, selectedView) => handleRawValueChange(newValue, selectionState, selectedView));
    const views = React.useMemo(() => ampm && inViews.includes("hours") ? inViews.includes("meridiem") ? inViews : [...inViews, "meridiem"] : inViews, [ampm, inViews]), {view, setValueAndGoToNextView, focusedView} = (0,_useViews.useViews)({view:inView, views, openTo, onViewChange, onChange:handleValueChange, focusedView:inFocusedView, onFocusedViewChange});
    handleValueChange = (0,_useEventCallback.default)(newValue => {
      setValueAndGoToNextView(newValue, "finish", "meridiem");
    });
    const {meridiemMode, handleMeridiemChange} = (0,_dateHelpersHooks.useMeridiemMode)(valueOrReferenceDate, ampm, handleValueChange, "finish"), isTimeDisabled = React.useCallback((rawValue, viewType) => {
      const isAfter = (0,_timeUtils.createIsAfterIgnoreDatePart)(disableIgnoringDatePartForTimeValidation, utils), shouldCheckPastEnd = "hours" === viewType || "minutes" === viewType && views.includes("seconds"), containsValidTime = ({start, end}) => minTime && isAfter(minTime, end) || maxTime && isAfter(start, maxTime) || disableFuture && isAfter(start, now) || disablePast && isAfter(now, shouldCheckPastEnd ? end : start) ? !1 : !0, isValidValue = (timeValue, step = 1) => {
        if (0 !== timeValue % step) {
          return !1;
        }
        if (shouldDisableTime) {
          switch(viewType) {
            case "hours":
              return !shouldDisableTime(utils.setHours(valueOrReferenceDate, timeValue), "hours");
            case "minutes":
              return !shouldDisableTime(utils.setMinutes(valueOrReferenceDate, timeValue), "minutes");
            case "seconds":
              return !shouldDisableTime(utils.setSeconds(valueOrReferenceDate, timeValue), "seconds");
            default:
              return !1;
          }
        }
        return !0;
      };
      switch(viewType) {
        case "hours":
          rawValue = (0,_timeUtils.convertValueToMeridiem)(rawValue, meridiemMode, ampm);
          var dateWithNewHours = utils.setHours(valueOrReferenceDate, rawValue), start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
          dateWithNewHours = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
          return !containsValidTime({start, end:dateWithNewHours}) || !isValidValue(rawValue);
        case "minutes":
          return dateWithNewHours = utils.setMinutes(valueOrReferenceDate, rawValue), start = utils.setSeconds(dateWithNewHours, 0), dateWithNewHours = utils.setSeconds(dateWithNewHours, 59), !containsValidTime({start, end:dateWithNewHours}) || !isValidValue(rawValue, minutesStep);
        case "seconds":
          return start = utils.setSeconds(valueOrReferenceDate, rawValue), !containsValidTime({start, end:start}) || !isValidValue(rawValue);
        default:
          throw Error("not supported");
      }
    }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils, disableFuture, disablePast, now, views]), buildViewProps = React.useCallback(viewToBuild => {
      switch(viewToBuild) {
        case "hours":
          return {onChange:hours => {
            hours = (0,_timeUtils.convertValueToMeridiem)(hours, meridiemMode, ampm);
            setValueAndGoToNextView(utils.setHours(valueOrReferenceDate, hours), "finish", "hours");
          }, items:(0,_MultiSectionDigitalClock.getHourSectionOptions)({now, value, ampm, utils, isDisabled:hours => isTimeDisabled(hours, "hours"), timeStep:timeSteps.hours, resolveAriaLabel:localeText.hoursClockNumberText, valueOrReferenceDate})};
        case "minutes":
          return {onChange:minutes => {
            setValueAndGoToNextView(utils.setMinutes(valueOrReferenceDate, minutes), "finish", "minutes");
          }, items:(0,_MultiSectionDigitalClock.getTimeSectionOptions)({value:utils.getMinutes(valueOrReferenceDate), utils, isDisabled:minutes => isTimeDisabled(minutes, "minutes"), resolveLabel:minutes => utils.format(utils.setMinutes(now, minutes), "minutes"), timeStep:timeSteps.minutes, hasValue:!!value, resolveAriaLabel:localeText.minutesClockNumberText})};
        case "seconds":
          return {onChange:seconds => {
            setValueAndGoToNextView(utils.setSeconds(valueOrReferenceDate, seconds), "finish", "seconds");
          }, items:(0,_MultiSectionDigitalClock.getTimeSectionOptions)({value:utils.getSeconds(valueOrReferenceDate), utils, isDisabled:seconds => isTimeDisabled(seconds, "seconds"), resolveLabel:seconds => utils.format(utils.setSeconds(now, seconds), "seconds"), timeStep:timeSteps.seconds, hasValue:!!value, resolveAriaLabel:localeText.secondsClockNumberText})};
        case "meridiem":
          viewToBuild = (0,_dateUtils.formatMeridiem)(utils, "am");
          const pmLabel = (0,_dateUtils.formatMeridiem)(utils, "pm");
          return {onChange:handleMeridiemChange, items:[{value:"am", label:viewToBuild, isSelected:() => !!value && "am" === meridiemMode, isFocused:() => !!valueOrReferenceDate && "am" === meridiemMode, ariaLabel:viewToBuild}, {value:"pm", label:pmLabel, isSelected:() => !!value && "pm" === meridiemMode, isFocused:() => !!valueOrReferenceDate && "pm" === meridiemMode, ariaLabel:pmLabel}]};
        default:
          throw Error(`Unknown view: ${viewToBuild} found.`);
      }
    }, [now, value, ampm, utils, timeSteps.hours, timeSteps.minutes, timeSteps.seconds, localeText.hoursClockNumberText, localeText.minutesClockNumberText, localeText.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, handleMeridiemChange]);
    handleValueChange = React.useMemo(() => views.reduce((result, currentView) => (0,_extends2.default)({}, result, {[currentView]:buildViewProps(currentView)}), {}), [views, buildViewProps]);
    const classes = useUtilityClasses(inProps);
    return (0,_jsxRuntime.jsx)(MultiSectionDigitalClockRoot, (0,_extends2.default)({ref, className:(0,_clsx.default)(classes.root, className), ownerState:inProps, role:"group"}, other, {children:Object.entries(handleValueChange).map(([timeView, viewOptions]) => (0,_jsxRuntime.jsx)(_MultiSectionDigitalClockSection.MultiSectionDigitalClockSection, {items:viewOptions.items, onChange:viewOptions.onChange, active:view === timeView, autoFocus:autoFocus ?? focusedView === timeView, disabled, readOnly, slots, 
    slotProps, skipDisabled, "aria-label":localeText.selectViewText(timeView)}, timeView))}));
  })).propTypes = {ampm:global.default.bool, autoFocus:global.default.bool, classes:global.default.object, className:global.default.string, defaultValue:global.default.object, disabled:global.default.bool, disableFuture:global.default.bool, disableIgnoringDatePartForTimeValidation:global.default.bool, disablePast:global.default.bool, focusedView:global.default.oneOf(["hours", "meridiem", "minutes", "seconds"]), maxTime:global.default.object, minTime:global.default.object, minutesStep:global.default.number, 
  onChange:global.default.func, onFocusedViewChange:global.default.func, onViewChange:global.default.func, openTo:global.default.oneOf(["hours", "meridiem", "minutes", "seconds"]), readOnly:global.default.bool, referenceDate:global.default.object, shouldDisableTime:global.default.func, skipDisabled:global.default.bool, slotProps:global.default.object, slots:global.default.object, sx:global.default.oneOfType([global.default.arrayOf(global.default.oneOfType([global.default.func, global.default.object, 
  global.default.bool])), global.default.func, global.default.object]), timeSteps:global.default.shape({hours:global.default.number, minutes:global.default.number, seconds:global.default.number}), timezone:global.default.string, value:global.default.object, view:global.default.oneOf(["hours", "meridiem", "minutes", "seconds"]), views:global.default.arrayOf(global.default.oneOf(["hours", "meridiem", "minutes", "seconds"]).isRequired)};
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$MultiSectionDigitalClock$MultiSectionDigitalClock.js.map
