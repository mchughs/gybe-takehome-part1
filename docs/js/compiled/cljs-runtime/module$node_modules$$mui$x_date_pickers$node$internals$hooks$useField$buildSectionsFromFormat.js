shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$buildSectionsFromFormat = function(global, require, module, exports) {
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.buildSectionsFromFormat = void 0;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), _useField = require("module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils");
  const expandFormat = ({utils, format}) => {
    let formatExpansionOverflow = 10, prevFormat = format;
    for (format = utils.expandFormat(format); format !== prevFormat;) {
      if (prevFormat = format, format = utils.expandFormat(prevFormat), --formatExpansionOverflow, 0 > formatExpansionOverflow) {
        throw Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");
      }
    }
    return format;
  }, getEscapedPartsFromFormat = ({utils, expandedFormat}) => {
    const escapedParts = [], {start:startChar, end:endChar} = utils.escapedCharacters;
    utils = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, "g");
    let match;
    for (; match = utils.exec(expandedFormat);) {
      escapedParts.push({start:match.index, end:utils.lastIndex - 1});
    }
    return escapedParts;
  }, getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, sectionFormat) => {
    switch(sectionConfig.type) {
      case "year":
        return localeText.fieldYearPlaceholder({digitAmount:utils.formatByString(utils.date(void 0, timezone), sectionFormat).length, format:sectionFormat});
      case "month":
        return localeText.fieldMonthPlaceholder({contentType:sectionConfig.contentType, format:sectionFormat});
      case "day":
        return localeText.fieldDayPlaceholder({format:sectionFormat});
      case "weekDay":
        return localeText.fieldWeekDayPlaceholder({contentType:sectionConfig.contentType, format:sectionFormat});
      case "hours":
        return localeText.fieldHoursPlaceholder({format:sectionFormat});
      case "minutes":
        return localeText.fieldMinutesPlaceholder({format:sectionFormat});
      case "seconds":
        return localeText.fieldSecondsPlaceholder({format:sectionFormat});
      case "meridiem":
        return localeText.fieldMeridiemPlaceholder({format:sectionFormat});
      default:
        return sectionFormat;
    }
  }, createSection = ({utils, timezone, date, shouldRespectLeadingZeros, localeText, localizedDigits, now, token, startSeparator}) => {
    if ("" === token) {
      throw Error("MUI X: Should not call `commitToken` with an empty token");
    }
    const sectionConfig = (0,_useField.getDateSectionConfigFromFormatToken)(utils, token), hasLeadingZerosInFormat = (0,_useField.doesSectionFormatHaveLeadingZeros)(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);
    shouldRespectLeadingZeros = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : "digit" === sectionConfig.contentType;
    const isValidDate = null != date && utils.isValid(date);
    date = isValidDate ? utils.formatByString(date, token) : "";
    let maxLength = null;
    if (shouldRespectLeadingZeros) {
      if (hasLeadingZerosInFormat) {
        maxLength = "" === date ? utils.formatByString(now, token).length : date.length;
      } else {
        if (null == sectionConfig.maxLength) {
          throw Error(`MUI X: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);
        }
        maxLength = sectionConfig.maxLength;
        isValidDate && (date = (0,_useField.applyLocalizedDigits)((0,_useField.cleanLeadingZeros)((0,_useField.removeLocalizedDigits)(date, localizedDigits), maxLength), localizedDigits));
      }
    }
    return (0,_extends2.default)({}, sectionConfig, {format:token, maxLength, value:date, placeholder:getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token), hasLeadingZerosInFormat, hasLeadingZerosInInput:shouldRespectLeadingZeros, startSeparator, endSeparator:"", modified:!1});
  }, buildSections = params => {
    const {utils, expandedFormat, escapedParts} = params, now = utils.date(void 0), sections = [];
    let startSeparator = "";
    var validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length);
    const regExpFirstWordInFormat = /^([a-zA-Z]+)/, regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join("|")})*$`);
    validTokens = new RegExp(`^(${validTokens.join("|")})`);
    const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);
    let i = 0;
    for (; i < expandedFormat.length;) {
      var escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i), isEscapedChar = null != escapedPartOfCurrentChar, firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];
      if (!isEscapedChar && null != firstWordInFormat && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {
        for (escapedPartOfCurrentChar = firstWordInFormat; 0 < escapedPartOfCurrentChar.length;) {
          isEscapedChar = validTokens.exec(escapedPartOfCurrentChar)[1], escapedPartOfCurrentChar = escapedPartOfCurrentChar.slice(isEscapedChar.length), sections.push(createSection((0,_extends2.default)({}, params, {now, token:isEscapedChar, startSeparator}))), startSeparator = "";
        }
        i += firstWordInFormat.length;
      } else {
        firstWordInFormat = expandedFormat[i], isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i || (0 === sections.length ? startSeparator += firstWordInFormat : sections[sections.length - 1].endSeparator += firstWordInFormat), i += 1;
      }
    }
    0 === sections.length && 0 < startSeparator.length && sections.push({type:"empty", contentType:"letter", maxLength:null, format:"", value:"", placeholder:"", hasLeadingZerosInFormat:!1, hasLeadingZerosInInput:!1, startSeparator, endSeparator:"", modified:!1});
    return sections;
  }, postProcessSections = ({isRTL, formatDensity, sections}) => sections.map(section => {
    const cleanSeparator = separator => {
      isRTL && null !== separator && separator.includes(" ") && (separator = `\u2069${separator}\u2066`);
      "spacious" === formatDensity && ["/", ".", "-"].includes(separator) && (separator = ` ${separator} `);
      return separator;
    };
    section.startSeparator = cleanSeparator(section.startSeparator);
    section.endSeparator = cleanSeparator(section.endSeparator);
    return section;
  });
  exports.buildSectionsFromFormat = params => {
    var expandedFormat = expandFormat(params);
    params.isRTL && params.enableAccessibleFieldDOMStructure && (expandedFormat = expandedFormat.split(" ").reverse().join(" "));
    const escapedParts = getEscapedPartsFromFormat((0,_extends2.default)({}, params, {expandedFormat}));
    expandedFormat = buildSections((0,_extends2.default)({}, params, {expandedFormat, escapedParts}));
    return postProcessSections((0,_extends2.default)({}, params, {sections:expandedFormat}));
  };
};

//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$buildSectionsFromFormat.js.map
