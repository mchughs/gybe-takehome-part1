shadow$provide.module$node_modules$$mui$base$node$TextareaAutosize$TextareaAutosize = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.TextareaAutosize = void 0;
  var _extends2 = global(require("module$node_modules$$babel$runtime$helpers$extends")), _objectWithoutPropertiesLoose2 = global(require("module$node_modules$$babel$runtime$helpers$objectWithoutPropertiesLoose")), React = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index"));
  global = global(require("module$node_modules$prop_types$index"));
  var _utils = require("module$node_modules$$mui$utils$node$index"), _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  const _excluded = ["onChange", "maxRows", "minRows", "style", "value"];
  var JSCompiler_object_inline_shadow_770 = {visibility:"hidden", position:"absolute", overflow:"hidden", height:0, top:0, left:0, transform:"translateZ(0)"};
  (exports.TextareaAutosize = React.forwardRef(function(props, forwardedRef) {
    const {onChange, maxRows, minRows = 1, style, value} = props, other = (0,_objectWithoutPropertiesLoose2.default)(props, _excluded), {current:isControlled} = React.useRef(null != value), inputRef = React.useRef(null);
    forwardedRef = (0,_utils.unstable_useForkRef)(forwardedRef, inputRef);
    const shadowRef = React.useRef(null), calculateTextareaStyles = React.useCallback(() => {
      var input = inputRef.current, computedStyle = (0,_utils.unstable_ownerWindow)(input).getComputedStyle(input);
      if ("0px" === computedStyle.width) {
        return {outerHeightStyle:0, overflowing:!1};
      }
      var inputShallow = shadowRef.current;
      inputShallow.style.width = computedStyle.width;
      inputShallow.value = input.value || props.placeholder || "x";
      "\n" === inputShallow.value.slice(-1) && (inputShallow.value += " ");
      input = computedStyle.boxSizing;
      const padding = (parseInt(computedStyle.paddingBottom, 10) || 0) + (parseInt(computedStyle.paddingTop, 10) || 0);
      computedStyle = (parseInt(computedStyle.borderBottomWidth, 10) || 0) + (parseInt(computedStyle.borderTopWidth, 10) || 0);
      const innerHeight = inputShallow.scrollHeight;
      inputShallow.value = "x";
      inputShallow = inputShallow.scrollHeight;
      let outerHeight = innerHeight;
      minRows && (outerHeight = Math.max(Number(minRows) * inputShallow, outerHeight));
      maxRows && (outerHeight = Math.min(Number(maxRows) * inputShallow, outerHeight));
      outerHeight = Math.max(outerHeight, inputShallow);
      return {outerHeightStyle:outerHeight + ("border-box" === input ? padding + computedStyle : 0), overflowing:1 >= Math.abs(outerHeight - innerHeight)};
    }, [maxRows, minRows, props.placeholder]), syncHeight = React.useCallback(() => {
      const textareaStyles = calculateTextareaStyles();
      if (void 0 !== textareaStyles && null !== textareaStyles && 0 !== Object.keys(textareaStyles).length && (0 !== textareaStyles.outerHeightStyle || textareaStyles.overflowing)) {
        var input = inputRef.current;
        input.style.height = `${textareaStyles.outerHeightStyle}px`;
        input.style.overflow = textareaStyles.overflowing ? "hidden" : "";
      }
    }, [calculateTextareaStyles]);
    (0,_utils.unstable_useEnhancedEffect)(() => {
      const handleResize = () => {
        syncHeight();
      }, debounceHandleResize = (0,_utils.unstable_debounce)(handleResize), input = inputRef.current, containerWindow = (0,_utils.unstable_ownerWindow)(input);
      containerWindow.addEventListener("resize", debounceHandleResize);
      let resizeObserver;
      "undefined" !== typeof ResizeObserver && (resizeObserver = new ResizeObserver(handleResize), resizeObserver.observe(input));
      return () => {
        debounceHandleResize.clear();
        cancelAnimationFrame(void 0);
        containerWindow.removeEventListener("resize", debounceHandleResize);
        resizeObserver && resizeObserver.disconnect();
      };
    }, [calculateTextareaStyles, syncHeight]);
    (0,_utils.unstable_useEnhancedEffect)(() => {
      syncHeight();
    });
    return (0,_jsxRuntime.jsxs)(React.Fragment, {children:[(0,_jsxRuntime.jsx)("textarea", (0,_extends2.default)({value, onChange:event => {
      isControlled || syncHeight();
      onChange && onChange(event);
    }, ref:forwardedRef, rows:minRows, style}, other)), (0,_jsxRuntime.jsx)("textarea", {"aria-hidden":!0, className:props.className, readOnly:!0, ref:shadowRef, tabIndex:-1, style:(0,_extends2.default)({}, JSCompiler_object_inline_shadow_770, style, {paddingTop:0, paddingBottom:0})})]});
  })).propTypes = {className:global.default.string, maxRows:global.default.oneOfType([global.default.number, global.default.string]), minRows:global.default.oneOfType([global.default.number, global.default.string]), onChange:global.default.func, placeholder:global.default.string, style:global.default.object, value:global.default.oneOfType([global.default.arrayOf(global.default.string), global.default.number, global.default.string])};
};

//# sourceMappingURL=module$node_modules$$mui$base$node$TextareaAutosize$TextareaAutosize.js.map
